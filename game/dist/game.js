/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/adapter/weapp-adapter.js":
/*!**************************************!*\
  !*** ./src/adapter/weapp-adapter.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/helpers/esm/typeof */ "./node_modules/@babel/runtime-corejs3/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/define-property */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/for-each */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/keys */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/assign */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/assign.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/set-prototype-of */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/set-prototype-of.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-prototype-of */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-prototype-of.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_parse_int__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/parse-int */ "./node_modules/@babel/runtime-corejs3/core-js-stable/parse-int.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_parse_int__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_parse_int__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_number_is_nan__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/number/is-nan */ "./node_modules/@babel/runtime-corejs3/core-js-stable/number/is-nan.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_number_is_nan__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_number_is_nan__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_find_index__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/find-index */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/find-index.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_find_index__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_find_index__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_splice__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/splice */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/splice.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_splice__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_splice__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/weak-map */ "./node_modules/@babel/runtime-corejs3/core-js-stable/weak-map.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_index_of__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/index-of */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/index-of.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_index_of__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_index_of__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_slice__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/slice */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/slice.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_slice__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_slice__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/map */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_json_stringify__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/json/stringify */ "./node_modules/@babel/runtime-corejs3/core-js-stable/json/stringify.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_json_stringify__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_json_stringify__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_keys__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/keys */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/keys.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_keys__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_keys__WEBPACK_IMPORTED_MODULE_17__);


















/******/(function (modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/
  var installedModules = {};

  /******/ // The require function
  /******/
  function __nested_webpack_require_1778__(moduleId) {
    /******/ // Check if module is in cache
    /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;

    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = installedModules[moduleId] = {
      /******/exports: {},
      /******/id: moduleId,
      /******/loaded: false
      /******/
    };

    /******/ // Execute the module function
    /******/
    modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1778__);

    /******/ // Flag the module as loaded
    /******/
    module.loaded = true;

    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }

  /******/ // expose the modules object (__webpack_modules__)
  /******/
  __nested_webpack_require_1778__.m = modules;

  /******/ // expose the module cache
  /******/
  __nested_webpack_require_1778__.c = installedModules;

  /******/ // __webpack_public_path__
  /******/
  __nested_webpack_require_1778__.p = "";

  /******/ // Load entry module and return exports
  /******/
  return __nested_webpack_require_1778__(0);
  /******/
}
/************************************************************************/
/******/)([/* 0 */
/***/function (module, exports, __nested_webpack_require_3043__) {
  'use strict';

  var _window2 = __nested_webpack_require_3043__(1);
  var _window = _interopRequireWildcard(_window2);
  var _HTMLElement = __nested_webpack_require_3043__(5);
  var _HTMLElement2 = _interopRequireDefault(_HTMLElement);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  var global = GameGlobal;
  function inject() {
    _window.addEventListener = function (type, listener) {
      _window.document.addEventListener(type, listener);
    };
    _window.removeEventListener = function (type, listener) {
      _window.document.removeEventListener(type, listener);
    };
    if (_window.canvas) {
      _window.canvas.addEventListener = _window.addEventListener;
      _window.canvas.removeEventListener = _window.removeEventListener;
    }
    var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
      platform = _wx$getSystemInfoSync.platform;

    // 开发者工具无法重定义 window

    if (platform === 'devtools') {
      for (var key in _window) {
        var descriptor = _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_1___default()(global, key);
        if (!descriptor || descriptor.configurable === true) {
          _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(window, key, {
            value: _window[key]
          });
        }
      }
      for (var _key in _window.document) {
        var _descriptor = _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_1___default()(global.document, _key);
        if (!_descriptor || _descriptor.configurable === true) {
          _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(global.document, _key, {
            value: _window.document[_key]
          });
        }
      }
      window.parent = window;
    } else {
      for (var _key2 in _window) {
        global[_key2] = _window[_key2];
      }
      global.window = _window;
      window = global;
      window.top = window.parent = window;
    }
  }
  if (!GameGlobal.__isAdapterInjected) {
    GameGlobal.__isAdapterInjected = true;
    inject();
  }

  /***/
}, /* 1 */
/***/function (module, exports, __nested_webpack_require_5370__) {
  'use strict';

  var _context, _context2;
  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  exports.cancelAnimationFrame = exports.requestAnimationFrame = exports.clearInterval = exports.clearTimeout = exports.setInterval = exports.setTimeout = exports.canvas = exports.TouchEvent = exports.location = exports.localStorage = exports.HTMLElement = exports.FileReader = exports.Audio = exports.Image = exports.WebSocket = exports.XMLHttpRequest = exports.navigator = exports.document = undefined;
  var _WindowProperties = __nested_webpack_require_5370__(2);
  _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3___default()(_context = _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_4___default()(_WindowProperties)).call(_context, function (key) {
    if (key === "default" || key === "__esModule") return;
    _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, key, {
      enumerable: true,
      get: function get() {
        return _WindowProperties[key];
      }
    });
  });
  var _constructor = __nested_webpack_require_5370__(4);
  _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3___default()(_context2 = _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_4___default()(_constructor)).call(_context2, function (key) {
    if (key === "default" || key === "__esModule") return;
    _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, key, {
      enumerable: true,
      get: function get() {
        return _constructor[key];
      }
    });
  });
  var _Canvas = __nested_webpack_require_5370__(10);
  var _Canvas2 = _interopRequireDefault(_Canvas);
  var _document2 = __nested_webpack_require_5370__(11);
  var _document3 = _interopRequireDefault(_document2);
  var _navigator2 = __nested_webpack_require_5370__(18);
  var _navigator3 = _interopRequireDefault(_navigator2);
  var _XMLHttpRequest2 = __nested_webpack_require_5370__(19);
  var _XMLHttpRequest3 = _interopRequireDefault(_XMLHttpRequest2);
  var _WebSocket2 = __nested_webpack_require_5370__(20);
  var _WebSocket3 = _interopRequireDefault(_WebSocket2);
  var _Image2 = __nested_webpack_require_5370__(12);
  var _Image3 = _interopRequireDefault(_Image2);
  var _Audio2 = __nested_webpack_require_5370__(13);
  var _Audio3 = _interopRequireDefault(_Audio2);
  var _FileReader2 = __nested_webpack_require_5370__(21);
  var _FileReader3 = _interopRequireDefault(_FileReader2);
  var _HTMLElement2 = __nested_webpack_require_5370__(5);
  var _HTMLElement3 = _interopRequireDefault(_HTMLElement2);
  var _localStorage2 = __nested_webpack_require_5370__(22);
  var _localStorage3 = _interopRequireDefault(_localStorage2);
  var _location2 = __nested_webpack_require_5370__(23);
  var _location3 = _interopRequireDefault(_location2);
  var _TouchEvent2 = __nested_webpack_require_5370__(17);
  var _TouchEvent3 = _interopRequireDefault(_TouchEvent2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  exports.document = _document3.default;
  exports.navigator = _navigator3.default;
  exports.XMLHttpRequest = _XMLHttpRequest3.default;
  exports.WebSocket = _WebSocket3.default;
  exports.Image = _Image3.default;
  exports.Audio = _Audio3.default;
  exports.FileReader = _FileReader3.default;
  exports.HTMLElement = _HTMLElement3.default;
  exports.localStorage = _localStorage3.default;
  exports.location = _location3.default;
  exports.TouchEvent = _TouchEvent3.default;

  // 暴露全局的 canvas
  var canvas = new _Canvas2.default();
  exports.canvas = canvas;
  exports.setTimeout = setTimeout;
  exports.setInterval = setInterval;
  exports.clearTimeout = clearTimeout;
  exports.clearInterval = clearInterval;
  exports.requestAnimationFrame = requestAnimationFrame;
  exports.cancelAnimationFrame = cancelAnimationFrame;

  /***/
}, /* 2 */
/***/function (module, exports, __nested_webpack_require_8847__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  exports.performance = exports.ontouchend = exports.ontouchmove = exports.ontouchstart = exports.screen = exports.devicePixelRatio = exports.innerHeight = exports.innerWidth = undefined;
  var _performance2 = __nested_webpack_require_8847__(3);
  var _performance3 = _interopRequireDefault(_performance2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
    screenWidth = _wx$getSystemInfoSync.screenWidth,
    screenHeight = _wx$getSystemInfoSync.screenHeight,
    devicePixelRatio = _wx$getSystemInfoSync.devicePixelRatio;
  var innerWidth = exports.innerWidth = screenWidth;
  var innerHeight = exports.innerHeight = screenHeight;
  exports.devicePixelRatio = devicePixelRatio;
  var screen = exports.screen = {
    availWidth: innerWidth,
    availHeight: innerHeight
  };
  var ontouchstart = exports.ontouchstart = null;
  var ontouchmove = exports.ontouchmove = null;
  var ontouchend = exports.ontouchend = null;
  exports.performance = _performance3.default;

  /***/
}, /* 3 */
/***/function (module, exports) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var performance = void 0;
  if (wx.getPerformance) {
    var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
      platform = _wx$getSystemInfoSync.platform;
    var wxPerf = wx.getPerformance();
    var initTime = wxPerf.now();
    var clientPerfAdapter = _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_5___default()({}, wxPerf, {
      now: function now() {
        return (wxPerf.now() - initTime) / 1000;
      }
    });
    performance = platform === 'devtools' ? wxPerf : clientPerfAdapter;
  }
  exports.default = performance;

  /***/
}, /* 4 */
/***/function (module, exports, __nested_webpack_require_10721__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  exports.HTMLCanvasElement = exports.HTMLImageElement = undefined;
  var _HTMLElement2 = __nested_webpack_require_10721__(5);
  var _HTMLElement3 = _interopRequireDefault(_HTMLElement2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(superClass));
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) (_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var HTMLImageElement = wx.createImage().constructor;
  var HTMLCanvasElement = function (_HTMLElement) {
    _inherits(HTMLCanvasElement, _HTMLElement);
    function HTMLCanvasElement() {
      _classCallCheck(this, HTMLCanvasElement);
      return _possibleConstructorReturn(this, (HTMLCanvasElement.__proto__ || _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default()(HTMLCanvasElement)).call(this, 'canvas'));
    }
    return HTMLCanvasElement;
  }(_HTMLElement3.default);
  exports.HTMLImageElement = HTMLImageElement;
  exports.HTMLCanvasElement = HTMLCanvasElement;

  /***/
}, /* 5 */
/***/function (module, exports, __nested_webpack_require_12726__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _Element2 = __nested_webpack_require_12726__(6);
  var _Element3 = _interopRequireDefault(_Element2);
  var _util = __nested_webpack_require_12726__(9);
  var _WindowProperties = __nested_webpack_require_12726__(2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(superClass));
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) (_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var HTMLElement = function (_Element) {
    _inherits(HTMLElement, _Element);
    function HTMLElement() {
      var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      _classCallCheck(this, HTMLElement);
      var _this = _possibleConstructorReturn(this, (HTMLElement.__proto__ || _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default()(HTMLElement)).call(this));
      _this.className = '';
      _this.childern = [];
      _this.style = {
        width: _WindowProperties.innerWidth + 'px',
        height: _WindowProperties.innerHeight + 'px'
      };
      _this.insertBefore = _util.noop;
      _this.innerHTML = '';
      _this.tagName = tagName.toUpperCase();
      return _this;
    }
    _createClass(HTMLElement, [{
      key: 'setAttribute',
      value: function setAttribute(name, value) {
        this[name] = value;
      }
    }, {
      key: 'getAttribute',
      value: function getAttribute(name) {
        return this[name];
      }
    }, {
      key: 'getBoundingClientRect',
      value: function getBoundingClientRect() {
        return {
          top: 0,
          left: 0,
          width: _WindowProperties.innerWidth,
          height: _WindowProperties.innerHeight
        };
      }
    }, {
      key: 'focus',
      value: function focus() {}
    }, {
      key: 'clientWidth',
      get: function get() {
        var ret = _babel_runtime_corejs3_core_js_stable_parse_int__WEBPACK_IMPORTED_MODULE_8___default()(this.style.fontSize, 10) * this.innerHTML.length;
        return _babel_runtime_corejs3_core_js_stable_number_is_nan__WEBPACK_IMPORTED_MODULE_9___default()(ret) ? 0 : ret;
      }
    }, {
      key: 'clientHeight',
      get: function get() {
        var ret = _babel_runtime_corejs3_core_js_stable_parse_int__WEBPACK_IMPORTED_MODULE_8___default()(this.style.fontSize, 10);
        return _babel_runtime_corejs3_core_js_stable_number_is_nan__WEBPACK_IMPORTED_MODULE_9___default()(ret) ? 0 : ret;
      }
    }]);
    return HTMLElement;
  }(_Element3.default);
  exports.default = HTMLElement;

  /***/
}, /* 6 */
/***/function (module, exports, __nested_webpack_require_16590__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _Node2 = __nested_webpack_require_16590__(7);
  var _Node3 = _interopRequireDefault(_Node2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(superClass));
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) (_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var ELement = function (_Node) {
    _inherits(ELement, _Node);
    function ELement() {
      _classCallCheck(this, ELement);
      var _this = _possibleConstructorReturn(this, (ELement.__proto__ || _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default()(ELement)).call(this));
      _this.className = '';
      _this.children = [];
      return _this;
    }
    return ELement;
  }(_Node3.default);
  exports.default = ELement;

  /***/
}, /* 7 */
/***/function (module, exports, __nested_webpack_require_18363__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _EventTarget2 = __nested_webpack_require_18363__(8);
  var _EventTarget3 = _interopRequireDefault(_EventTarget2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(superClass));
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) (_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var Node = function (_EventTarget) {
    _inherits(Node, _EventTarget);
    function Node() {
      _classCallCheck(this, Node);
      var _this = _possibleConstructorReturn(this, (Node.__proto__ || _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default()(Node)).call(this));
      _this.childNodes = [];
      return _this;
    }
    _createClass(Node, [{
      key: 'appendChild',
      value: function appendChild(node) {
        if (node instanceof Node) {
          this.childNodes.push(node);
        } else {
          throw new TypeError('Failed to executed \'appendChild\' on \'Node\': parameter 1 is not of type \'Node\'.');
        }
      }
    }, {
      key: 'cloneNode',
      value: function cloneNode() {
        var copyNode = Object.create(this);
        _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_5___default()(copyNode, this);
        return copyNode;
      }
    }, {
      key: 'removeChild',
      value: function removeChild(node) {
        var _context3;
        var index = _babel_runtime_corejs3_core_js_stable_instance_find_index__WEBPACK_IMPORTED_MODULE_10___default()(_context3 = this.childNodes).call(_context3, function (child) {
          return child === node;
        });
        if (index > -1) {
          var _context4;
          return _babel_runtime_corejs3_core_js_stable_instance_splice__WEBPACK_IMPORTED_MODULE_11___default()(_context4 = this.childNodes).call(_context4, index, 1);
        }
        return null;
      }
    }]);
    return Node;
  }(_EventTarget3.default);
  exports.default = Node;

  /***/
}, /* 8 */
/***/function (module, exports) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _events = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var EventTarget = function () {
    function EventTarget() {
      _classCallCheck(this, EventTarget);
      _events.set(this, {});
    }
    _createClass(EventTarget, [{
      key: 'addEventListener',
      value: function addEventListener(type, listener) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var events = _events.get(this);
        if (!events) {
          events = {};
          _events.set(this, events);
        }
        if (!events[type]) {
          events[type] = [];
        }
        events[type].push(listener);
        if (options.capture) {
          console.warn('EventTarget.addEventListener: options.capture is not implemented.');
        }
        if (options.once) {
          console.warn('EventTarget.addEventListener: options.once is not implemented.');
        }
        if (options.passive) {
          console.warn('EventTarget.addEventListener: options.passive is not implemented.');
        }
      }
    }, {
      key: 'removeEventListener',
      value: function removeEventListener(type, listener) {
        var listeners = _events.get(this)[type];
        if (listeners && listeners.length > 0) {
          for (var i = listeners.length; i--; i > 0) {
            if (listeners[i] === listener) {
              _babel_runtime_corejs3_core_js_stable_instance_splice__WEBPACK_IMPORTED_MODULE_11___default()(listeners).call(listeners, i, 1);
              break;
            }
          }
        }
      }
    }, {
      key: 'dispatchEvent',
      value: function dispatchEvent() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var listeners = _events.get(this)[event.type];
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i](event);
          }
        }
      }
    }]);
    return EventTarget;
  }();
  exports.default = EventTarget;

  /***/
}, /* 9 */
/***/function (module, exports) {
  "use strict";

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  exports.noop = noop;
  function noop() {}

  /***/
}, /* 10 */
/***/function (module, exports, __nested_webpack_require_24810__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  exports.default = Canvas;
  var _constructor = __nested_webpack_require_24810__(4);
  var _HTMLElement = __nested_webpack_require_24810__(5);
  var _HTMLElement2 = _interopRequireDefault(_HTMLElement);
  var _document = __nested_webpack_require_24810__(11);
  var _document2 = _interopRequireDefault(_document);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var hasModifiedCanvasPrototype = false;
  var hasInit2DContextConstructor = false;
  var hasInitWebGLContextConstructor = false;
  function Canvas() {
    var canvas = wx.createCanvas();
    canvas.type = 'canvas';
    canvas.__proto__.__proto__ = new _constructor.HTMLCanvasElement('canvas');
    var _getContext = canvas.getContext;
    canvas.getBoundingClientRect = function () {
      var ret = {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight
      };
      return ret;
    };
    return canvas;
  }

  /***/
}, /* 11 */
/***/function (module, exports, __nested_webpack_require_25927__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _window = __nested_webpack_require_25927__(1);
  var window = _interopRequireWildcard(_window);
  var _HTMLElement = __nested_webpack_require_25927__(5);
  var _HTMLElement2 = _interopRequireDefault(_HTMLElement);
  var _Image = __nested_webpack_require_25927__(12);
  var _Image2 = _interopRequireDefault(_Image);
  var _Audio = __nested_webpack_require_25927__(13);
  var _Audio2 = _interopRequireDefault(_Audio);
  var _Canvas = __nested_webpack_require_25927__(10);
  var _Canvas2 = _interopRequireDefault(_Canvas);
  __nested_webpack_require_25927__(16);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  var events = {};
  var document = {
    readyState: 'complete',
    visibilityState: 'visible',
    documentElement: window,
    hidden: false,
    style: {},
    location: window.location,
    ontouchstart: null,
    ontouchmove: null,
    ontouchend: null,
    head: new _HTMLElement2.default('head'),
    body: new _HTMLElement2.default('body'),
    createElement: function createElement(tagName) {
      if (tagName === 'canvas') {
        return new _Canvas2.default();
      } else if (tagName === 'audio') {
        return new _Audio2.default();
      } else if (tagName === 'img') {
        return new _Image2.default();
      }
      return new _HTMLElement2.default(tagName);
    },
    getElementById: function getElementById(id) {
      if (id === window.canvas.id) {
        return window.canvas;
      }
      return null;
    },
    getElementsByTagName: function getElementsByTagName(tagName) {
      if (tagName === 'head') {
        return [document.head];
      } else if (tagName === 'body') {
        return [document.body];
      } else if (tagName === 'canvas') {
        return [window.canvas];
      }
      return [];
    },
    getElementsByName: function getElementsByName(tagName) {
      if (tagName === 'head') {
        return [document.head];
      } else if (tagName === 'body') {
        return [document.body];
      } else if (tagName === 'canvas') {
        return [window.canvas];
      }
      return [];
    },
    querySelector: function querySelector(query) {
      if (query === 'head') {
        return document.head;
      } else if (query === 'body') {
        return document.body;
      } else if (query === 'canvas') {
        return window.canvas;
      } else if (query === '#' + window.canvas.id) {
        return window.canvas;
      }
      return null;
    },
    querySelectorAll: function querySelectorAll(query) {
      if (query === 'head') {
        return [document.head];
      } else if (query === 'body') {
        return [document.body];
      } else if (query === 'canvas') {
        return [window.canvas];
      }
      return [];
    },
    addEventListener: function addEventListener(type, listener) {
      if (!events[type]) {
        events[type] = [];
      }
      events[type].push(listener);
    },
    removeEventListener: function removeEventListener(type, listener) {
      var listeners = events[type];
      if (listeners && listeners.length > 0) {
        for (var i = listeners.length; i--; i > 0) {
          if (listeners[i] === listener) {
            _babel_runtime_corejs3_core_js_stable_instance_splice__WEBPACK_IMPORTED_MODULE_11___default()(listeners).call(listeners, i, 1);
            break;
          }
        }
      }
    },
    dispatchEvent: function dispatchEvent(event) {
      var listeners = events[event.type];
      if (listeners) {
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](event);
        }
      }
    }
  };
  exports.default = document;

  /***/
}, /* 12 */
/***/function (module, exports) {
  "use strict";

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  exports.default = Image;
  function Image() {
    var image = wx.createImage();
    return image;
  }

  /***/
}, /* 13 */
/***/function (module, exports, __nested_webpack_require_30205__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _HTMLAudioElement2 = __nested_webpack_require_30205__(14);
  var _HTMLAudioElement3 = _interopRequireDefault(_HTMLAudioElement2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(superClass));
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) (_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var HAVE_NOTHING = 0;
  var HAVE_METADATA = 1;
  var HAVE_CURRENT_DATA = 2;
  var HAVE_FUTURE_DATA = 3;
  var HAVE_ENOUGH_DATA = 4;
  var _innerAudioContext = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var _src = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var _loop = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var _autoplay = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var Audio = function (_HTMLAudioElement) {
    _inherits(Audio, _HTMLAudioElement);
    function Audio(url) {
      _classCallCheck(this, Audio);
      var _this = _possibleConstructorReturn(this, (Audio.__proto__ || _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default()(Audio)).call(this));
      _this.HAVE_NOTHING = HAVE_NOTHING;
      _this.HAVE_METADATA = HAVE_METADATA;
      _this.HAVE_CURRENT_DATA = HAVE_CURRENT_DATA;
      _this.HAVE_FUTURE_DATA = HAVE_FUTURE_DATA;
      _this.HAVE_ENOUGH_DATA = HAVE_ENOUGH_DATA;
      _this.readyState = HAVE_NOTHING;
      _src.set(_this, '');
      var innerAudioContext = wx.createInnerAudioContext();
      _innerAudioContext.set(_this, innerAudioContext);
      innerAudioContext.onCanplay(function () {
        _this.dispatchEvent({
          type: 'load'
        });
        _this.dispatchEvent({
          type: 'loadend'
        });
        _this.dispatchEvent({
          type: 'canplay'
        });
        _this.dispatchEvent({
          type: 'canplaythrough'
        });
        _this.dispatchEvent({
          type: 'loadedmetadata'
        });
        _this.readyState = HAVE_CURRENT_DATA;
      });
      innerAudioContext.onPlay(function () {
        _this.dispatchEvent({
          type: 'play'
        });
      });
      innerAudioContext.onPause(function () {
        _this.dispatchEvent({
          type: 'pause'
        });
      });
      innerAudioContext.onEnded(function () {
        _this.dispatchEvent({
          type: 'ended'
        });
        _this.readyState = HAVE_ENOUGH_DATA;
      });
      innerAudioContext.onError(function () {
        _this.dispatchEvent({
          type: 'error'
        });
      });
      if (url) {
        _innerAudioContext.get(_this).src = url;
      }
      return _this;
    }
    _createClass(Audio, [{
      key: 'load',
      value: function load() {
        console.warn('HTMLAudioElement.load() is not implemented.');
      }
    }, {
      key: 'play',
      value: function play() {
        _innerAudioContext.get(this).play();
      }
    }, {
      key: 'pause',
      value: function pause() {
        _innerAudioContext.get(this).pause();
      }
    }, {
      key: 'canPlayType',
      value: function canPlayType() {
        var mediaType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        if (typeof mediaType !== 'string') {
          return '';
        }
        if (_babel_runtime_corejs3_core_js_stable_instance_index_of__WEBPACK_IMPORTED_MODULE_13___default()(mediaType).call(mediaType, 'audio/mpeg') > -1 || _babel_runtime_corejs3_core_js_stable_instance_index_of__WEBPACK_IMPORTED_MODULE_13___default()(mediaType).call(mediaType, 'audio/mp4')) {
          return 'probably';
        }
        return '';
      }
    }, {
      key: 'cloneNode',
      value: function cloneNode() {
        var newAudio = new Audio();
        newAudio.loop = _innerAudioContext.get(this).loop;
        newAudio.autoplay = _innerAudioContext.get(this).autoplay;
        newAudio.src = this.src;
        return newAudio;
      }
    }, {
      key: 'currentTime',
      get: function get() {
        return _innerAudioContext.get(this).currentTime;
      },
      set: function set(value) {
        _innerAudioContext.get(this).seek(value);
      }
    }, {
      key: 'src',
      get: function get() {
        return _src.get(this);
      },
      set: function set(value) {
        _src.set(this, value);
        _innerAudioContext.get(this).src = value;
      }
    }, {
      key: 'loop',
      get: function get() {
        return _innerAudioContext.get(this).loop;
      },
      set: function set(value) {
        _innerAudioContext.get(this).loop = value;
      }
    }, {
      key: 'autoplay',
      get: function get() {
        return _innerAudioContext.get(this).autoplay;
      },
      set: function set(value) {
        _innerAudioContext.get(this).autoplay = value;
      }
    }, {
      key: 'paused',
      get: function get() {
        return _innerAudioContext.get(this).paused;
      }
    }]);
    return Audio;
  }(_HTMLAudioElement3.default);
  exports.default = Audio;

  /***/
}, /* 14 */
/***/function (module, exports, __nested_webpack_require_36518__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _HTMLMediaElement2 = __nested_webpack_require_36518__(15);
  var _HTMLMediaElement3 = _interopRequireDefault(_HTMLMediaElement2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(superClass));
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) (_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var HTMLAudioElement = function (_HTMLMediaElement) {
    _inherits(HTMLAudioElement, _HTMLMediaElement);
    function HTMLAudioElement() {
      _classCallCheck(this, HTMLAudioElement);
      return _possibleConstructorReturn(this, (HTMLAudioElement.__proto__ || _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default()(HTMLAudioElement)).call(this, 'audio'));
    }
    return HTMLAudioElement;
  }(_HTMLMediaElement3.default);
  exports.default = HTMLAudioElement;

  /***/
}, /* 15 */
/***/function (module, exports, __nested_webpack_require_38366__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _HTMLElement2 = __nested_webpack_require_38366__(5);
  var _HTMLElement3 = _interopRequireDefault(_HTMLElement2);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && ((0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function") ? call : self;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (0,_babel_runtime_corejs3_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(superClass));
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) (_babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_6___default()(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var HTMLMediaElement = function (_HTMLElement) {
    _inherits(HTMLMediaElement, _HTMLElement);
    function HTMLMediaElement(type) {
      _classCallCheck(this, HTMLMediaElement);
      return _possibleConstructorReturn(this, (HTMLMediaElement.__proto__ || _babel_runtime_corejs3_core_js_stable_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_7___default()(HTMLMediaElement)).call(this, type));
    }
    _createClass(HTMLMediaElement, [{
      key: 'addTextTrack',
      value: function addTextTrack() {}
    }, {
      key: 'captureStream',
      value: function captureStream() {}
    }, {
      key: 'fastSeek',
      value: function fastSeek() {}
    }, {
      key: 'load',
      value: function load() {}
    }, {
      key: 'pause',
      value: function pause() {}
    }, {
      key: 'play',
      value: function play() {}
    }]);
    return HTMLMediaElement;
  }(_HTMLElement3.default);
  exports.default = HTMLMediaElement;

  /***/
}, /* 16 */
/***/function (module, exports, __nested_webpack_require_41282__) {
  'use strict';

  __nested_webpack_require_41282__(17);

  /***/
}, /* 17 */
/***/function (module, exports, __nested_webpack_require_41402__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _window = __nested_webpack_require_41402__(1);
  var window = _interopRequireWildcard(_window);
  var _document = __nested_webpack_require_41402__(11);
  var _document2 = _interopRequireDefault(_document);
  var _util = __nested_webpack_require_41402__(9);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var TouchEvent = function TouchEvent(type) {
    _classCallCheck(this, TouchEvent);
    this.target = window.canvas;
    this.currentTarget = window.canvas;
    this.touches = [];
    this.targetTouches = [];
    this.changedTouches = [];
    this.preventDefault = _util.noop;
    this.stopPropagation = _util.noop;
    this.type = type;
  };
  exports.default = TouchEvent;
  function touchEventHandlerFactory(type) {
    return function (event) {
      var touchEvent = new TouchEvent(type);
      touchEvent.touches = event.touches;
      touchEvent.targetTouches = _babel_runtime_corejs3_core_js_stable_instance_slice__WEBPACK_IMPORTED_MODULE_14___default()(Array.prototype).call(event.touches);
      touchEvent.changedTouches = event.changedTouches;
      touchEvent.timeStamp = event.timeStamp;
      _document2.default.dispatchEvent(touchEvent);
    };
  }
  wx.onTouchStart(touchEventHandlerFactory('touchstart'));
  wx.onTouchMove(touchEventHandlerFactory('touchmove'));
  wx.onTouchEnd(touchEventHandlerFactory('touchend'));
  wx.onTouchCancel(touchEventHandlerFactory('touchcancel'));

  /***/
}, /* 18 */
/***/function (module, exports, __nested_webpack_require_43454__) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _util = __nested_webpack_require_43454__(9);

  // TODO 需要 wx.getSystemInfo 获取更详细信息
  var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
    platform = _wx$getSystemInfoSync.platform;
  var navigator = {
    platform: platform,
    language: 'zh-cn',
    appVersion: '5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1',
    userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E8301 MicroMessenger/6.6.0 MiniGame NetType/WIFI Language/zh_CN',
    onLine: true,
    // TODO 用 wx.getNetworkStateChange 和 wx.onNetworkStateChange 来返回真实的状态

    // TODO 用 wx.getLocation 来封装 geolocation
    geolocation: {
      getCurrentPosition: _util.noop,
      watchPosition: _util.noop,
      clearWatch: _util.noop
    }
  };
  exports.default = navigator;

  /***/
}, /* 19 */
/***/function (module, exports) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _url = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var _method = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var _requestHeader = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var _responseHeader = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var _requestTask = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  function _triggerEvent(type) {
    if (typeof this['on' + type] === 'function') {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      this['on' + type].apply(this, args);
    }
  }
  function _changeReadyState(readyState) {
    this.readyState = readyState;
    _triggerEvent.call(this, 'readystatechange');
  }
  var XMLHttpRequest = function () {
    // TODO 没法模拟 HEADERS_RECEIVED 和 LOADING 两个状态
    function XMLHttpRequest() {
      _classCallCheck(this, XMLHttpRequest);
      this.onabort = null;
      this.onerror = null;
      this.onload = null;
      this.onloadstart = null;
      this.onprogress = null;
      this.ontimeout = null;
      this.onloadend = null;
      this.onreadystatechange = null;
      this.readyState = 0;
      this.response = null;
      this.responseText = null;
      this.responseType = '';
      this.responseXML = null;
      this.status = 0;
      this.statusText = '';
      this.upload = {};
      this.withCredentials = false;
      _requestHeader.set(this, {
        'content-type': 'application/x-www-form-urlencoded'
      });
      _responseHeader.set(this, {});
    }

    /*
     * TODO 这一批事件应该是在 XMLHttpRequestEventTarget.prototype 上面的
     */

    _createClass(XMLHttpRequest, [{
      key: 'abort',
      value: function abort() {
        var myRequestTask = _requestTask.get(this);
        if (myRequestTask) {
          myRequestTask.abort();
        }
      }
    }, {
      key: 'getAllResponseHeaders',
      value: function getAllResponseHeaders() {
        var _context5;
        var responseHeader = _responseHeader.get(this);
        return _babel_runtime_corejs3_core_js_stable_instance_map__WEBPACK_IMPORTED_MODULE_15___default()(_context5 = _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_4___default()(responseHeader)).call(_context5, function (header) {
          return header + ': ' + responseHeader[header];
        }).join('\n');
      }
    }, {
      key: 'getResponseHeader',
      value: function getResponseHeader(header) {
        return _responseHeader.get(this)[header];
      }
    }, {
      key: 'open',
      value: function open(method, url /* async, user, password 这几个参数在小程序内不支持*/) {
        _method.set(this, method);
        _url.set(this, url);
        _changeReadyState.call(this, XMLHttpRequest.OPENED);
      }
    }, {
      key: 'overrideMimeType',
      value: function overrideMimeType() {}
    }, {
      key: 'send',
      value: function send() {
        var _this = this;
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        if (this.readyState !== XMLHttpRequest.OPENED) {
          throw new Error("Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.");
        } else {
          wx.request({
            data: data,
            url: _url.get(this),
            method: _method.get(this),
            header: _requestHeader.get(this),
            responseType: this.responseType,
            success: function success(_ref) {
              var data = _ref.data,
                statusCode = _ref.statusCode,
                header = _ref.header;
              if (typeof data !== 'string' && !(data instanceof ArrayBuffer)) {
                try {
                  data = _babel_runtime_corejs3_core_js_stable_json_stringify__WEBPACK_IMPORTED_MODULE_16___default()(data);
                } catch (e) {
                  data = data;
                }
              }
              _this.status = statusCode;
              _responseHeader.set(_this, header);
              _triggerEvent.call(_this, 'loadstart');
              _changeReadyState.call(_this, XMLHttpRequest.HEADERS_RECEIVED);
              _changeReadyState.call(_this, XMLHttpRequest.LOADING);
              _this.response = data;
              if (data instanceof ArrayBuffer) {
                _this.responseText = '';
                var bytes = new Uint8Array(data);
                var len = bytes.byteLength;
                for (var i = 0; i < len; i++) {
                  _this.responseText += String.fromCharCode(bytes[i]);
                }
              } else {
                _this.responseText = data;
              }
              _changeReadyState.call(_this, XMLHttpRequest.DONE);
              _triggerEvent.call(_this, 'load');
              _triggerEvent.call(_this, 'loadend');
            },
            fail: function fail(_ref2) {
              var errMsg = _ref2.errMsg;

              // TODO 规范错误
              if (_babel_runtime_corejs3_core_js_stable_instance_index_of__WEBPACK_IMPORTED_MODULE_13___default()(errMsg).call(errMsg, 'abort') !== -1) {
                _triggerEvent.call(_this, 'abort');
              } else {
                _triggerEvent.call(_this, 'error', errMsg);
              }
              _triggerEvent.call(_this, 'loadend');
            }
          });
        }
      }
    }, {
      key: 'setRequestHeader',
      value: function setRequestHeader(header, value) {
        var myHeader = _requestHeader.get(this);
        myHeader[header] = value;
        _requestHeader.set(this, myHeader);
      }
    }]);
    return XMLHttpRequest;
  }();
  XMLHttpRequest.UNSEND = 0;
  XMLHttpRequest.OPENED = 1;
  XMLHttpRequest.HEADERS_RECEIVED = 2;
  XMLHttpRequest.LOADING = 3;
  XMLHttpRequest.DONE = 4;
  exports.default = XMLHttpRequest;

  /***/
}, /* 20 */
/***/function (module, exports) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _socketTask = new (_babel_runtime_corejs3_core_js_stable_weak_map__WEBPACK_IMPORTED_MODULE_12___default())();
  var WebSocket = function () {
    // TODO 更新 binaryType
    // The connection is in the process of closing.
    // The connection is not yet open.
    function WebSocket(url) {
      var _this = this;
      var protocols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      _classCallCheck(this, WebSocket);
      this.binaryType = '';
      this.bufferedAmount = 0;
      this.extensions = '';
      this.onclose = null;
      this.onerror = null;
      this.onmessage = null;
      this.onopen = null;
      this.protocol = '';
      this.readyState = 3;
      if (typeof url !== 'string' || !/(^ws:\/\/)|(^wss:\/\/)/.test(url)) {
        throw new TypeError('Failed to construct \'WebSocket\': The URL \'' + url + '\' is invalid');
      }
      this.url = url;
      this.readyState = WebSocket.CONNECTING;
      var socketTask = wx.connectSocket({
        url: url,
        protocols: Array.isArray(protocols) ? protocols : [protocols]
      });
      _socketTask.set(this, socketTask);
      socketTask.onClose(function (res) {
        _this.readyState = WebSocket.CLOSED;
        if (typeof _this.onclose === 'function') {
          _this.onclose(res);
        }
      });
      socketTask.onMessage(function (res) {
        if (typeof _this.onmessage === 'function') {
          _this.onmessage(res);
        }
      });
      socketTask.onOpen(function () {
        _this.readyState = WebSocket.OPEN;
        if (typeof _this.onopen === 'function') {
          _this.onopen();
        }
      });
      socketTask.onError(function (res) {
        if (typeof _this.onerror === 'function') {
          _this.onerror(new Error(res.errMsg));
        }
      });
      return this;
    } // TODO 小程序内目前获取不到，实际上需要根据服务器选择的 sub-protocol 返回
    // TODO 更新 bufferedAmount
    // The connection is closed or couldn't be opened.

    // The connection is open and ready to communicate.

    _createClass(WebSocket, [{
      key: 'close',
      value: function close(code, reason) {
        this.readyState = WebSocket.CLOSING;
        var socketTask = _socketTask.get(this);
        socketTask.close({
          code: code,
          reason: reason
        });
      }
    }, {
      key: 'send',
      value: function send(data) {
        if (typeof data !== 'string' && !(data instanceof ArrayBuffer)) {
          throw new TypeError('Failed to send message: The data ' + data + ' is invalid');
        }
        var socketTask = _socketTask.get(this);
        socketTask.send({
          data: data
        });
      }
    }]);
    return WebSocket;
  }();
  WebSocket.CONNECTING = 0;
  WebSocket.OPEN = 1;
  WebSocket.CLOSING = 2;
  WebSocket.CLOSED = 3;
  exports.default = WebSocket;

  /***/
}, /* 21 */
/***/function (module, exports) {
  "use strict";

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /*
   * TODO 使用 wx.readFile 来封装 FileReader
   */
  var FileReader = function () {
    function FileReader() {
      _classCallCheck(this, FileReader);
    }
    _createClass(FileReader, [{
      key: "construct",
      value: function construct() {}
    }]);
    return FileReader;
  }();
  exports.default = FileReader;

  /***/
}, /* 22 */
/***/function (module, exports) {
  "use strict";

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var localStorage = {
    get length() {
      var _wx$getStorageInfoSyn = wx.getStorageInfoSync(),
        keys = _babel_runtime_corejs3_core_js_stable_instance_keys__WEBPACK_IMPORTED_MODULE_17___default()(_wx$getStorageInfoSyn);
      return keys.length;
    },
    key: function key(n) {
      var _wx$getStorageInfoSyn2 = wx.getStorageInfoSync(),
        keys = _babel_runtime_corejs3_core_js_stable_instance_keys__WEBPACK_IMPORTED_MODULE_17___default()(_wx$getStorageInfoSyn2);
      return keys[n];
    },
    getItem: function getItem(key) {
      return wx.getStorageSync(key);
    },
    setItem: function setItem(key, value) {
      return wx.setStorageSync(key, value);
    },
    removeItem: function removeItem(key) {
      wx.removeStorageSync(key);
    },
    clear: function clear() {
      wx.clearStorageSync();
    }
  };
  exports.default = localStorage;

  /***/
}, /* 23 */
/***/function (module, exports) {
  'use strict';

  _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_2___default()(exports, "__esModule", {
    value: true
  });
  var location = {
    href: 'game.js',
    reload: function reload() {}
  };
  exports.default = location;

  /***/
}
/******/]);

/***/ }),

/***/ "./node_modules/core-js-pure/actual/symbol/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/actual/symbol/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../stable/symbol */ "./node_modules/core-js-pure/stable/symbol/index.js");

__webpack_require__(/*! ../../modules/esnext.symbol.dispose */ "./node_modules/core-js-pure/modules/esnext.symbol.dispose.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/actual/symbol/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/actual/symbol/iterator.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../stable/symbol/iterator */ "./node_modules/core-js-pure/stable/symbol/iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/find-index.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/find-index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../../modules/es.array.find-index */ "./node_modules/core-js-pure/modules/es.array.find-index.js");
var entryVirtual = __webpack_require__(/*! ../../../internals/entry-virtual */ "./node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('Array').findIndex;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/for-each.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/for-each.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../../modules/es.array.for-each */ "./node_modules/core-js-pure/modules/es.array.for-each.js");
var entryVirtual = __webpack_require__(/*! ../../../internals/entry-virtual */ "./node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('Array').forEach;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/index-of.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/index-of.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../../modules/es.array.index-of */ "./node_modules/core-js-pure/modules/es.array.index-of.js");
var entryVirtual = __webpack_require__(/*! ../../../internals/entry-virtual */ "./node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('Array').indexOf;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/keys.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../../modules/es.array.iterator */ "./node_modules/core-js-pure/modules/es.array.iterator.js");
__webpack_require__(/*! ../../../modules/es.object.to-string */ "./node_modules/core-js-pure/modules/es.object.to-string.js");
var entryVirtual = __webpack_require__(/*! ../../../internals/entry-virtual */ "./node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('Array').keys;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/map.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../../modules/es.array.map */ "./node_modules/core-js-pure/modules/es.array.map.js");
var entryVirtual = __webpack_require__(/*! ../../../internals/entry-virtual */ "./node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('Array').map;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/slice.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/slice.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../../modules/es.array.slice */ "./node_modules/core-js-pure/modules/es.array.slice.js");
var entryVirtual = __webpack_require__(/*! ../../../internals/entry-virtual */ "./node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('Array').slice;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/splice.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/splice.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../../modules/es.array.splice */ "./node_modules/core-js-pure/modules/es.array.splice.js");
var entryVirtual = __webpack_require__(/*! ../../../internals/entry-virtual */ "./node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('Array').splice;


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/find-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/find-index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/find-index */ "./node_modules/core-js-pure/es/array/virtual/find-index.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.findIndex;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.findIndex) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/index-of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/index-of.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/index-of */ "./node_modules/core-js-pure/es/array/virtual/index-of.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.indexOf;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.indexOf) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/map.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/map */ "./node_modules/core-js-pure/es/array/virtual/map.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.map;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.map) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/slice.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/slice.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/slice */ "./node_modules/core-js-pure/es/array/virtual/slice.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.slice;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.slice) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/splice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/splice.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/splice */ "./node_modules/core-js-pure/es/array/virtual/splice.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.splice;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.splice) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/json/stringify.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/es/json/stringify.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.json.stringify */ "./node_modules/core-js-pure/modules/es.json.stringify.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var apply = __webpack_require__(/*! ../../internals/function-apply */ "./node_modules/core-js-pure/internals/function-apply.js");

// eslint-disable-next-line es/no-json -- safe
if (!path.JSON) path.JSON = { stringify: JSON.stringify };

// eslint-disable-next-line no-unused-vars -- required for `.length`
module.exports = function stringify(it, replacer, space) {
  return apply(path.JSON.stringify, null, arguments);
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/number/is-nan.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/es/number/is-nan.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.number.is-nan */ "./node_modules/core-js-pure/modules/es.number.is-nan.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Number.isNaN;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/assign.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/assign.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.object.assign */ "./node_modules/core-js-pure/modules/es.object.assign.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.assign;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/define-property.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/define-property.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.object.define-property */ "./node_modules/core-js-pure/modules/es.object.define-property.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

var Object = path.Object;

var defineProperty = module.exports = function defineProperty(it, key, desc) {
  return Object.defineProperty(it, key, desc);
};

if (Object.defineProperty.sham) defineProperty.sham = true;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/get-own-property-descriptor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/get-own-property-descriptor.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.object.get-own-property-descriptor */ "./node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

var Object = path.Object;

var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {
  return Object.getOwnPropertyDescriptor(it, key);
};

if (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/get-prototype-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/get-prototype-of.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.object.get-prototype-of */ "./node_modules/core-js-pure/modules/es.object.get-prototype-of.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.getPrototypeOf;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/keys.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/keys.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.object.keys */ "./node_modules/core-js-pure/modules/es.object.keys.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.keys;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/set-prototype-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/set-prototype-of.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.object.set-prototype-of */ "./node_modules/core-js-pure/modules/es.object.set-prototype-of.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.setPrototypeOf;


/***/ }),

/***/ "./node_modules/core-js-pure/es/parse-int.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js-pure/es/parse-int.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es.parse-int */ "./node_modules/core-js-pure/modules/es.parse-int.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.parseInt;


/***/ }),

/***/ "./node_modules/core-js-pure/es/symbol/index.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js-pure/es/symbol/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.array.concat */ "./node_modules/core-js-pure/modules/es.array.concat.js");
__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js-pure/modules/es.object.to-string.js");
__webpack_require__(/*! ../../modules/es.symbol */ "./node_modules/core-js-pure/modules/es.symbol.js");
__webpack_require__(/*! ../../modules/es.symbol.async-iterator */ "./node_modules/core-js-pure/modules/es.symbol.async-iterator.js");
__webpack_require__(/*! ../../modules/es.symbol.description */ "./node_modules/core-js-pure/modules/es.symbol.description.js");
__webpack_require__(/*! ../../modules/es.symbol.has-instance */ "./node_modules/core-js-pure/modules/es.symbol.has-instance.js");
__webpack_require__(/*! ../../modules/es.symbol.is-concat-spreadable */ "./node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js");
__webpack_require__(/*! ../../modules/es.symbol.iterator */ "./node_modules/core-js-pure/modules/es.symbol.iterator.js");
__webpack_require__(/*! ../../modules/es.symbol.match */ "./node_modules/core-js-pure/modules/es.symbol.match.js");
__webpack_require__(/*! ../../modules/es.symbol.match-all */ "./node_modules/core-js-pure/modules/es.symbol.match-all.js");
__webpack_require__(/*! ../../modules/es.symbol.replace */ "./node_modules/core-js-pure/modules/es.symbol.replace.js");
__webpack_require__(/*! ../../modules/es.symbol.search */ "./node_modules/core-js-pure/modules/es.symbol.search.js");
__webpack_require__(/*! ../../modules/es.symbol.species */ "./node_modules/core-js-pure/modules/es.symbol.species.js");
__webpack_require__(/*! ../../modules/es.symbol.split */ "./node_modules/core-js-pure/modules/es.symbol.split.js");
__webpack_require__(/*! ../../modules/es.symbol.to-primitive */ "./node_modules/core-js-pure/modules/es.symbol.to-primitive.js");
__webpack_require__(/*! ../../modules/es.symbol.to-string-tag */ "./node_modules/core-js-pure/modules/es.symbol.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.symbol.unscopables */ "./node_modules/core-js-pure/modules/es.symbol.unscopables.js");
__webpack_require__(/*! ../../modules/es.json.to-string-tag */ "./node_modules/core-js-pure/modules/es.json.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.math.to-string-tag */ "./node_modules/core-js-pure/modules/es.math.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.reflect.to-string-tag */ "./node_modules/core-js-pure/modules/es.reflect.to-string-tag.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Symbol;


/***/ }),

/***/ "./node_modules/core-js-pure/es/symbol/iterator.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/es/symbol/iterator.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js-pure/modules/es.array.iterator.js");
__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js-pure/modules/es.object.to-string.js");
__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js-pure/modules/es.string.iterator.js");
__webpack_require__(/*! ../../modules/es.symbol.iterator */ "./node_modules/core-js-pure/modules/es.symbol.iterator.js");
var WrappedWellKnownSymbolModule = __webpack_require__(/*! ../../internals/well-known-symbol-wrapped */ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js");

module.exports = WrappedWellKnownSymbolModule.f('iterator');


/***/ }),

/***/ "./node_modules/core-js-pure/es/weak-map/index.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/es/weak-map/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js-pure/modules/es.array.iterator.js");
__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js-pure/modules/es.object.to-string.js");
__webpack_require__(/*! ../../modules/es.weak-map */ "./node_modules/core-js-pure/modules/es.weak-map.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.WeakMap;


/***/ }),

/***/ "./node_modules/core-js-pure/features/symbol/index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/features/symbol/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ../../full/symbol */ "./node_modules/core-js-pure/full/symbol/index.js");


/***/ }),

/***/ "./node_modules/core-js-pure/features/symbol/iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/features/symbol/iterator.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ../../full/symbol/iterator */ "./node_modules/core-js-pure/full/symbol/iterator.js");


/***/ }),

/***/ "./node_modules/core-js-pure/full/symbol/index.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/full/symbol/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../actual/symbol */ "./node_modules/core-js-pure/actual/symbol/index.js");
__webpack_require__(/*! ../../modules/esnext.symbol.async-dispose */ "./node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js");
__webpack_require__(/*! ../../modules/esnext.symbol.is-registered */ "./node_modules/core-js-pure/modules/esnext.symbol.is-registered.js");
__webpack_require__(/*! ../../modules/esnext.symbol.is-well-known */ "./node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js");
__webpack_require__(/*! ../../modules/esnext.symbol.matcher */ "./node_modules/core-js-pure/modules/esnext.symbol.matcher.js");
__webpack_require__(/*! ../../modules/esnext.symbol.metadata-key */ "./node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js");
__webpack_require__(/*! ../../modules/esnext.symbol.observable */ "./node_modules/core-js-pure/modules/esnext.symbol.observable.js");
// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../../modules/esnext.symbol.metadata */ "./node_modules/core-js-pure/modules/esnext.symbol.metadata.js");
__webpack_require__(/*! ../../modules/esnext.symbol.pattern-match */ "./node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js");
__webpack_require__(/*! ../../modules/esnext.symbol.replace-all */ "./node_modules/core-js-pure/modules/esnext.symbol.replace-all.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/full/symbol/iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/full/symbol/iterator.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../actual/symbol/iterator */ "./node_modules/core-js-pure/actual/symbol/iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/a-callable.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/a-callable.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/a-possible-prototype.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/a-possible-prototype.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/add-to-unscopables.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/add-to-unscopables.js ***!
  \*******************************************************************/
/***/ (function(module) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js-pure/internals/an-instance.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/an-instance.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/an-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/an-object.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-buffer-non-extensible.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-buffer-non-extensible.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-for-each.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-for-each.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").forEach);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js-pure/internals/array-method-is-strict.js");

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-includes.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-includes.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js-pure/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-iteration.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-iteration.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js-pure/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js-pure/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js-pure/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-method-has-species-support.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-method-has-species-support.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js-pure/internals/engine-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-method-is-strict.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-method-is-strict.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-set-length.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-set-length.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-slice-simple.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-slice-simple.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js-pure/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js-pure/internals/create-property.js");

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-slice.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-slice.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-species-constructor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-species-constructor.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js-pure/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-species-create.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-species-create.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js-pure/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/classof-raw.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/classof-raw.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/classof.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/classof.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js-pure/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/collection-weak.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/collection-weak.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js-pure/internals/define-built-ins.js");
var getWeakData = (__webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js-pure/internals/internal-metadata.js").getWeakData);
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js-pure/internals/an-instance.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js-pure/internals/iterate.js");
var ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis([].splice);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    defineBuiltIns(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return Constructor;
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/collection.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/collection.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js-pure/internals/internal-metadata.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js-pure/internals/iterate.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js-pure/internals/an-instance.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);
var forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").forEach);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var exported = {};
  var Constructor;

  if (!DESCRIPTORS || !isCallable(NativeConstructor)
    || !(IS_WEAK || NativePrototype.forEach && !fails(function () { new NativeConstructor().entries().next(); }))
  ) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else {
    Constructor = wrapper(function (target, iterable) {
      setInternalState(anInstance(target, Prototype), {
        type: CONSTRUCTOR_NAME,
        collection: new NativeConstructor()
      });
      if (iterable != undefined) iterate(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
        createNonEnumerableProperty(Prototype, KEY, function (a, b) {
          var collection = getInternalState(this).collection;
          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
          var result = collection[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      }
    });

    IS_WEAK || defineProperty(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).collection.size;
      }
    });
  }

  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: true }, exported);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/correct-prototype-getter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/correct-prototype-getter.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-iter-result-object.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-iter-result-object.js ***!
  \**************************************************************************/
/***/ (function(module) {

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-non-enumerable-property.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-property-descriptor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-property-descriptor.js ***!
  \***************************************************************************/
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-property.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-property.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-built-in-accessor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-built-in-accessor.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-built-in.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-built-in.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");

module.exports = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;
  else createNonEnumerableProperty(target, key, value);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-built-ins.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-built-ins.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");

module.exports = function (target, src, options) {
  for (var key in src) {
    if (options && options.unsafe && target[key]) target[key] = src[key];
    else defineBuiltIn(target, key, src[key], options);
  } return target;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-global-property.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-global-property.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/delete-property-or-throw.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/delete-property-or-throw.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");

var $TypeError = TypeError;

module.exports = function (O, P) {
  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/descriptors.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/descriptors.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/document-all.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/document-all.js ***!
  \*************************************************************/
/***/ (function(module) {

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/document-create-element.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/document-create-element.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js ***!
  \*****************************************************************************/
/***/ (function(module) {

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/dom-iterables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/dom-iterables.js ***!
  \**************************************************************/
/***/ (function(module) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/engine-user-agent.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/engine-user-agent.js ***!
  \******************************************************************/
/***/ (function(module) {

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ "./node_modules/core-js-pure/internals/engine-v8-version.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/engine-v8-version.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js-pure/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/entry-virtual.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/entry-virtual.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = function (CONSTRUCTOR) {
  return path[CONSTRUCTOR + 'Prototype'];
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/enum-bug-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/enum-bug-keys.js ***!
  \**************************************************************/
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js-pure/internals/export.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/export.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js-pure/internals/function-apply.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js").f);
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js-pure/internals/is-forced.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js-pure/internals/function-bind-context.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0: return new NativeConstructor();
        case 1: return new NativeConstructor(a);
        case 2: return new NativeConstructor(a, b);
      } return new NativeConstructor(a, b, c);
    } return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;

  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;

  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;

  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

    targetProperty = target[key];

    if (USE_NATIVE) if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;

    // bind methods to global for calling from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);
    // wrap global constructors for prevent changes in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/fails.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/fails.js ***!
  \******************************************************/
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/freezing.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/freezing.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-apply.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-apply.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-bind-context.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-bind-context.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-bind-native.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-bind-native.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-call.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-call.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-name.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-name.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this-accessor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this-accessor.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this-clause.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-built-in.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-built-in.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-iterator-method.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js-pure/internals/get-method.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-iterator.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js-pure/internals/get-iterator-method.js");

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-json-replacer-function.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-json-replacer-function.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) == 'Number' || classof(element) == 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-method.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-method.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/global.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/global.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || this || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js-pure/internals/has-own-property.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/has-own-property.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/hidden-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/hidden-keys.js ***!
  \************************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/html.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/html.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js-pure/internals/ie8-dom-define.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/ie8-dom-define.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js-pure/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/indexed-object.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/indexed-object.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/inspect-source.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/inspect-source.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/internal-metadata.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/internal-metadata.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js-pure/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternalModule = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js-pure/internals/object-get-own-property-names-external.js");
var isExtensible = __webpack_require__(/*! ../internals/object-is-extensible */ "./node_modules/core-js-pure/internals/object-is-extensible.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js-pure/internals/freezing.js");

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/internal-state.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/internal-state.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js-pure/internals/weak-map-basic-detection.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-array-iterator-method.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-array-iterator-method.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-array.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-array.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-callable.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-callable.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js-pure/internals/document-all.js");

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-constructor.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js-pure/internals/inspect-source.js");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-forced.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-forced.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-null-or-undefined.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-null-or-undefined.js ***!
  \*********************************************************************/
/***/ (function(module) {

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-object.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var $documentAll = __webpack_require__(/*! ../internals/document-all */ "./node_modules/core-js-pure/internals/document-all.js");

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-pure.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-pure.js ***!
  \********************************************************/
/***/ (function(module) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-symbol.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-symbol.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterate.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterate.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js-pure/internals/function-bind-context.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js-pure/internals/is-array-iterator-method.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js-pure/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js-pure/internals/get-iterator-method.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js-pure/internals/iterator-close.js");

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterator-close.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterator-close.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js-pure/internals/get-method.js");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterator-create-constructor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterator-create-constructor.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js-pure/internals/iterators-core.js").IteratorPrototype);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js-pure/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterator-define.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterator-define.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js-pure/internals/function-name.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js-pure/internals/iterator-create-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js-pure/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js-pure/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js-pure/internals/iterators-core.js");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterators-core.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterators-core.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js-pure/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js-pure/internals/object-get-prototype-of.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterators.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterators.js ***!
  \**********************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/length-of-array-like.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/length-of-array-like.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js-pure/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/math-trunc.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/math-trunc.js ***!
  \***********************************************************/
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/number-parse-int.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/number-parse-int.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var trim = (__webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js-pure/internals/string-trim.js").trim);
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js-pure/internals/whitespaces.js");

var $parseInt = global.parseInt;
var Symbol = global.Symbol;
var ITERATOR = Symbol && Symbol.iterator;
var hex = /^[+-]?0x/i;
var exec = uncurryThis(hex.exec);
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22
  // MS Edge 18- broken with boxed symbols
  || (ITERATOR && !fails(function () { $parseInt(Object(ITERATOR)); }));

// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(toString(string));
  return $parseInt(S, (radix >>> 0) || (exec(hex, S) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-assign.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-assign.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js-pure/internals/indexed-object.js");

// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es/no-symbol -- safe
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-create.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js-pure/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js-pure/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js-pure/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js-pure/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-define-properties.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-define-properties.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-define-property.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-define-property.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js-pure/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js-pure/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-names-external.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-names-external.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var $getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js-pure/internals/object-get-own-property-names.js").f);
var arraySlice = __webpack_require__(/*! ../internals/array-slice-simple */ "./node_modules/core-js-pure/internals/array-slice-simple.js");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-names.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-names.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js-pure/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js-pure/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-symbols.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-prototype-of.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-prototype-of.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js-pure/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-is-extensible.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-is-extensible.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__(/*! ../internals/array-buffer-non-extensible */ "./node_modules/core-js-pure/internals/array-buffer-non-extensible.js");

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-is-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-is-prototype-of.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-keys-internal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-keys-internal.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js-pure/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-keys.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js-pure/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js-pure/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-property-is-enumerable.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-set-prototype-of.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-set-prototype-of.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js-pure/internals/function-uncurry-this-accessor.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js-pure/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-to-string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-to-string.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js-pure/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/ordinary-to-primitive.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/ordinary-to-primitive.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/path.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/path.js ***!
  \*****************************************************/
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/require-object-coercible.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/require-object-coercible.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/set-to-string-tag.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/set-to-string-tag.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js-pure/internals/to-string-tag-support.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js-pure/internals/object-to-string.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;
    if (!hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty(target, 'toString', toString);
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared-key.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared-store.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared-store.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js-pure/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.30.2',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/string-multibyte.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/string-multibyte.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/string-trim.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/string-trim.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js-pure/internals/whitespaces.js");

var replace = uncurryThis(''.replace);
var ltrim = RegExp('^[' + whitespaces + ']+');
var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-constructor-detection.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js-pure/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-define-to-primitive.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-define-to-primitive.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-registry-detection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-registry-detection.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-absolute-index.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-absolute-index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-indexed-object.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-indexed-object.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js-pure/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-integer-or-infinity.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js-pure/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-length.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-length.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-object.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-primitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-primitive.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js-pure/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js-pure/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-property-key.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-property-key.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js-pure/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-string-tag-support.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-string-tag-support.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-string.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-string.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/try-to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/try-to-string.js ***!
  \**************************************************************/
/***/ (function(module) {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/uid.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/uid.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/use-symbol-as-uid.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/v8-prototype-define-bug.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/weak-map-basic-detection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/weak-map-basic-detection.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "./node_modules/core-js-pure/internals/well-known-symbol-define.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/well-known-symbol-define.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/well-known-symbol.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/well-known-symbol.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js");

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/whitespaces.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/whitespaces.js ***!
  \************************************************************/
/***/ (function(module) {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.concat.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.concat.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js-pure/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js-pure/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js-pure/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js-pure/internals/engine-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.find-index.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.find-index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var $findIndex = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").findIndex);
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js-pure/internals/add-to-unscopables.js");

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
// eslint-disable-next-line es/no-array-prototype-findindex -- testing
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.for-each.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.for-each.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js-pure/internals/array-for-each.js");

// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.index-of.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.index-of.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/* eslint-disable es/no-array-prototype-indexof -- required for testing */
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js");
var $indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js-pure/internals/array-includes.js").indexOf);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js-pure/internals/array-method-is-strict.js");

var nativeIndexOf = uncurryThis([].indexOf);

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: FORCED }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf(this, searchElement, fromIndex) || 0
      : $indexOf(this, searchElement, fromIndex);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.iterator.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.iterator.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js-pure/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js-pure/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js-pure/internals/create-iter-result-object.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return createIterResultObject(undefined, true);
  }
  if (kind == 'keys') return createIterResultObject(index, false);
  if (kind == 'values') return createIterResultObject(target[index], false);
  return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.map.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var $map = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").map);
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js-pure/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.slice.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.slice.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js-pure/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js-pure/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js-pure/internals/create-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js-pure/internals/array-method-has-species-support.js");
var nativeSlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js-pure/internals/array-slice.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var $Array = Array;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === $Array || Constructor === undefined) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.splice.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.splice.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js-pure/internals/to-absolute-index.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var setArrayLength = __webpack_require__(/*! ../internals/array-set-length */ "./node_modules/core-js-pure/internals/array-set-length.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js-pure/internals/array-species-create.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js-pure/internals/create-property.js");
var deletePropertyOrThrow = __webpack_require__(/*! ../internals/delete-property-or-throw */ "./node_modules/core-js-pure/internals/delete-property-or-throw.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js-pure/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

var max = Math.max;
var min = Math.min;

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    setArrayLength(O, len - actualDeleteCount + insertCount);
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.json.stringify.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.json.stringify.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js-pure/internals/function-apply.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js-pure/internals/array-slice.js");
var getReplacerFunction = __webpack_require__(/*! ../internals/get-json-replacer-function */ "./node_modules/core-js-pure/internals/get-json-replacer-function.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')();
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.json.to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.json.to-string-tag.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.math.to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.math.to-string-tag.js ***!
  \********************************************************************/
/***/ (function() {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.number.is-nan.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.number.is-nan.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");

// `Number.isNaN` method
// https://tc39.es/ecma262/#sec-number.isnan
$({ target: 'Number', stat: true }, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return number != number;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.assign.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.assign.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js-pure/internals/object-assign.js");

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.define-property.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.define-property.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js":
/*!************************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js").f);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");

var FORCED = !DESCRIPTORS || fails(function () { nativeGetOwnPropertyDescriptor(1); });

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.get-prototype-of.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.get-prototype-of.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var nativeGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js-pure/internals/object-get-prototype-of.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js-pure/internals/correct-prototype-getter.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.keys.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.keys.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.set-prototype-of.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.set-prototype-of.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js-pure/internals/object-set-prototype-of.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.to-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.to-string.js ***!
  \******************************************************************/
/***/ (function() {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.parse-int.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.parse-int.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var $parseInt = __webpack_require__(/*! ../internals/number-parse-int */ "./node_modules/core-js-pure/internals/number-parse-int.js");

// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
$({ global: true, forced: parseInt != $parseInt }, {
  parseInt: $parseInt
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.reflect.to-string-tag.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.reflect.to-string-tag.js ***!
  \***********************************************************************/
/***/ (function() {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.string.iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.string.iterator.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var charAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js-pure/internals/string-multibyte.js").charAt);
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js-pure/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js-pure/internals/create-iter-result-object.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.async-iterator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.async-iterator.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.constructor.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js-pure/internals/object-create.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js-pure/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js-pure/internals/object-get-own-property-names-external.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js-pure/internals/object-define-properties.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js-pure/internals/define-built-in-accessor.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js-pure/internals/symbol-define-to-primitive.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");
var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.description.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.description.js ***!
  \********************************************************************/
/***/ (function() {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.for.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.for.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js-pure/internals/symbol-registry-detection.js");

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.has-instance.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.has-instance.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.iterator.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/es.symbol.constructor */ "./node_modules/core-js-pure/modules/es.symbol.constructor.js");
__webpack_require__(/*! ../modules/es.symbol.for */ "./node_modules/core-js-pure/modules/es.symbol.for.js");
__webpack_require__(/*! ../modules/es.symbol.key-for */ "./node_modules/core-js-pure/modules/es.symbol.key-for.js");
__webpack_require__(/*! ../modules/es.json.stringify */ "./node_modules/core-js-pure/modules/es.json.stringify.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-symbols */ "./node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js");


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.key-for.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.key-for.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js-pure/internals/symbol-registry-detection.js");

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.match-all.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.match-all.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.match.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.match.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.replace.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.replace.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.search.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.search.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.species.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.species.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.split.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.split.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.to-primitive.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.to-primitive.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js-pure/internals/symbol-define-to-primitive.js");

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.to-string-tag.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.to-string-tag.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.unscopables.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.unscopables.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.weak-map.constructor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.weak-map.constructor.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js-pure/internals/freezing.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js-pure/internals/define-built-ins.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js-pure/internals/internal-metadata.js");
var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js-pure/internals/collection.js");
var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js-pure/internals/collection-weak.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var enforceInternalState = (__webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js").enforce);
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js-pure/internals/weak-map-basic-detection.js");

var $Object = Object;
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray = Array.isArray;
// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = $Object.isExtensible;
// eslint-disable-next-line es/no-object-isfrozen -- safe
var isFrozen = $Object.isFrozen;
// eslint-disable-next-line es/no-object-issealed -- safe
var isSealed = $Object.isSealed;
// eslint-disable-next-line es/no-object-freeze -- safe
var freeze = $Object.freeze;
// eslint-disable-next-line es/no-object-seal -- safe
var seal = $Object.seal;

var FROZEN = {};
var SEALED = {};
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap = collection('WeakMap', wrapper, collectionWeak);
var WeakMapPrototype = $WeakMap.prototype;
var nativeSet = uncurryThis(WeakMapPrototype.set);

// Chakra Edge bug: adding frozen arrays to WeakMap unfreeze them
var hasMSEdgeFreezingBug = function () {
  return FREEZING && fails(function () {
    var frozenArray = freeze([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen(frozenArray);
  });
};

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP) if (IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  defineBuiltIns(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      } return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      } return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      } return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);
      return this;
    }
  });
// Chakra Edge frozen keys fix
} else if (hasMSEdgeFreezingBug()) {
  defineBuiltIns(WeakMapPrototype, {
    set: function set(key, value) {
      var arrayIntegrityLevel;
      if (isArray(key)) {
        if (isFrozen(key)) arrayIntegrityLevel = FROZEN;
        else if (isSealed(key)) arrayIntegrityLevel = SEALED;
      }
      nativeSet(this, key, value);
      if (arrayIntegrityLevel == FROZEN) freeze(key);
      if (arrayIntegrityLevel == SEALED) seal(key);
      return this;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.weak-map.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.weak-map.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__(/*! ../modules/es.weak-map.constructor */ "./node_modules/core-js-pure/modules/es.weak-map.constructor.js");


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-async-explicit-resource-management
defineWellKnownSymbol('asyncDispose');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.dispose.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.dispose.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-explicit-resource-management
defineWellKnownSymbol('dispose');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.is-registered.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.is-registered.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

var Symbol = getBuiltIn('Symbol');
var keyFor = Symbol.keyFor;
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);

// `Symbol.isRegistered` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregistered
$({ target: 'Symbol', stat: true }, {
  isRegistered: function isRegistered(value) {
    try {
      return keyFor(thisSymbolValue(value)) !== undefined;
    } catch (error) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var Symbol = getBuiltIn('Symbol');
var $isWellKnown = Symbol.isWellKnown;
var getOwnPropertyNames = getBuiltIn('Object', 'getOwnPropertyNames');
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);
var WellKnownSymbolsStore = shared('wks');

for (var i = 0, symbolKeys = getOwnPropertyNames(Symbol), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  // some old engines throws on access to some keys like `arguments` or `caller`
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol(Symbol[symbolKey])) wellKnownSymbol(symbolKey);
  } catch (error) { /* empty */ }
}

// `Symbol.isWellKnown` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknown
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, forced: true }, {
  isWellKnown: function isWellKnown(value) {
    if ($isWellKnown && $isWellKnown(value)) return true;
    try {
      var symbol = thisSymbolValue(value);
      for (var j = 0, keys = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {
        if (WellKnownSymbolsStore[keys[j]] == symbol) return true;
      }
    } catch (error) { /* empty */ }
    return false;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.matcher.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.matcher.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('matcher');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.metadataKey` well-known symbol
// https://github.com/tc39/proposal-decorator-metadata
defineWellKnownSymbol('metadataKey');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.metadata.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// TODO: Remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators
defineWellKnownSymbol('metadata');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.observable.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.replace-all.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.replace-all.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

defineWellKnownSymbol('replaceAll');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/web.dom-collections.iterator.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js-pure/modules/es.array.iterator.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js-pure/internals/dom-iterables.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js-pure/internals/global.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }
  Iterators[COLLECTION_NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/core-js-pure/stable/array/virtual/for-each.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/array/virtual/for-each.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../../es/array/virtual/for-each */ "./node_modules/core-js-pure/es/array/virtual/for-each.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/array/virtual/keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/array/virtual/keys.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../../es/array/virtual/keys */ "./node_modules/core-js-pure/es/array/virtual/keys.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/find-index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/find-index.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/instance/find-index */ "./node_modules/core-js-pure/es/instance/find-index.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/for-each.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/for-each.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js");
var classof = __webpack_require__(/*! ../../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");
var hasOwn = __webpack_require__(/*! ../../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/for-each */ "./node_modules/core-js-pure/stable/array/virtual/for-each.js");

var ArrayPrototype = Array.prototype;

var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

module.exports = function (it) {
  var own = it.forEach;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.forEach)
    || hasOwn(DOMIterables, classof(it)) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/index-of.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/index-of.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/instance/index-of */ "./node_modules/core-js-pure/es/instance/index-of.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/keys.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/keys.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js");
var classof = __webpack_require__(/*! ../../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");
var hasOwn = __webpack_require__(/*! ../../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/keys */ "./node_modules/core-js-pure/stable/array/virtual/keys.js");

var ArrayPrototype = Array.prototype;

var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

module.exports = function (it) {
  var own = it.keys;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.keys)
    || hasOwn(DOMIterables, classof(it)) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/map.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/map.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/instance/map */ "./node_modules/core-js-pure/es/instance/map.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/slice.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/slice.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/instance/slice */ "./node_modules/core-js-pure/es/instance/slice.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/splice.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/splice.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/instance/splice */ "./node_modules/core-js-pure/es/instance/splice.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/json/stringify.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/json/stringify.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/json/stringify */ "./node_modules/core-js-pure/es/json/stringify.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/number/is-nan.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/number/is-nan.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/number/is-nan */ "./node_modules/core-js-pure/es/number/is-nan.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/assign.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/assign.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/object/assign */ "./node_modules/core-js-pure/es/object/assign.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/define-property.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/object/define-property */ "./node_modules/core-js-pure/es/object/define-property.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/get-own-property-descriptor.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/object/get-own-property-descriptor */ "./node_modules/core-js-pure/es/object/get-own-property-descriptor.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/get-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/get-prototype-of.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/object/get-prototype-of */ "./node_modules/core-js-pure/es/object/get-prototype-of.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/keys.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/object/keys */ "./node_modules/core-js-pure/es/object/keys.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/set-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/set-prototype-of.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/object/set-prototype-of */ "./node_modules/core-js-pure/es/object/set-prototype-of.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/parse-int.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/stable/parse-int.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../es/parse-int */ "./node_modules/core-js-pure/es/parse-int.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/symbol/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/symbol/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/symbol */ "./node_modules/core-js-pure/es/symbol/index.js");
__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/symbol/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/symbol/iterator.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/symbol/iterator */ "./node_modules/core-js-pure/es/symbol/iterator.js");
__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/weak-map/index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/weak-map/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__(/*! ../../es/weak-map */ "./node_modules/core-js-pure/es/weak-map/index.js");
__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ (function(module) {

"use strict";


module.exports = earcut;
module.exports["default"] = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/ismobilejs/esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ismobilejs/esm/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport safe */ _isMobile__WEBPACK_IMPORTED_MODULE_0__["default"]; }
/* harmony export */ });
/* harmony import */ var _isMobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isMobile */ "./node_modules/ismobilejs/esm/isMobile.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ismobilejs/esm/isMobile.js":
/*!*************************************************!*\
  !*** ./node_modules/ismobilejs/esm/isMobile.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ isMobile; }
/* harmony export */ });
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
        navigator.platform === 'MacIntel' &&
        typeof navigator.maxTouchPoints === 'number' &&
        navigator.maxTouchPoints > 1 &&
        typeof MSStream === 'undefined');
};
function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
}
function isMobile(param) {
    var nav = {
        userAgent: '',
        platform: '',
        maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
        nav = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
    }
    else if (typeof param === 'string') {
        nav.userAgent = param;
    }
    else if (param && param.userAgent) {
        nav = {
            userAgent: param.userAgent,
            platform: param.platform,
            maxTouchPoints: param.maxTouchPoints || 0
        };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
        apple: {
            phone: match(appleIphone) && !match(windowsPhone),
            ipod: match(appleIpod),
            tablet: !match(appleIphone) &&
                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone),
            universal: match(appleUniversal),
            device: (match(appleIphone) ||
                match(appleIpod) ||
                match(appleTablet) ||
                match(appleUniversal) ||
                isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone)
        },
        amazon: {
            phone: match(amazonPhone),
            tablet: !match(amazonPhone) && match(amazonTablet),
            device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
            phone: (!match(windowsPhone) && match(amazonPhone)) ||
                (!match(windowsPhone) && match(androidPhone)),
            tablet: !match(windowsPhone) &&
                !match(amazonPhone) &&
                !match(androidPhone) &&
                (match(amazonTablet) || match(androidTablet)),
            device: (!match(windowsPhone) &&
                (match(amazonPhone) ||
                    match(amazonTablet) ||
                    match(androidPhone) ||
                    match(androidTablet))) ||
                match(/\bokhttp\b/i)
        },
        windows: {
            phone: match(windowsPhone),
            tablet: match(windowsTablet),
            device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
            blackberry: match(otherBlackBerry),
            blackberry10: match(otherBlackBerry10),
            opera: match(otherOpera),
            firefox: match(otherFirefox),
            chrome: match(otherChrome),
            device: match(otherBlackBerry) ||
                match(otherBlackBerry10) ||
                match(otherOpera) ||
                match(otherFirefox) ||
                match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
    };
    result.any =
        result.apple.device ||
            result.android.device ||
            result.windows.device ||
            result.other.device;
    result.phone =
        result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
        result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
}
//# sourceMappingURL=isMobile.js.map

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ (function(module) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ (function(module) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");


/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ (function(module) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DOMException": function() { return /* binding */ DOMException; },
/* harmony export */   "Headers": function() { return /* binding */ Headers; },
/* harmony export */   "Request": function() { return /* binding */ Request; },
/* harmony export */   "Response": function() { return /* binding */ Response; },
/* harmony export */   "fetch": function() { return /* binding */ fetch; }
/* harmony export */ });
var global =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  (typeof global !== 'undefined' && global)

var support = {
  searchParams: 'URLSearchParams' in global,
  iterable: 'Symbol' in global && 'iterator' in Symbol,
  blob:
    'FileReader' in global &&
    'Blob' in global &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in global,
  arrayBuffer: 'ArrayBuffer' in global
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    this.bodyUsed = this.bodyUsed
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this)
        if (isConsumed) {
          return isConsumed
        }
        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          )
        } else {
          return Promise.resolve(this._bodyArrayBuffer)
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = global.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      setTimeout(function() {
        resolve(new Response(body, options))
      }, 0)
    }

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'))
      }, 0)
    }

    function fixUrl(url) {
      try {
        return url === '' && global.location.href ? global.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob'
      } else if (
        support.arrayBuffer &&
        request.headers.get('Content-Type') &&
        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
      ) {
        xhr.responseType = 'arraybuffer'
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
      })
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!global.fetch) {
  global.fetch = fetch
  global.Headers = Headers
  global.Request = Request
  global.Response = Response
}


/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/find-index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/find-index.js ***!
  \***********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/find-index */ "./node_modules/core-js-pure/stable/instance/find-index.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/for-each */ "./node_modules/core-js-pure/stable/instance/for-each.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/index-of.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/index-of.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/index-of */ "./node_modules/core-js-pure/stable/instance/index-of.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/keys.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/keys.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/keys */ "./node_modules/core-js-pure/stable/instance/keys.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/map */ "./node_modules/core-js-pure/stable/instance/map.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/slice.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/slice.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/slice */ "./node_modules/core-js-pure/stable/instance/slice.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/splice.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/splice.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/splice */ "./node_modules/core-js-pure/stable/instance/splice.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/json/stringify.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/json/stringify.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/json/stringify */ "./node_modules/core-js-pure/stable/json/stringify.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/number/is-nan.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/number/is-nan.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/number/is-nan */ "./node_modules/core-js-pure/stable/number/is-nan.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/assign.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/assign.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/assign */ "./node_modules/core-js-pure/stable/object/assign.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/define-property */ "./node_modules/core-js-pure/stable/object/define-property.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js ***!
  \**************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/get-own-property-descriptor */ "./node_modules/core-js-pure/stable/object/get-own-property-descriptor.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-prototype-of.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-prototype-of.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/get-prototype-of */ "./node_modules/core-js-pure/stable/object/get-prototype-of.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/keys */ "./node_modules/core-js-pure/stable/object/keys.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/set-prototype-of.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/set-prototype-of.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/set-prototype-of */ "./node_modules/core-js-pure/stable/object/set-prototype-of.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/parse-int.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/parse-int.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/parse-int */ "./node_modules/core-js-pure/stable/parse-int.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/weak-map.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/weak-map.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/stable/weak-map */ "./node_modules/core-js-pure/stable/weak-map/index.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js/symbol.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js/symbol.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/features/symbol */ "./node_modules/core-js-pure/features/symbol/index.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js/symbol/iterator.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js/symbol/iterator.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js-pure/features/symbol/iterator */ "./node_modules/core-js-pure/features/symbol/iterator.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/helpers/esm/typeof.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/helpers/esm/typeof.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _typeof; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_corejs3_core_js_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js/symbol */ "./node_modules/@babel/runtime-corejs3/core-js/symbol.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_symbol_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js/symbol/iterator */ "./node_modules/@babel/runtime-corejs3/core-js/symbol/iterator.js");


function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof _babel_runtime_corejs3_core_js_symbol__WEBPACK_IMPORTED_MODULE_0__ && "symbol" == typeof _babel_runtime_corejs3_core_js_symbol_iterator__WEBPACK_IMPORTED_MODULE_1__ ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof _babel_runtime_corejs3_core_js_symbol__WEBPACK_IMPORTED_MODULE_0__ && obj.constructor === _babel_runtime_corejs3_core_js_symbol__WEBPACK_IMPORTED_MODULE_0__ && obj !== _babel_runtime_corejs3_core_js_symbol__WEBPACK_IMPORTED_MODULE_0__.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/SpineBase.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/SpineBase.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpineBase": function() { return /* binding */ SpineBase; },
/* harmony export */   "SpineMesh": function() { return /* binding */ SpineMesh; },
/* harmony export */   "SpineSprite": function() { return /* binding */ SpineSprite; }
/* harmony export */ });
/* harmony import */ var _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/AttachmentType.mjs */ "./node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs");
/* harmony import */ var _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/TextureRegion.mjs */ "./node_modules/@pixi-spine/base/lib/core/TextureRegion.mjs");
/* harmony import */ var _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/Utils.mjs */ "./node_modules/@pixi-spine/base/lib/core/Utils.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.mjs");
/* harmony import */ var _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pixi/mesh-extras */ "./node_modules/@pixi/mesh-extras/lib/index.mjs");
/* harmony import */ var _pixi_graphics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/index.mjs");
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi-spine/base/lib/settings.mjs");










const tempRgb = [0, 0, 0];
class SpineSprite extends _pixi_sprite__WEBPACK_IMPORTED_MODULE_5__.Sprite {
  constructor() {
    super(...arguments);
    this.region = null;
    this.attachment = null;
  }
}
class SpineMesh extends _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_6__.SimpleMesh {
  constructor(texture, vertices, uvs, indices, drawMode) {
    super(texture, vertices, uvs, indices, drawMode);
    this.region = null;
    this.attachment = null;
  }
}
const _SpineBase = class extends _pixi_display__WEBPACK_IMPORTED_MODULE_4__.Container {
  constructor(spineData) {
    super();
    if (!spineData) {
      throw new Error("The spineData param is required.");
    }
    if (typeof spineData === "string") {
      throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
    }
    this.spineData = spineData;
    this.createSkeleton(spineData);
    this.slotContainers = [];
    this.tempClipContainers = [];
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.newContainer();
      this.slotContainers.push(slotContainer);
      this.addChild(slotContainer);
      this.tempClipContainers.push(null);
      if (!attachment) {
        continue;
      }
      if (attachment.type === _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType.Region) {
        const spriteName = attachment.name;
        const sprite = this.createSprite(slot, attachment, spriteName);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
      } else if (attachment.type === _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType.Mesh) {
        const mesh = this.createMesh(slot, attachment);
        slot.currentMesh = mesh;
        slot.currentMeshId = attachment.id;
        slot.currentMeshName = attachment.name;
        slotContainer.addChild(mesh);
      } else if (attachment.type === _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType.Clipping) {
        this.createGraphics(slot, attachment);
        slotContainer.addChild(slot.clippingContainer);
        slotContainer.addChild(slot.currentGraphics);
      }
    }
    this.tintRgb = new Float32Array([1, 1, 1]);
    this.autoUpdate = true;
    this.visible = true;
  }
  get debug() {
    return this._debug;
  }
  set debug(value) {
    if (value == this._debug) {
      return;
    }
    this._debug?.unregisterSpine(this);
    value?.registerSpine(this);
    this._debug = value;
  }
  /**
   * If this flag is set to true, the spine animation will be automatically updated every
   * time the object id drawn. The down side of this approach is that the delta time is
   * automatically calculated and you could miss out on cool effects like slow motion,
   * pause, skip ahead and the sorts. Most of these effects can be achieved even with
   * autoUpdate enabled but are harder to achieve.
   *
   * @member {boolean}
   * @memberof spine.Spine#
   * @default true
   */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      this.updateTransform = value ? _SpineBase.prototype.autoUpdateTransform : _pixi_display__WEBPACK_IMPORTED_MODULE_4__.Container.prototype.updateTransform;
    }
  }
  /**
   * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
   *
   * @member {number}
   * @memberof spine.Spine#
   * @default 0xFFFFFF
   */
  get tint() {
    return _pixi_core__WEBPACK_IMPORTED_MODULE_3__.utils.rgb2hex(this.tintRgb);
  }
  set tint(value) {
    this.tintRgb = _pixi_core__WEBPACK_IMPORTED_MODULE_3__.utils.hex2rgb(value, this.tintRgb);
  }
  /**
   * Limit value for the update dt with Spine.globalDelayLimit
   * that can be overridden with localDelayLimit
   * @return {number} - Maximum processed dt value for the update
   */
  get delayLimit() {
    const limit = typeof this.localDelayLimit !== "undefined" ? this.localDelayLimit : _settings_mjs__WEBPACK_IMPORTED_MODULE_8__.settings.GLOBAL_DELAY_LIMIT;
    return limit || Number.MAX_VALUE;
  }
  /**
   * Update the spine skeleton and its animations by delta time (dt)
   *
   * @param dt {number} Delta time. Time by which the animation should be updated
   */
  update(dt) {
    const delayLimit = this.delayLimit;
    if (dt > delayLimit)
      dt = delayLimit;
    this.state.update(dt);
    this.state.apply(this.skeleton);
    if (!this.skeleton) {
      return;
    }
    this.skeleton.updateWorldTransform();
    const slots = this.skeleton.slots;
    const globalClr = this.color;
    let light = null;
    let dark = null;
    if (globalClr) {
      light = globalClr.light;
      dark = globalClr.dark;
    } else {
      light = this.tintRgb;
    }
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      const slotContainer = this.slotContainers[i];
      if (!attachment) {
        slotContainer.visible = false;
        continue;
      }
      let spriteColor = null;
      if (attachment.sequence) {
        attachment.sequence.apply(slot, attachment);
      }
      let region = attachment.region;
      const attColor = attachment.color;
      switch (attachment != null && attachment.type) {
        case _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType.Region:
          const transform = slotContainer.transform;
          transform.setFromMatrix(slot.bone.matrix);
          region = attachment.region;
          if (slot.currentMesh) {
            slot.currentMesh.visible = false;
            slot.currentMesh = null;
            slot.currentMeshId = void 0;
            slot.currentMeshName = void 0;
          }
          if (!region) {
            if (slot.currentSprite) {
              slot.currentSprite.renderable = false;
            }
            break;
          }
          if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {
            const spriteName = attachment.name;
            if (slot.currentSprite) {
              slot.currentSprite.visible = false;
            }
            slot.sprites = slot.sprites || {};
            if (slot.sprites[spriteName] !== void 0) {
              slot.sprites[spriteName].visible = true;
            } else {
              const sprite = this.createSprite(slot, attachment, spriteName);
              slotContainer.addChild(sprite);
            }
            slot.currentSprite = slot.sprites[spriteName];
            slot.currentSpriteName = spriteName;
          }
          slot.currentSprite.renderable = true;
          if (!slot.hackRegion) {
            this.setSpriteRegion(attachment, slot.currentSprite, region);
          }
          if (slot.currentSprite.color) {
            spriteColor = slot.currentSprite.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentSprite.tint = _pixi_core__WEBPACK_IMPORTED_MODULE_3__.utils.rgb2hex(tempRgb);
          }
          slot.currentSprite.blendMode = slot.blendMode;
          break;
        case _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType.Mesh:
          if (slot.currentSprite) {
            slot.currentSprite.visible = false;
            slot.currentSprite = null;
            slot.currentSpriteName = void 0;
            const transform2 = new _pixi_core__WEBPACK_IMPORTED_MODULE_3__.Transform();
            transform2._parentID = -1;
            transform2._worldID = slotContainer.transform._worldID;
            slotContainer.transform = transform2;
          }
          if (!region) {
            if (slot.currentMesh) {
              slot.currentMesh.renderable = false;
            }
            break;
          }
          const id = attachment.id;
          if (slot.currentMeshId === void 0 || slot.currentMeshId !== id) {
            const meshId = id;
            if (slot.currentMesh) {
              slot.currentMesh.visible = false;
            }
            slot.meshes = slot.meshes || {};
            if (slot.meshes[meshId] !== void 0) {
              slot.meshes[meshId].visible = true;
            } else {
              const mesh = this.createMesh(slot, attachment);
              slotContainer.addChild(mesh);
            }
            slot.currentMesh = slot.meshes[meshId];
            slot.currentMeshName = attachment.name;
            slot.currentMeshId = meshId;
          }
          slot.currentMesh.renderable = true;
          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);
          if (slot.currentMesh.color) {
            spriteColor = slot.currentMesh.color;
          } else {
            tempRgb[0] = light[0] * slot.color.r * attColor.r;
            tempRgb[1] = light[1] * slot.color.g * attColor.g;
            tempRgb[2] = light[2] * slot.color.b * attColor.b;
            slot.currentMesh.tint = _pixi_core__WEBPACK_IMPORTED_MODULE_3__.utils.rgb2hex(tempRgb);
          }
          slot.currentMesh.blendMode = slot.blendMode;
          if (!slot.hackRegion) {
            this.setMeshRegion(attachment, slot.currentMesh, region);
          }
          break;
        case _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType.Clipping:
          if (!slot.currentGraphics) {
            this.createGraphics(slot, attachment);
            slotContainer.addChild(slot.clippingContainer);
            slotContainer.addChild(slot.currentGraphics);
          }
          this.updateGraphics(slot, attachment);
          slotContainer.alpha = 1;
          slotContainer.visible = true;
          continue;
        default:
          slotContainer.visible = false;
          continue;
      }
      slotContainer.visible = true;
      if (spriteColor) {
        let r0 = slot.color.r * attColor.r;
        let g0 = slot.color.g * attColor.g;
        let b0 = slot.color.b * attColor.b;
        spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
        if (slot.darkColor) {
          r0 = slot.darkColor.r;
          g0 = slot.darkColor.g;
          b0 = slot.darkColor.b;
        } else {
          r0 = 0;
          g0 = 0;
          b0 = 0;
        }
        spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));
      }
      slotContainer.alpha = slot.color.a;
    }
    const drawOrder = this.skeleton.drawOrder;
    let clippingAttachment = null;
    let clippingContainer = null;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = slots[drawOrder[i].data.index];
      const slotContainer = this.slotContainers[drawOrder[i].data.index];
      if (!clippingContainer) {
        if (slotContainer.parent !== null && slotContainer.parent !== this) {
          slotContainer.parent.removeChild(slotContainer);
          slotContainer.parent = this;
        }
      }
      if (slot.currentGraphics && slot.getAttachment()) {
        clippingContainer = slot.clippingContainer;
        clippingAttachment = slot.getAttachment();
        clippingContainer.children.length = 0;
        this.children[i] = slotContainer;
        if (clippingAttachment.endSlot === slot.data) {
          clippingAttachment.endSlot = null;
        }
      } else if (clippingContainer) {
        let c = this.tempClipContainers[i];
        if (!c) {
          c = this.tempClipContainers[i] = this.newContainer();
          c.visible = false;
        }
        this.children[i] = c;
        slotContainer.parent = null;
        clippingContainer.addChild(slotContainer);
        if (clippingAttachment.endSlot == slot.data) {
          clippingContainer.renderable = true;
          clippingContainer = null;
          clippingAttachment = null;
        }
      } else {
        this.children[i] = slotContainer;
      }
    }
    this._debug?.renderDebug(this);
  }
  setSpriteRegion(attachment, sprite, region) {
    if (sprite.attachment === attachment && sprite.region === region) {
      return;
    }
    sprite.region = region;
    sprite.attachment = attachment;
    sprite.texture = region.texture;
    sprite.rotation = attachment.rotation * _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__.MathUtils.degRad;
    sprite.position.x = attachment.x;
    sprite.position.y = attachment.y;
    sprite.alpha = attachment.color.a;
    if (!region.size) {
      sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;
      sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;
    } else {
      sprite.scale.x = region.size.width / region.originalWidth;
      sprite.scale.y = -region.size.height / region.originalHeight;
    }
  }
  setMeshRegion(attachment, mesh, region) {
    if (mesh.attachment === attachment && mesh.region === region) {
      return;
    }
    mesh.region = region;
    mesh.attachment = attachment;
    mesh.texture = region.texture;
    region.texture.updateUvs();
    mesh.uvBuffer.update(attachment.regionUVs);
  }
  /**
   * When autoupdate is set to yes this function is used as pixi's updateTransform function
   *
   * @private
   */
  autoUpdateTransform() {
    if (_settings_mjs__WEBPACK_IMPORTED_MODULE_8__.settings.GLOBAL_AUTO_UPDATE) {
      this.lastTime = this.lastTime || Date.now();
      const timeDelta = (Date.now() - this.lastTime) * 1e-3;
      this.lastTime = Date.now();
      this.update(timeDelta);
    } else {
      this.lastTime = 0;
    }
    _pixi_display__WEBPACK_IMPORTED_MODULE_4__.Container.prototype.updateTransform.call(this);
  }
  /**
   * Create a new sprite to be used with core.RegionAttachment
   *
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createSprite(slot, attachment, defName) {
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
    }
    const texture = region ? region.texture : null;
    const sprite = this.newSprite(texture);
    sprite.anchor.set(0.5);
    if (region) {
      this.setSpriteRegion(attachment, sprite, attachment.region);
    }
    slot.sprites = slot.sprites || {};
    slot.sprites[defName] = sprite;
    return sprite;
  }
  /**
   * Creates a Strip from the spine data
   * @param slot {spine.Slot} The slot to which the attachment is parented
   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent
   * @private
   */
  createMesh(slot, attachment) {
    let region = attachment.region;
    if (slot.hackAttachment === attachment) {
      region = slot.hackRegion;
      slot.hackAttachment = null;
      slot.hackRegion = null;
    }
    const strip = this.newMesh(
      region ? region.texture : null,
      new Float32Array(attachment.regionUVs.length),
      attachment.regionUVs,
      new Uint16Array(attachment.triangles),
      _pixi_core__WEBPACK_IMPORTED_MODULE_3__.DRAW_MODES.TRIANGLES
    );
    if (typeof strip._canvasPadding !== "undefined") {
      strip._canvasPadding = 1.5;
    }
    strip.alpha = attachment.color.a;
    strip.region = attachment.region;
    if (region) {
      this.setMeshRegion(attachment, strip, region);
    }
    slot.meshes = slot.meshes || {};
    slot.meshes[attachment.id] = strip;
    return strip;
  }
  // @ts-ignore
  createGraphics(slot, clip) {
    const graphics = this.newGraphics();
    const poly = new _pixi_core__WEBPACK_IMPORTED_MODULE_3__.Polygon([]);
    graphics.clear();
    graphics.beginFill(16777215, 1);
    graphics.drawPolygon(poly);
    graphics.renderable = false;
    slot.currentGraphics = graphics;
    slot.clippingContainer = this.newContainer();
    slot.clippingContainer.mask = slot.currentGraphics;
    return graphics;
  }
  updateGraphics(slot, clip) {
    const geom = slot.currentGraphics.geometry;
    const vertices = geom.graphicsData[0].shape.points;
    const n = clip.worldVerticesLength;
    vertices.length = n;
    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
    geom.invalidate();
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotIndex {number}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotIndex(slotIndex, texture = null, size = null) {
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const attachment = slot.getAttachment();
    let region = attachment.region;
    if (texture) {
      region = new _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureRegion();
      region.texture = texture;
      region.size = size;
      slot.hackRegion = region;
      slot.hackAttachment = attachment;
    } else {
      slot.hackRegion = null;
      slot.hackAttachment = null;
    }
    if (slot.currentSprite) {
      this.setSpriteRegion(attachment, slot.currentSprite, region);
    } else if (slot.currentMesh) {
      this.setMeshRegion(attachment, slot.currentMesh, region);
    }
    return true;
  }
  /**
   * Changes texture in attachment in specific slot.
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureBySlotName(slotName, texture = null, size = null) {
    const index = this.skeleton.findSlotIndex(slotName);
    if (index == -1) {
      return false;
    }
    return this.hackTextureBySlotIndex(index, texture, size);
  }
  /**
   * Changes texture of an attachment
   *
   * PIXI runtime feature, it was made to satisfy our users.
   *
   * @param slotName {string}
   * @param attachmentName {string}
   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture
   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there
   * @returns {boolean} Success flag
   */
  hackTextureAttachment(slotName, attachmentName, texture, size = null) {
    const slotIndex = this.skeleton.findSlotIndex(slotName);
    const attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);
    attachment.region.texture = texture;
    const slot = this.skeleton.slots[slotIndex];
    if (!slot) {
      return false;
    }
    const currentAttachment = slot.getAttachment();
    if (attachmentName === currentAttachment.name) {
      let region = attachment.region;
      if (texture) {
        region = new _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureRegion();
        region.texture = texture;
        region.size = size;
        slot.hackRegion = region;
        slot.hackAttachment = currentAttachment;
      } else {
        slot.hackRegion = null;
        slot.hackAttachment = null;
      }
      if (slot.currentSprite && slot.currentSprite.region != region) {
        this.setSpriteRegion(currentAttachment, slot.currentSprite, region);
        slot.currentSprite.region = region;
      } else if (slot.currentMesh && slot.currentMesh.region != region) {
        this.setMeshRegion(currentAttachment, slot.currentMesh, region);
      }
      return true;
    }
    return false;
  }
  // those methods can be overriden to spawn different classes
  newContainer() {
    return new _pixi_display__WEBPACK_IMPORTED_MODULE_4__.Container();
  }
  newSprite(tex) {
    return new SpineSprite(tex);
  }
  newGraphics() {
    return new _pixi_graphics__WEBPACK_IMPORTED_MODULE_7__.Graphics();
  }
  newMesh(texture, vertices, uvs, indices, drawMode) {
    return new SpineMesh(texture, vertices, uvs, indices, drawMode);
  }
  transformHack() {
    return 1;
  }
  /**
   * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer
   * @param nameSuffix
   * @param group
   * @param outGroup
   */
  hackAttachmentGroups(nameSuffix, group, outGroup) {
    if (!nameSuffix) {
      return void 0;
    }
    const list_d = [];
    const list_n = [];
    for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {
      const slot = this.skeleton.slots[i];
      const name = slot.currentSpriteName || slot.currentMeshName || "";
      const target = slot.currentSprite || slot.currentMesh;
      if (name.endsWith(nameSuffix)) {
        target.parentGroup = group;
        list_n.push(target);
      } else if (outGroup && target) {
        target.parentGroup = outGroup;
        list_d.push(target);
      }
    }
    return [list_d, list_n];
  }
  destroy(options) {
    this.debug = null;
    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {
      const slot = this.skeleton.slots[i];
      for (const name in slot.meshes) {
        slot.meshes[name].destroy(options);
      }
      slot.meshes = null;
      for (const name in slot.sprites) {
        slot.sprites[name].destroy(options);
      }
      slot.sprites = null;
    }
    for (let i = 0, n = this.slotContainers.length; i < n; i++) {
      this.slotContainers[i].destroy(options);
    }
    this.spineData = null;
    this.skeleton = null;
    this.slotContainers = null;
    this.stateData = null;
    this.state = null;
    this.tempClipContainers = null;
    super.destroy(options);
  }
};
let SpineBase = _SpineBase;
SpineBase.clippingPolygon = [];
Object.defineProperty(SpineBase.prototype, "visible", {
  get() {
    return this._visible;
  },
  set(value) {
    if (value !== this._visible) {
      this._visible = value;
      if (value) {
        this.lastTime = 0;
      }
    }
  }
});


//# sourceMappingURL=SpineBase.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/SpineDebugRenderer.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/SpineDebugRenderer.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpineDebugRenderer": function() { return /* binding */ SpineDebugRenderer; }
/* harmony export */ });
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/index.mjs");
/* harmony import */ var _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/AttachmentType.mjs */ "./node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs");
/* harmony import */ var _core_SkeletonBoundsBase_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/SkeletonBoundsBase.mjs */ "./node_modules/@pixi-spine/base/lib/core/SkeletonBoundsBase.mjs");





class SpineDebugRenderer {
  constructor() {
    this.registeredSpines = /* @__PURE__ */ new Map();
    this.drawDebug = true;
    this.drawMeshHull = true;
    this.drawMeshTriangles = true;
    this.drawBones = true;
    this.drawPaths = true;
    this.drawBoundingBoxes = true;
    this.drawClipping = true;
    this.drawRegionAttachments = true;
    this.lineWidth = 1;
    this.regionAttachmentsColor = 30975;
    this.meshHullColor = 30975;
    this.meshTrianglesColor = 16763904;
    this.clippingPolygonColor = 16711935;
    this.boundingBoxesRectColor = 65280;
    this.boundingBoxesPolygonColor = 65280;
    this.boundingBoxesCircleColor = 65280;
    this.pathsCurveColor = 16711680;
    this.pathsLineColor = 16711935;
    this.skeletonXYColor = 16711680;
    this.bonesColor = 61132;
  }
  /**
   * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update
   */
  registerSpine(spine) {
    if (this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!", spine);
    }
    const debugDisplayObjects = {
      parentDebugContainer: new _pixi_display__WEBPACK_IMPORTED_MODULE_0__.Container(),
      bones: new _pixi_display__WEBPACK_IMPORTED_MODULE_0__.Container(),
      skeletonXY: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      regionAttachmentsShape: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      meshTrianglesLine: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      meshHullLine: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      clippingPolygon: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      boundingBoxesRect: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      boundingBoxesCircle: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      boundingBoxesPolygon: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      pathsCurve: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(),
      pathsLine: new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics()
    };
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);
    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);
    spine.addChild(debugDisplayObjects.parentDebugContainer);
    this.registeredSpines.set(spine, debugDisplayObjects);
  }
  renderDebug(spine) {
    if (!this.registeredSpines.has(spine)) {
      this.registerSpine(spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.skeletonXY.clear();
    debugDisplayObjects.regionAttachmentsShape.clear();
    debugDisplayObjects.meshTrianglesLine.clear();
    debugDisplayObjects.meshHullLine.clear();
    debugDisplayObjects.clippingPolygon.clear();
    debugDisplayObjects.boundingBoxesRect.clear();
    debugDisplayObjects.boundingBoxesCircle.clear();
    debugDisplayObjects.boundingBoxesPolygon.clear();
    debugDisplayObjects.pathsCurve.clear();
    debugDisplayObjects.pathsLine.clear();
    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {
      debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });
    }
    const scale = spine.scale.x || spine.scale.y || 1;
    const lineWidth = this.lineWidth / scale;
    if (this.drawBones) {
      this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);
    }
    if (this.drawPaths) {
      this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawBoundingBoxes) {
      this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawClipping) {
      this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawMeshHull || this.drawMeshTriangles) {
      this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);
    }
    if (this.drawRegionAttachments) {
      this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);
    }
  }
  drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale) {
    const skeleton = spine.skeleton;
    const skeletonX = skeleton.x;
    const skeletonY = skeleton.y;
    const bones = skeleton.bones;
    debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);
    for (let i = 0, len = bones.length; i < len; i++) {
      const bone = bones[i];
      const boneLen = bone.data.length;
      const starX = skeletonX + bone.matrix.tx;
      const starY = skeletonY + bone.matrix.ty;
      const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;
      const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;
      if (bone.data.name === "root" || bone.data.parent === null) {
        continue;
      }
      const w = Math.abs(starX - endX);
      const h = Math.abs(starY - endY);
      const a2 = Math.pow(w, 2);
      const b = h;
      const b2 = Math.pow(h, 2);
      const c = Math.sqrt(a2 + b2);
      const c2 = Math.pow(c, 2);
      const rad = Math.PI / 180;
      const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;
      if (c === 0) {
        continue;
      }
      const gp = new _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics();
      debugDisplayObjects.bones.addChild(gp);
      const refRation = c / 50 / scale;
      gp.beginFill(this.bonesColor, 1);
      gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);
      gp.endFill();
      gp.x = starX;
      gp.y = starY;
      gp.pivot.y = c;
      let rotation = 0;
      if (starX < endX && starY < endY) {
        rotation = -B + 180 * rad;
      } else if (starX > endX && starY < endY) {
        rotation = 180 * rad + B;
      } else if (starX > endX && starY > endY) {
        rotation = -B;
      } else if (starX < endX && starY > endY) {
        rotation = B;
      } else if (starY === endY && starX < endX) {
        rotation = 90 * rad;
      } else if (starY === endY && starX > endX) {
        rotation = -90 * rad;
      } else if (starX === endX && starY < endY) {
        rotation = 180 * rad;
      } else if (starX === endX && starY > endY) {
        rotation = 0;
      }
      gp.rotation = rotation;
      gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);
      gp.beginFill(0, 0.6);
      gp.drawCircle(0, c, refRation * 1.2);
      gp.endFill();
    }
    const startDotSize = lineWidth * 3;
    debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);
    debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);
    debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);
  }
  drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_2__.AttachmentType.Region) {
        continue;
      }
      const regionAttachment = attachment;
      const vertices = new Float32Array(8);
      if (regionAttachment.updateOffset)
        regionAttachment.updateOffset();
      regionAttachment.computeWorldVertices(slot, vertices, 0, 2);
      debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));
    }
  }
  drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);
    debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_2__.AttachmentType.Mesh) {
        continue;
      }
      const meshAttachment = attachment;
      const vertices = new Float32Array(meshAttachment.worldVerticesLength);
      const triangles = meshAttachment.triangles;
      let hullLength = meshAttachment.hullLength;
      meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);
      if (this.drawMeshTriangles) {
        for (let i2 = 0, len2 = triangles.length; i2 < len2; i2 += 3) {
          const v1 = triangles[i2] * 2;
          const v2 = triangles[i2 + 1] * 2;
          const v3 = triangles[i2 + 2] * 2;
          debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);
          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);
        }
      }
      if (this.drawMeshHull && hullLength > 0) {
        hullLength = (hullLength >> 1) * 2;
        let lastX = vertices[hullLength - 2];
        let lastY = vertices[hullLength - 1];
        for (let i2 = 0, len2 = hullLength; i2 < len2; i2 += 2) {
          const x = vertices[i2];
          const y = vertices[i2 + 1];
          debugDisplayObjects.meshHullLine.moveTo(x, y);
          debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);
          lastX = x;
          lastY = y;
        }
      }
    }
  }
  drawClippingFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_2__.AttachmentType.Clipping) {
        continue;
      }
      const clippingAttachment = attachment;
      const nn = clippingAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));
    }
  }
  drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth) {
    debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);
    const bounds = new _core_SkeletonBoundsBase_mjs__WEBPACK_IMPORTED_MODULE_3__.SkeletonBoundsBase();
    bounds.update(spine.skeleton, true);
    debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());
    const polygons = bounds.polygons;
    const drawPolygon = (polygonVertices, _offset, count) => {
      debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);
      debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);
      if (count < 3) {
        throw new Error("Polygon must contain at least 3 vertices");
      }
      const paths = [];
      const dotSize = lineWidth * 2;
      for (let i = 0, len = polygonVertices.length; i < len; i += 2) {
        const x1 = polygonVertices[i];
        const y1 = polygonVertices[i + 1];
        debugDisplayObjects.boundingBoxesCircle.lineStyle(0);
        debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);
        debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);
        debugDisplayObjects.boundingBoxesCircle.endFill();
        paths.push(x1, y1);
      }
      debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);
      debugDisplayObjects.boundingBoxesPolygon.endFill();
    };
    for (let i = 0, len = polygons.length; i < len; i++) {
      const polygon = polygons[i];
      drawPolygon(polygon, 0, polygon.length);
    }
  }
  drawPathsFunc(spine, debugDisplayObjects, lineWidth) {
    const skeleton = spine.skeleton;
    const slots = skeleton.slots;
    debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);
    debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);
    for (let i = 0, len = slots.length; i < len; i++) {
      const slot = slots[i];
      if (!slot.bone.active) {
        continue;
      }
      const attachment = slot.getAttachment();
      if (attachment == null || attachment.type !== _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_2__.AttachmentType.Path) {
        continue;
      }
      const pathAttachment = attachment;
      let nn = pathAttachment.worldVerticesLength;
      const world = new Float32Array(nn);
      pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);
      let x1 = world[2];
      let y1 = world[3];
      let x2 = 0;
      let y2 = 0;
      if (pathAttachment.closed) {
        const cx1 = world[0];
        const cy1 = world[1];
        const cx2 = world[nn - 2];
        const cy2 = world[nn - 1];
        x2 = world[nn - 4];
        y2 = world[nn - 3];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
      }
      nn -= 4;
      for (let ii = 4; ii < nn; ii += 6) {
        const cx1 = world[ii];
        const cy1 = world[ii + 1];
        const cx2 = world[ii + 2];
        const cy2 = world[ii + 3];
        x2 = world[ii + 4];
        y2 = world[ii + 5];
        debugDisplayObjects.pathsCurve.moveTo(x1, y1);
        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
        debugDisplayObjects.pathsLine.moveTo(x1, y1);
        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);
        debugDisplayObjects.pathsLine.moveTo(x2, y2);
        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);
        x1 = x2;
        y1 = y2;
      }
    }
  }
  unregisterSpine(spine) {
    if (!this.registeredSpines.has(spine)) {
      console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!", spine);
    }
    const debugDisplayObjects = this.registeredSpines.get(spine);
    debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });
    this.registeredSpines.delete(spine);
  }
}


//# sourceMappingURL=SpineDebugRenderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachmentType": function() { return /* binding */ AttachmentType; }
/* harmony export */ });
var AttachmentType = /* @__PURE__ */ ((AttachmentType2) => {
  AttachmentType2[AttachmentType2["Region"] = 0] = "Region";
  AttachmentType2[AttachmentType2["BoundingBox"] = 1] = "BoundingBox";
  AttachmentType2[AttachmentType2["Mesh"] = 2] = "Mesh";
  AttachmentType2[AttachmentType2["LinkedMesh"] = 3] = "LinkedMesh";
  AttachmentType2[AttachmentType2["Path"] = 4] = "Path";
  AttachmentType2[AttachmentType2["Point"] = 5] = "Point";
  AttachmentType2[AttachmentType2["Clipping"] = 6] = "Clipping";
  return AttachmentType2;
})(AttachmentType || {});


//# sourceMappingURL=AttachmentType.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/BinaryInput.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/BinaryInput.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BinaryInput": function() { return /* binding */ BinaryInput; }
/* harmony export */ });
class BinaryInput {
  constructor(data, strings = new Array(), index = 0, buffer = new DataView(data.buffer)) {
    this.strings = strings;
    this.index = index;
    this.buffer = buffer;
  }
  readByte() {
    return this.buffer.getInt8(this.index++);
  }
  readUnsignedByte() {
    return this.buffer.getUint8(this.index++);
  }
  readShort() {
    const value = this.buffer.getInt16(this.index);
    this.index += 2;
    return value;
  }
  readInt32() {
    const value = this.buffer.getInt32(this.index);
    this.index += 4;
    return value;
  }
  readInt(optimizePositive) {
    let b = this.readByte();
    let result = b & 127;
    if ((b & 128) != 0) {
      b = this.readByte();
      result |= (b & 127) << 7;
      if ((b & 128) != 0) {
        b = this.readByte();
        result |= (b & 127) << 14;
        if ((b & 128) != 0) {
          b = this.readByte();
          result |= (b & 127) << 21;
          if ((b & 128) != 0) {
            b = this.readByte();
            result |= (b & 127) << 28;
          }
        }
      }
    }
    return optimizePositive ? result : result >>> 1 ^ -(result & 1);
  }
  readStringRef() {
    const index = this.readInt(true);
    return index == 0 ? null : this.strings[index - 1];
  }
  readString() {
    let byteCount = this.readInt(true);
    switch (byteCount) {
      case 0:
        return null;
      case 1:
        return "";
    }
    byteCount--;
    let chars = "";
    for (let i = 0; i < byteCount; ) {
      const b = this.readUnsignedByte();
      switch (b >> 4) {
        case 12:
        case 13:
          chars += String.fromCharCode((b & 31) << 6 | this.readByte() & 63);
          i += 2;
          break;
        case 14:
          chars += String.fromCharCode((b & 15) << 12 | (this.readByte() & 63) << 6 | this.readByte() & 63);
          i += 3;
          break;
        default:
          chars += String.fromCharCode(b);
          i++;
      }
    }
    return chars;
  }
  readFloat() {
    const value = this.buffer.getFloat32(this.index);
    this.index += 4;
    return value;
  }
  readBoolean() {
    return this.readByte() != 0;
  }
}


//# sourceMappingURL=BinaryInput.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/IAnimation.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/IAnimation.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MixBlend": function() { return /* binding */ MixBlend; },
/* harmony export */   "MixDirection": function() { return /* binding */ MixDirection; }
/* harmony export */ });
var MixBlend = /* @__PURE__ */ ((MixBlend2) => {
  MixBlend2[MixBlend2["setup"] = 0] = "setup";
  MixBlend2[MixBlend2["first"] = 1] = "first";
  MixBlend2[MixBlend2["replace"] = 2] = "replace";
  MixBlend2[MixBlend2["add"] = 3] = "add";
  return MixBlend2;
})(MixBlend || {});
var MixDirection = /* @__PURE__ */ ((MixDirection2) => {
  MixDirection2[MixDirection2["mixIn"] = 0] = "mixIn";
  MixDirection2[MixDirection2["mixOut"] = 1] = "mixOut";
  return MixDirection2;
})(MixDirection || {});


//# sourceMappingURL=IAnimation.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/IConstraint.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/IConstraint.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PositionMode": function() { return /* binding */ PositionMode; },
/* harmony export */   "RotateMode": function() { return /* binding */ RotateMode; }
/* harmony export */ });
var PositionMode = /* @__PURE__ */ ((PositionMode2) => {
  PositionMode2[PositionMode2["Fixed"] = 0] = "Fixed";
  PositionMode2[PositionMode2["Percent"] = 1] = "Percent";
  return PositionMode2;
})(PositionMode || {});
var RotateMode = /* @__PURE__ */ ((RotateMode2) => {
  RotateMode2[RotateMode2["Tangent"] = 0] = "Tangent";
  RotateMode2[RotateMode2["Chain"] = 1] = "Chain";
  RotateMode2[RotateMode2["ChainScale"] = 2] = "ChainScale";
  return RotateMode2;
})(RotateMode || {});


//# sourceMappingURL=IConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/ISkeleton.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/ISkeleton.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformMode": function() { return /* binding */ TransformMode; }
/* harmony export */ });
var TransformMode = /* @__PURE__ */ ((TransformMode2) => {
  TransformMode2[TransformMode2["Normal"] = 0] = "Normal";
  TransformMode2[TransformMode2["OnlyTranslation"] = 1] = "OnlyTranslation";
  TransformMode2[TransformMode2["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
  TransformMode2[TransformMode2["NoScale"] = 3] = "NoScale";
  TransformMode2[TransformMode2["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
  return TransformMode2;
})(TransformMode || {});


//# sourceMappingURL=ISkeleton.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/SkeletonBoundsBase.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/SkeletonBoundsBase.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonBoundsBase": function() { return /* binding */ SkeletonBoundsBase; }
/* harmony export */ });
/* harmony import */ var _AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AttachmentType.mjs */ "./node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@pixi-spine/base/lib/core/Utils.mjs");



class SkeletonBoundsBase {
  constructor() {
    /** The left edge of the axis aligned bounding box. */
    this.minX = 0;
    /** The bottom edge of the axis aligned bounding box. */
    this.minY = 0;
    /** The right edge of the axis aligned bounding box. */
    this.maxX = 0;
    /** The top edge of the axis aligned bounding box. */
    this.maxY = 0;
    /** The visible bounding boxes. */
    this.boundingBoxes = new Array();
    /** The world vertices for the bounding box polygons. */
    this.polygons = new Array();
    this.polygonPool = new _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__.Pool(() => _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(16));
  }
  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding
   * box's polygon.
   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the
   *           SkeletonBounds AABB methods will always return true. */
  update(skeleton, updateAabb) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    const boundingBoxes = this.boundingBoxes;
    const polygons = this.polygons;
    const polygonPool = this.polygonPool;
    const slots = skeleton.slots;
    const slotCount = slots.length;
    boundingBoxes.length = 0;
    polygonPool.freeAll(polygons);
    polygons.length = 0;
    for (let i = 0; i < slotCount; i++) {
      const slot = slots[i];
      if (!slot.bone.active)
        continue;
      const attachment = slot.getAttachment();
      if (attachment != null && attachment.type === _AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType.BoundingBox) {
        const boundingBox = attachment;
        boundingBoxes.push(boundingBox);
        let polygon = polygonPool.obtain();
        if (polygon.length != boundingBox.worldVerticesLength) {
          polygon = _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(boundingBox.worldVerticesLength);
        }
        polygons.push(polygon);
        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
      }
    }
    if (updateAabb) {
      this.aabbCompute();
    } else {
      this.minX = Number.POSITIVE_INFINITY;
      this.minY = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.maxY = Number.NEGATIVE_INFINITY;
    }
  }
  aabbCompute() {
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      const polygon = polygons[i];
      const vertices = polygon;
      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {
        const x = vertices[ii];
        const y = vertices[ii + 1];
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /** Returns true if the axis aligned bounding box contains the point. */
  aabbContainsPoint(x, y) {
    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
  }
  /** Returns true if the axis aligned bounding box intersects the line segment. */
  aabbIntersectsSegment(x1, y1, x2, y2) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {
      return false;
    }
    const m = (y2 - y1) / (x2 - x1);
    let y = m * (minX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    y = m * (maxX - x1) + y1;
    if (y > minY && y < maxY)
      return true;
    let x = (minY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    x = (maxY - y1) / m + x1;
    if (x > minX && x < maxX)
      return true;
    return false;
  }
  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */
  aabbIntersectsSkeleton(bounds) {
    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
  }
  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.
   * Cannot be done here because BoundingBoxAttachment is not a thing yet*/
  containsPoint(x, y) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.containsPointPolygon(polygons[i], x, y))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains the point. */
  containsPointPolygon(polygon, x, y) {
    const vertices = polygon;
    const nn = polygon.length;
    let prevIndex = nn - 2;
    let inside = false;
    for (let ii = 0; ii < nn; ii += 2) {
      const vertexY = vertices[ii + 1];
      const prevY = vertices[prevIndex + 1];
      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
        const vertexX = vertices[ii];
        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)
          inside = !inside;
      }
      prevIndex = ii;
    }
    return inside;
  }
  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it
   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns
   * true. */
  intersectsSegment(x1, y1, x2, y2) {
    const polygons = this.polygons;
    for (let i = 0, n = polygons.length; i < n; i++) {
      if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))
        return this.boundingBoxes[i];
    }
    return null;
  }
  /** Returns true if the polygon contains any part of the line segment. */
  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {
    const vertices = polygon;
    const nn = polygon.length;
    const width12 = x1 - x2;
    const height12 = y1 - y2;
    const det1 = x1 * y2 - y1 * x2;
    let x3 = vertices[nn - 2];
    let y3 = vertices[nn - 1];
    for (let ii = 0; ii < nn; ii += 2) {
      const x4 = vertices[ii];
      const y4 = vertices[ii + 1];
      const det2 = x3 * y4 - y3 * x4;
      const width34 = x3 - x4;
      const height34 = y3 - y4;
      const det3 = width12 * height34 - height12 * width34;
      const x = (det1 * width34 - width12 * det2) / det3;
      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
        const y = (det1 * height34 - height12 * det2) / det3;
        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1))
          return true;
      }
      x3 = x4;
      y3 = y4;
    }
    return false;
  }
  /** Returns the polygon for the specified bounding box, or null. */
  getPolygon(boundingBox) {
    if (!boundingBox)
      throw new Error("boundingBox cannot be null.");
    const index = this.boundingBoxes.indexOf(boundingBox);
    return index == -1 ? null : this.polygons[index];
  }
  /** The width of the axis aligned bounding box. */
  getWidth() {
    return this.maxX - this.minX;
  }
  /** The height of the axis aligned bounding box. */
  getHeight() {
    return this.maxY - this.minY;
  }
}


//# sourceMappingURL=SkeletonBoundsBase.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/TextureAtlas.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/TextureAtlas.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureAtlas": function() { return /* binding */ TextureAtlas; },
/* harmony export */   "TextureAtlasPage": function() { return /* binding */ TextureAtlasPage; },
/* harmony export */   "TextureAtlasRegion": function() { return /* binding */ TextureAtlasRegion; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextureRegion.mjs */ "./node_modules/@pixi-spine/base/lib/core/TextureRegion.mjs");



class RegionFields {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.originalWidth = 0;
    this.originalHeight = 0;
    this.rotate = 0;
    this.index = 0;
  }
}
class TextureAtlas {
  constructor(atlasText, textureLoader, callback) {
    this.pages = new Array();
    this.regions = new Array();
    if (atlasText) {
      this.addSpineAtlas(atlasText, textureLoader, callback);
    }
  }
  addTexture(name, texture) {
    const pages = this.pages;
    let page = null;
    for (let i = 0; i < pages.length; i++) {
      if (pages[i].baseTexture === texture.baseTexture) {
        page = pages[i];
        break;
      }
    }
    if (page === null) {
      page = new TextureAtlasPage();
      page.name = "texturePage";
      const baseTexture = texture.baseTexture;
      page.width = baseTexture.realWidth;
      page.height = baseTexture.realHeight;
      page.baseTexture = baseTexture;
      page.minFilter = page.magFilter = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureFilter.Nearest;
      page.uWrap = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureWrap.ClampToEdge;
      page.vWrap = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureWrap.ClampToEdge;
      pages.push(page);
    }
    const region = new TextureAtlasRegion();
    region.name = name;
    region.page = page;
    region.texture = texture;
    region.index = -1;
    this.regions.push(region);
    return region;
  }
  addTextureHash(textures, stripExtension) {
    for (const key in textures) {
      if (textures.hasOwnProperty(key)) {
        this.addTexture(stripExtension && key.indexOf(".") !== -1 ? key.substr(0, key.lastIndexOf(".")) : key, textures[key]);
      }
    }
  }
  addSpineAtlas(atlasText, textureLoader, callback) {
    return this.load(atlasText, textureLoader, callback);
  }
  load(atlasText, textureLoader, callback) {
    if (textureLoader == null) {
      throw new Error("textureLoader cannot be null.");
    }
    const reader = new TextureAtlasReader(atlasText);
    const entry = new Array(4);
    let page = null;
    const pageFields = {};
    let region = null;
    pageFields.size = () => {
      page.width = parseInt(entry[1]);
      page.height = parseInt(entry[2]);
    };
    pageFields.format = () => {
    };
    pageFields.filter = () => {
      page.minFilter = (0,_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.filterFromString)(entry[1]);
      page.magFilter = (0,_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.filterFromString)(entry[2]);
    };
    pageFields.repeat = () => {
      if (entry[1].indexOf("x") != -1)
        page.uWrap = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureWrap.Repeat;
      if (entry[1].indexOf("y") != -1)
        page.vWrap = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureWrap.Repeat;
    };
    pageFields.pma = () => {
      page.pma = entry[1] == "true";
    };
    const regionFields = {};
    regionFields.xy = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
    };
    regionFields.size = () => {
      region.width = parseInt(entry[1]);
      region.height = parseInt(entry[2]);
    };
    regionFields.bounds = () => {
      region.x = parseInt(entry[1]);
      region.y = parseInt(entry[2]);
      region.width = parseInt(entry[3]);
      region.height = parseInt(entry[4]);
    };
    regionFields.offset = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
    };
    regionFields.orig = () => {
      region.originalWidth = parseInt(entry[1]);
      region.originalHeight = parseInt(entry[2]);
    };
    regionFields.offsets = () => {
      region.offsetX = parseInt(entry[1]);
      region.offsetY = parseInt(entry[2]);
      region.originalWidth = parseInt(entry[3]);
      region.originalHeight = parseInt(entry[4]);
    };
    regionFields.rotate = () => {
      const rotateValue = entry[1];
      let rotate = 0;
      if (rotateValue.toLocaleLowerCase() == "true") {
        rotate = 6;
      } else if (rotateValue.toLocaleLowerCase() == "false") {
        rotate = 0;
      } else {
        rotate = (720 - parseFloat(rotateValue)) % 360 / 45;
      }
      region.rotate = rotate;
    };
    regionFields.index = () => {
      region.index = parseInt(entry[1]);
    };
    let line = reader.readLine();
    while (line != null && line.trim().length == 0) {
      line = reader.readLine();
    }
    while (true) {
      if (line == null || line.trim().length == 0)
        break;
      if (reader.readEntry(entry, line) == 0)
        break;
      line = reader.readLine();
    }
    const iterateParser = () => {
      while (true) {
        if (line == null) {
          return callback && callback(this);
        }
        if (line.trim().length == 0) {
          page = null;
          line = reader.readLine();
        } else if (page === null) {
          page = new TextureAtlasPage();
          page.name = line.trim();
          while (true) {
            if (reader.readEntry(entry, line = reader.readLine()) == 0)
              break;
            const field = pageFields[entry[0]];
            if (field)
              field();
          }
          this.pages.push(page);
          textureLoader(page.name, (texture) => {
            if (texture === null) {
              this.pages.splice(this.pages.indexOf(page), 1);
              return callback && callback(null);
            }
            page.baseTexture = texture;
            if (page.pma) {
              texture.alphaMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.PMA;
            }
            if (!texture.valid) {
              texture.setSize(page.width, page.height);
            }
            page.setFilters();
            if (!page.width || !page.height) {
              page.width = texture.realWidth;
              page.height = texture.realHeight;
              if (!page.width || !page.height) {
                console.log(
                  `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`
                );
              }
            }
            iterateParser();
          });
          break;
        } else {
          region = new RegionFields();
          const atlasRegion = new TextureAtlasRegion();
          atlasRegion.name = line;
          atlasRegion.page = page;
          let names = null;
          let values = null;
          while (true) {
            const count = reader.readEntry(entry, line = reader.readLine());
            if (count == 0)
              break;
            const field = regionFields[entry[0]];
            if (field) {
              field();
            } else {
              if (names == null) {
                names = [];
                values = [];
              }
              names.push(entry[0]);
              const entryValues = [];
              for (let i = 0; i < count; i++) {
                entryValues.push(parseInt(entry[i + 1]));
              }
              values.push(entryValues);
            }
          }
          if (region.originalWidth == 0 && region.originalHeight == 0) {
            region.originalWidth = region.width;
            region.originalHeight = region.height;
          }
          const resolution = page.baseTexture.resolution;
          region.x /= resolution;
          region.y /= resolution;
          region.width /= resolution;
          region.height /= resolution;
          region.originalWidth /= resolution;
          region.originalHeight /= resolution;
          region.offsetX /= resolution;
          region.offsetY /= resolution;
          const swapWH = region.rotate % 4 !== 0;
          const frame = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);
          const orig = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, region.originalWidth, region.originalHeight);
          const trim = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);
          atlasRegion.texture = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);
          atlasRegion.index = region.index;
          atlasRegion.texture.updateUvs();
          this.regions.push(atlasRegion);
        }
      }
    };
    iterateParser();
  }
  findRegion(name) {
    for (let i = 0; i < this.regions.length; i++) {
      if (this.regions[i].name == name) {
        return this.regions[i];
      }
    }
    return null;
  }
  dispose() {
    for (let i = 0; i < this.pages.length; i++) {
      this.pages[i].baseTexture.dispose();
    }
  }
}
class TextureAtlasReader {
  constructor(text) {
    this.index = 0;
    this.lines = text.split(/\r\n|\r|\n/);
  }
  readLine() {
    if (this.index >= this.lines.length) {
      return null;
    }
    return this.lines[this.index++];
  }
  readEntry(entry, line) {
    if (line == null)
      return 0;
    line = line.trim();
    if (line.length == 0)
      return 0;
    const colon = line.indexOf(":");
    if (colon == -1)
      return 0;
    entry[0] = line.substr(0, colon).trim();
    for (let i = 1, lastMatch = colon + 1; ; i++) {
      const comma = line.indexOf(",", lastMatch);
      if (comma == -1) {
        entry[i] = line.substr(lastMatch).trim();
        return i;
      }
      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();
      lastMatch = comma + 1;
      if (i == 4)
        return 4;
    }
  }
}
class TextureAtlasPage {
  constructor() {
    this.minFilter = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureFilter.Nearest;
    this.magFilter = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureFilter.Nearest;
    this.uWrap = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureWrap.ClampToEdge;
    this.vWrap = _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureWrap.ClampToEdge;
  }
  setFilters() {
    const tex = this.baseTexture;
    const filter = this.minFilter;
    if (filter == _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureFilter.Linear) {
      tex.scaleMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.LINEAR;
    } else if (this.minFilter == _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureFilter.Nearest) {
      tex.scaleMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.NEAREST;
    } else {
      tex.mipmap = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.MIPMAP_MODES.POW2;
      if (filter == _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureFilter.MipMapNearestNearest) {
        tex.scaleMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.NEAREST;
      } else {
        tex.scaleMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.LINEAR;
      }
    }
  }
}
class TextureAtlasRegion extends _TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureRegion {
}


//# sourceMappingURL=TextureAtlas.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/TextureRegion.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/TextureRegion.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureFilter": function() { return /* binding */ TextureFilter; },
/* harmony export */   "TextureRegion": function() { return /* binding */ TextureRegion; },
/* harmony export */   "TextureWrap": function() { return /* binding */ TextureWrap; },
/* harmony export */   "filterFromString": function() { return /* binding */ filterFromString; },
/* harmony export */   "wrapFromString": function() { return /* binding */ wrapFromString; }
/* harmony export */ });
function filterFromString(text) {
  switch (text.toLowerCase()) {
    case "nearest":
      return TextureFilter.Nearest;
    case "linear":
      return TextureFilter.Linear;
    case "mipmap":
      return TextureFilter.MipMap;
    case "mipmapnearestnearest":
      return TextureFilter.MipMapNearestNearest;
    case "mipmaplinearnearest":
      return TextureFilter.MipMapLinearNearest;
    case "mipmapnearestlinear":
      return TextureFilter.MipMapNearestLinear;
    case "mipmaplinearlinear":
      return TextureFilter.MipMapLinearLinear;
    default:
      throw new Error(`Unknown texture filter ${text}`);
  }
}
function wrapFromString(text) {
  switch (text.toLowerCase()) {
    case "mirroredtepeat":
      return TextureWrap.MirroredRepeat;
    case "clamptoedge":
      return TextureWrap.ClampToEdge;
    case "repeat":
      return TextureWrap.Repeat;
    default:
      throw new Error(`Unknown texture wrap ${text}`);
  }
}
var TextureFilter = /* @__PURE__ */ ((TextureFilter2) => {
  TextureFilter2[TextureFilter2["Nearest"] = 9728] = "Nearest";
  TextureFilter2[TextureFilter2["Linear"] = 9729] = "Linear";
  TextureFilter2[TextureFilter2["MipMap"] = 9987] = "MipMap";
  TextureFilter2[TextureFilter2["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
  TextureFilter2[TextureFilter2["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
  TextureFilter2[TextureFilter2["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
  TextureFilter2[TextureFilter2["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
  return TextureFilter2;
})(TextureFilter || {});
var TextureWrap = /* @__PURE__ */ ((TextureWrap2) => {
  TextureWrap2[TextureWrap2["MirroredRepeat"] = 33648] = "MirroredRepeat";
  TextureWrap2[TextureWrap2["ClampToEdge"] = 33071] = "ClampToEdge";
  TextureWrap2[TextureWrap2["Repeat"] = 10497] = "Repeat";
  return TextureWrap2;
})(TextureWrap || {});
class TextureRegion {
  constructor() {
    // thats for overrides
    this.size = null;
    this.names = null;
    this.values = null;
    this.renderObject = null;
  }
  get width() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.width;
    }
    return tex.orig.width;
  }
  get height() {
    const tex = this.texture;
    if (tex.trim) {
      return tex.trim.height;
    }
    return tex.orig.height;
  }
  get u() {
    return this.texture._uvs.x0;
  }
  get v() {
    return this.texture._uvs.y0;
  }
  get u2() {
    return this.texture._uvs.x2;
  }
  get v2() {
    return this.texture._uvs.y2;
  }
  get offsetX() {
    const tex = this.texture;
    return tex.trim ? tex.trim.x : 0;
  }
  get offsetY() {
    return this.spineOffsetY;
  }
  get pixiOffsetY() {
    const tex = this.texture;
    return tex.trim ? tex.trim.y : 0;
  }
  get spineOffsetY() {
    const tex = this.texture;
    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);
  }
  get originalWidth() {
    return this.texture.orig.width;
  }
  get originalHeight() {
    return this.texture.orig.height;
  }
  get x() {
    return this.texture.frame.x;
  }
  get y() {
    return this.texture.frame.y;
  }
  get rotate() {
    return this.texture.rotate !== 0;
  }
  get degrees() {
    return (360 - this.texture.rotate * 45) % 360;
  }
}


//# sourceMappingURL=TextureRegion.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/core/Utils.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/core/Utils.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": function() { return /* binding */ Color; },
/* harmony export */   "DebugUtils": function() { return /* binding */ DebugUtils; },
/* harmony export */   "IntSet": function() { return /* binding */ IntSet; },
/* harmony export */   "Interpolation": function() { return /* binding */ Interpolation; },
/* harmony export */   "MathUtils": function() { return /* binding */ MathUtils; },
/* harmony export */   "Pool": function() { return /* binding */ Pool; },
/* harmony export */   "Pow": function() { return /* binding */ Pow; },
/* harmony export */   "PowOut": function() { return /* binding */ PowOut; },
/* harmony export */   "StringSet": function() { return /* binding */ StringSet; },
/* harmony export */   "TimeKeeper": function() { return /* binding */ TimeKeeper; },
/* harmony export */   "Utils": function() { return /* binding */ Utils; },
/* harmony export */   "Vector2": function() { return /* binding */ Vector2; },
/* harmony export */   "WindowedMean": function() { return /* binding */ WindowedMean; }
/* harmony export */ });
class IntSet {
  constructor() {
    this.array = new Array();
  }
  add(value) {
    const contains = this.contains(value);
    this.array[value | 0] = value | 0;
    return !contains;
  }
  contains(value) {
    return this.array[value | 0] != void 0;
  }
  remove(value) {
    this.array[value | 0] = void 0;
  }
  clear() {
    this.array.length = 0;
  }
}
class StringSet {
  constructor() {
    this.entries = {};
    this.size = 0;
  }
  add(value) {
    const contains = this.entries[value];
    this.entries[value] = true;
    if (!contains) {
      this.size++;
      return true;
    }
    return false;
  }
  addAll(values) {
    const oldSize = this.size;
    for (let i = 0, n = values.length; i < n; i++) {
      this.add(values[i]);
    }
    return oldSize != this.size;
  }
  contains(value) {
    return this.entries[value];
  }
  clear() {
    this.entries = {};
    this.size = 0;
  }
}
const _Color = class {
  constructor(r = 0, g = 0, b = 0, a = 0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  set(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this.clamp();
  }
  setFromColor(c) {
    this.r = c.r;
    this.g = c.g;
    this.b = c.b;
    this.a = c.a;
    return this;
  }
  setFromString(hex) {
    hex = hex.charAt(0) == "#" ? hex.substr(1) : hex;
    this.r = parseInt(hex.substr(0, 2), 16) / 255;
    this.g = parseInt(hex.substr(2, 2), 16) / 255;
    this.b = parseInt(hex.substr(4, 2), 16) / 255;
    this.a = hex.length != 8 ? 1 : parseInt(hex.substr(6, 2), 16) / 255;
    return this;
  }
  add(r, g, b, a) {
    this.r += r;
    this.g += g;
    this.b += b;
    this.a += a;
    return this.clamp();
  }
  clamp() {
    if (this.r < 0)
      this.r = 0;
    else if (this.r > 1)
      this.r = 1;
    if (this.g < 0)
      this.g = 0;
    else if (this.g > 1)
      this.g = 1;
    if (this.b < 0)
      this.b = 0;
    else if (this.b > 1)
      this.b = 1;
    if (this.a < 0)
      this.a = 0;
    else if (this.a > 1)
      this.a = 1;
    return this;
  }
  static rgba8888ToColor(color, value) {
    color.r = ((value & 4278190080) >>> 24) / 255;
    color.g = ((value & 16711680) >>> 16) / 255;
    color.b = ((value & 65280) >>> 8) / 255;
    color.a = (value & 255) / 255;
  }
  static rgb888ToColor(color, value) {
    color.r = ((value & 16711680) >>> 16) / 255;
    color.g = ((value & 65280) >>> 8) / 255;
    color.b = (value & 255) / 255;
  }
  static fromString(hex) {
    return new _Color().setFromString(hex);
  }
};
let Color = _Color;
Color.WHITE = new _Color(1, 1, 1, 1);
Color.RED = new _Color(1, 0, 0, 1);
Color.GREEN = new _Color(0, 1, 0, 1);
Color.BLUE = new _Color(0, 0, 1, 1);
Color.MAGENTA = new _Color(1, 0, 1, 1);
const _MathUtils = class {
  static clamp(value, min, max) {
    if (value < min)
      return min;
    if (value > max)
      return max;
    return value;
  }
  static cosDeg(degrees) {
    return Math.cos(degrees * _MathUtils.degRad);
  }
  static sinDeg(degrees) {
    return Math.sin(degrees * _MathUtils.degRad);
  }
  static signum(value) {
    return Math.sign(value);
  }
  static toInt(x) {
    return x > 0 ? Math.floor(x) : Math.ceil(x);
  }
  static cbrt(x) {
    const y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  }
  static randomTriangular(min, max) {
    return _MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
  }
  static randomTriangularWith(min, max, mode) {
    const u = Math.random();
    const d = max - min;
    if (u <= (mode - min) / d)
      return min + Math.sqrt(u * d * (mode - min));
    return max - Math.sqrt((1 - u) * d * (max - mode));
  }
  static isPowerOfTwo(value) {
    return value && (value & value - 1) === 0;
  }
};
let MathUtils = _MathUtils;
MathUtils.PI = 3.1415927;
MathUtils.PI2 = _MathUtils.PI * 2;
MathUtils.radiansToDegrees = 180 / _MathUtils.PI;
MathUtils.radDeg = _MathUtils.radiansToDegrees;
MathUtils.degreesToRadians = _MathUtils.PI / 180;
MathUtils.degRad = _MathUtils.degreesToRadians;
class Interpolation {
  apply(start, end, a) {
    return start + (end - start) * this.applyInternal(a);
  }
}
class Pow extends Interpolation {
  constructor(power) {
    super();
    this.power = 2;
    this.power = power;
  }
  applyInternal(a) {
    if (a <= 0.5)
      return Math.pow(a * 2, this.power) / 2;
    return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
  }
}
class PowOut extends Pow {
  applyInternal(a) {
    return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
  }
}
const _Utils = class {
  static arrayCopy(source, sourceStart, dest, destStart, numElements) {
    for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
      dest[j] = source[i];
    }
  }
  static arrayFill(array, fromIndex, toIndex, value) {
    for (let i = fromIndex; i < toIndex; i++) {
      array[i] = value;
    }
  }
  static setArraySize(array, size, value = 0) {
    const oldSize = array.length;
    if (oldSize == size)
      return array;
    array.length = size;
    if (oldSize < size) {
      for (let i = oldSize; i < size; i++)
        array[i] = value;
    }
    return array;
  }
  static ensureArrayCapacity(array, size, value = 0) {
    if (array.length >= size)
      return array;
    return _Utils.setArraySize(array, size, value);
  }
  static newArray(size, defaultValue) {
    const array = new Array(size);
    for (let i = 0; i < size; i++)
      array[i] = defaultValue;
    return array;
  }
  static newFloatArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Float32Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static newShortArray(size) {
    if (_Utils.SUPPORTS_TYPED_ARRAYS) {
      return new Int16Array(size);
    }
    const array = new Array(size);
    for (let i = 0; i < array.length; i++)
      array[i] = 0;
    return array;
  }
  static toFloatArray(array) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
  }
  static toSinglePrecision(value) {
    return _Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
  }
  // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109
  static webkit602BugfixHelper(alpha, blend) {
  }
  static contains(array, element, identity = true) {
    for (let i = 0; i < array.length; i++) {
      if (array[i] == element)
        return true;
    }
    return false;
  }
  static enumValue(type, name) {
    return type[name[0].toUpperCase() + name.slice(1)];
  }
};
let Utils = _Utils;
Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
class DebugUtils {
  static logBones(skeleton) {
    for (let i = 0; i < skeleton.bones.length; i++) {
      const bone = skeleton.bones[i];
      const mat = bone.matrix;
      console.log(`${bone.data.name}, ${mat.a}, ${mat.b}, ${mat.c}, ${mat.d}, ${mat.tx}, ${mat.ty}`);
    }
  }
}
class Pool {
  constructor(instantiator) {
    this.items = new Array();
    this.instantiator = instantiator;
  }
  obtain() {
    return this.items.length > 0 ? this.items.pop() : this.instantiator();
  }
  free(item) {
    if (item.reset)
      item.reset();
    this.items.push(item);
  }
  freeAll(items) {
    for (let i = 0; i < items.length; i++) {
      this.free(items[i]);
    }
  }
  clear() {
    this.items.length = 0;
  }
}
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  length() {
    const x = this.x;
    const y = this.y;
    return Math.sqrt(x * x + y * y);
  }
  normalize() {
    const len = this.length();
    if (len != 0) {
      this.x /= len;
      this.y /= len;
    }
    return this;
  }
}
class TimeKeeper {
  constructor() {
    this.maxDelta = 0.064;
    this.framesPerSecond = 0;
    this.delta = 0;
    this.totalTime = 0;
    this.lastTime = Date.now() / 1e3;
    this.frameCount = 0;
    this.frameTime = 0;
  }
  update() {
    const now = Date.now() / 1e3;
    this.delta = now - this.lastTime;
    this.frameTime += this.delta;
    this.totalTime += this.delta;
    if (this.delta > this.maxDelta)
      this.delta = this.maxDelta;
    this.lastTime = now;
    this.frameCount++;
    if (this.frameTime > 1) {
      this.framesPerSecond = this.frameCount / this.frameTime;
      this.frameTime = 0;
      this.frameCount = 0;
    }
  }
}
class WindowedMean {
  constructor(windowSize = 32) {
    this.addedValues = 0;
    this.lastValue = 0;
    this.mean = 0;
    this.dirty = true;
    this.values = new Array(windowSize);
  }
  hasEnoughData() {
    return this.addedValues >= this.values.length;
  }
  addValue(value) {
    if (this.addedValues < this.values.length)
      this.addedValues++;
    this.values[this.lastValue++] = value;
    if (this.lastValue > this.values.length - 1)
      this.lastValue = 0;
    this.dirty = true;
  }
  getMean() {
    if (this.hasEnoughData()) {
      if (this.dirty) {
        let mean = 0;
        for (let i = 0; i < this.values.length; i++) {
          mean += this.values[i];
        }
        this.mean = mean / this.values.length;
        this.dirty = false;
      }
      return this.mean;
    }
    return 0;
  }
}


//# sourceMappingURL=Utils.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/index.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachmentType": function() { return /* reexport safe */ _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentType; },
/* harmony export */   "BinaryInput": function() { return /* reexport safe */ _core_BinaryInput_mjs__WEBPACK_IMPORTED_MODULE_1__.BinaryInput; },
/* harmony export */   "Color": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.Color; },
/* harmony export */   "DebugUtils": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.DebugUtils; },
/* harmony export */   "IntSet": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.IntSet; },
/* harmony export */   "Interpolation": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.Interpolation; },
/* harmony export */   "MathUtils": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.MathUtils; },
/* harmony export */   "MixBlend": function() { return /* reexport safe */ _core_IAnimation_mjs__WEBPACK_IMPORTED_MODULE_2__.MixBlend; },
/* harmony export */   "MixDirection": function() { return /* reexport safe */ _core_IAnimation_mjs__WEBPACK_IMPORTED_MODULE_2__.MixDirection; },
/* harmony export */   "Pool": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.Pool; },
/* harmony export */   "PositionMode": function() { return /* reexport safe */ _core_IConstraint_mjs__WEBPACK_IMPORTED_MODULE_3__.PositionMode; },
/* harmony export */   "Pow": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.Pow; },
/* harmony export */   "PowOut": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.PowOut; },
/* harmony export */   "RotateMode": function() { return /* reexport safe */ _core_IConstraint_mjs__WEBPACK_IMPORTED_MODULE_3__.RotateMode; },
/* harmony export */   "SkeletonBoundsBase": function() { return /* reexport safe */ _core_SkeletonBoundsBase_mjs__WEBPACK_IMPORTED_MODULE_8__.SkeletonBoundsBase; },
/* harmony export */   "SpineBase": function() { return /* reexport safe */ _SpineBase_mjs__WEBPACK_IMPORTED_MODULE_10__.SpineBase; },
/* harmony export */   "SpineDebugRenderer": function() { return /* reexport safe */ _SpineDebugRenderer_mjs__WEBPACK_IMPORTED_MODULE_11__.SpineDebugRenderer; },
/* harmony export */   "SpineMesh": function() { return /* reexport safe */ _SpineBase_mjs__WEBPACK_IMPORTED_MODULE_10__.SpineMesh; },
/* harmony export */   "SpineSprite": function() { return /* reexport safe */ _SpineBase_mjs__WEBPACK_IMPORTED_MODULE_10__.SpineSprite; },
/* harmony export */   "StringSet": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.StringSet; },
/* harmony export */   "TextureAtlas": function() { return /* reexport safe */ _core_TextureAtlas_mjs__WEBPACK_IMPORTED_MODULE_5__.TextureAtlas; },
/* harmony export */   "TextureAtlasPage": function() { return /* reexport safe */ _core_TextureAtlas_mjs__WEBPACK_IMPORTED_MODULE_5__.TextureAtlasPage; },
/* harmony export */   "TextureAtlasRegion": function() { return /* reexport safe */ _core_TextureAtlas_mjs__WEBPACK_IMPORTED_MODULE_5__.TextureAtlasRegion; },
/* harmony export */   "TextureFilter": function() { return /* reexport safe */ _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_6__.TextureFilter; },
/* harmony export */   "TextureRegion": function() { return /* reexport safe */ _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_6__.TextureRegion; },
/* harmony export */   "TextureWrap": function() { return /* reexport safe */ _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_6__.TextureWrap; },
/* harmony export */   "TimeKeeper": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.TimeKeeper; },
/* harmony export */   "TransformMode": function() { return /* reexport safe */ _core_ISkeleton_mjs__WEBPACK_IMPORTED_MODULE_4__.TransformMode; },
/* harmony export */   "Utils": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.Utils; },
/* harmony export */   "Vector2": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.Vector2; },
/* harmony export */   "WindowedMean": function() { return /* reexport safe */ _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__.WindowedMean; },
/* harmony export */   "filterFromString": function() { return /* reexport safe */ _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_6__.filterFromString; },
/* harmony export */   "settings": function() { return /* reexport safe */ _settings_mjs__WEBPACK_IMPORTED_MODULE_9__.settings; },
/* harmony export */   "wrapFromString": function() { return /* reexport safe */ _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_6__.wrapFromString; }
/* harmony export */ });
/* harmony import */ var _core_AttachmentType_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/AttachmentType.mjs */ "./node_modules/@pixi-spine/base/lib/core/AttachmentType.mjs");
/* harmony import */ var _core_BinaryInput_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/BinaryInput.mjs */ "./node_modules/@pixi-spine/base/lib/core/BinaryInput.mjs");
/* harmony import */ var _core_IAnimation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/IAnimation.mjs */ "./node_modules/@pixi-spine/base/lib/core/IAnimation.mjs");
/* harmony import */ var _core_IConstraint_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/IConstraint.mjs */ "./node_modules/@pixi-spine/base/lib/core/IConstraint.mjs");
/* harmony import */ var _core_ISkeleton_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/ISkeleton.mjs */ "./node_modules/@pixi-spine/base/lib/core/ISkeleton.mjs");
/* harmony import */ var _core_TextureAtlas_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/TextureAtlas.mjs */ "./node_modules/@pixi-spine/base/lib/core/TextureAtlas.mjs");
/* harmony import */ var _core_TextureRegion_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/TextureRegion.mjs */ "./node_modules/@pixi-spine/base/lib/core/TextureRegion.mjs");
/* harmony import */ var _core_Utils_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/Utils.mjs */ "./node_modules/@pixi-spine/base/lib/core/Utils.mjs");
/* harmony import */ var _core_SkeletonBoundsBase_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/SkeletonBoundsBase.mjs */ "./node_modules/@pixi-spine/base/lib/core/SkeletonBoundsBase.mjs");
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi-spine/base/lib/settings.mjs");
/* harmony import */ var _SpineBase_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SpineBase.mjs */ "./node_modules/@pixi-spine/base/lib/SpineBase.mjs");
/* harmony import */ var _SpineDebugRenderer_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./SpineDebugRenderer.mjs */ "./node_modules/@pixi-spine/base/lib/SpineDebugRenderer.mjs");












//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/base/lib/settings.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi-spine/base/lib/settings.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "settings": function() { return /* binding */ settings; }
/* harmony export */ });
const settings = {
  yDown: true,
  /**
   * pixi-spine gives option to not fail at certain parsing errors
   * spine-ts fails here
   */
  FAIL_ON_NON_EXISTING_SKIN: false,
  /**
   * past Spine.globalAutoUpdate
   */
  GLOBAL_AUTO_UPDATE: true,
  /**
   * past Spine.globalDelayLimit
   */
  GLOBAL_DELAY_LIMIT: 0
};


//# sourceMappingURL=settings.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/loader-base/lib/SpineLoaderAbstract.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/loader-base/lib/SpineLoaderAbstract.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpineLoaderAbstract": function() { return /* binding */ SpineLoaderAbstract; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _atlasLoader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./atlasLoader.mjs */ "./node_modules/@pixi-spine/loader-base/lib/atlasLoader.mjs");





function isJson(resource) {
  return resource.hasOwnProperty("bones");
}
function isBuffer(resource) {
  return resource instanceof ArrayBuffer;
}
class SpineLoaderAbstract {
  constructor() {
  }
  installLoader() {
    const spineAdapter = this;
    const spineLoaderExtension = {
      extension: _pixi_core__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.Asset,
      loader: {
        extension: {
          type: _pixi_core__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.LoadParser,
          priority: _pixi_assets__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.Normal
        },
        // #region Downloading skel buffer data
        test(url) {
          return (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_1__.checkExtension)(url, ".skel");
        },
        async load(url) {
          const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_2__.settings.ADAPTER.fetch(url);
          const buffer = await response.arrayBuffer();
          return buffer;
        },
        // #endregion
        // #region Parsing spine data
        testParse(asset, options) {
          const isJsonSpineModel = (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_1__.checkExtension)(options.src, ".json") && isJson(asset);
          const isBinarySpineModel = (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_1__.checkExtension)(options.src, ".skel") && isBuffer(asset);
          const isMetadataAngry = options.data?.spineAtlas === false;
          return Promise.resolve(isJsonSpineModel && !isMetadataAngry || isBinarySpineModel);
        },
        async parse(asset, loadAsset, loader) {
          const fileExt = _pixi_core__WEBPACK_IMPORTED_MODULE_2__.utils.path.extname(loadAsset.src).toLowerCase();
          const fileName = _pixi_core__WEBPACK_IMPORTED_MODULE_2__.utils.path.basename(loadAsset.src, fileExt);
          let basePath = _pixi_core__WEBPACK_IMPORTED_MODULE_2__.utils.path.dirname(loadAsset.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          const isJsonSpineModel = (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_1__.checkExtension)(loadAsset.src, ".json") && isJson(asset);
          let parser = null;
          let dataToParse = asset;
          if (isJsonSpineModel) {
            parser = spineAdapter.createJsonParser();
          } else {
            parser = spineAdapter.createBinaryParser();
            dataToParse = new Uint8Array(asset);
          }
          const metadata = loadAsset.data || {};
          const metadataSkeletonScale = metadata?.spineSkeletonScale ?? null;
          if (metadataSkeletonScale) {
            parser.scale = metadataSkeletonScale;
          }
          const metadataAtlas = metadata.spineAtlas;
          if (metadataAtlas && metadataAtlas.pages) {
            return spineAdapter.parseData(parser, metadataAtlas, dataToParse);
          }
          const textAtlas = metadata.atlasRawData;
          if (textAtlas) {
            let auxResolve = null;
            let auxReject = null;
            const atlasPromise = new Promise((resolve, reject) => {
              auxResolve = resolve;
              auxReject = reject;
            });
            const atlas = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TextureAtlas(textAtlas, (0,_atlasLoader_mjs__WEBPACK_IMPORTED_MODULE_3__.makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject)(loader, basePath, metadata.imageMetadata), (newAtlas) => {
              if (!newAtlas) {
                auxReject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
              }
              auxResolve(atlas);
            });
            const textureAtlas2 = await atlasPromise;
            return spineAdapter.parseData(parser, textureAtlas2, dataToParse);
          }
          let atlasPath = metadata.spineAtlasFile;
          if (!atlasPath) {
            atlasPath = `${basePath + fileName}.atlas`;
          }
          const textureAtlas = await loader.load({ src: atlasPath, data: metadata, alias: metadata.spineAtlasAlias });
          return spineAdapter.parseData(parser, textureAtlas, dataToParse);
        }
        // #endregion
        // unload(asset: ISpineResource<SKD>, loadAsset, loader) {
        // 	???
        // },
      }
    };
    _pixi_core__WEBPACK_IMPORTED_MODULE_2__.extensions.add(spineLoaderExtension);
    return spineLoaderExtension;
  }
}


//# sourceMappingURL=SpineLoaderAbstract.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/loader-base/lib/atlasLoader.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi-spine/loader-base/lib/atlasLoader.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject": function() { return /* binding */ makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_assets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");




const spineTextureAtlasLoader = {
  extension: _pixi_core__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.Asset,
  // cache: {
  //     test: (asset: RawAtlas | TextureAtlas) => asset instanceof TextureAtlas,
  //     getCacheableAssets: (keys: string[], asset: RawAtlas | TextureAtlas) => getCacheableAssets(keys, asset),
  // },
  loader: {
    extension: {
      type: _pixi_core__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.LoadParser,
      priority: _pixi_assets__WEBPACK_IMPORTED_MODULE_1__.LoaderParserPriority.Normal
    },
    test(url) {
      return (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_1__.checkExtension)(url, ".atlas");
    },
    async load(url) {
      const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_2__.settings.ADAPTER.fetch(url);
      const txt = await response.text();
      return txt;
    },
    testParse(asset, options) {
      const isExtensionRight = (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_1__.checkExtension)(options.src, ".atlas");
      const isString = typeof asset === "string";
      return Promise.resolve(isExtensionRight && isString);
    },
    async parse(asset, options, loader) {
      const metadata = options.data;
      let basePath = _pixi_core__WEBPACK_IMPORTED_MODULE_2__.utils.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let resolve = null;
      let reject = null;
      const retPromise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      let retval;
      const resolveCallback = (newAtlas) => {
        if (!newAtlas) {
          reject("Something went terribly wrong loading a spine .atlas file\nMost likely your texture failed to load.");
        }
        resolve(retval);
      };
      if (metadata.image || metadata.images) {
        const pages = Object.assign(metadata.image ? { default: metadata.image } : {}, metadata.images);
        retval = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TextureAtlas(
          asset,
          (line, callback) => {
            const page = pages[line] || pages.default;
            if (page && page.baseTexture)
              callback(page.baseTexture);
            else
              callback(page);
          },
          resolveCallback
        );
      } else {
        retval = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TextureAtlas(asset, makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject(loader, basePath, metadata.imageMetadata), resolveCallback);
      }
      return await retPromise;
    },
    unload(atlas) {
      atlas.dispose();
    }
  }
};
const makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject = (loader, atlasBasePath, imageMetadata) => {
  return async (pageName, textureLoadedCallback) => {
    const url = _pixi_core__WEBPACK_IMPORTED_MODULE_2__.utils.path.normalize([...atlasBasePath.split(_pixi_core__WEBPACK_IMPORTED_MODULE_2__.utils.path.sep), pageName].join(_pixi_core__WEBPACK_IMPORTED_MODULE_2__.utils.path.sep));
    const texture = await loader.load({ src: url, data: imageMetadata });
    textureLoadedCallback(texture.baseTexture);
  };
};
_pixi_core__WEBPACK_IMPORTED_MODULE_2__.extensions.add(spineTextureAtlasLoader);


//# sourceMappingURL=atlasLoader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/loader-base/lib/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi-spine/loader-base/lib/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpineLoaderAbstract": function() { return /* reexport safe */ _SpineLoaderAbstract_mjs__WEBPACK_IMPORTED_MODULE_1__.SpineLoaderAbstract; },
/* harmony export */   "makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject": function() { return /* reexport safe */ _atlasLoader_mjs__WEBPACK_IMPORTED_MODULE_0__.makeSpineTextureAtlasLoaderFunctionFromPixiLoaderObject; }
/* harmony export */ });
/* harmony import */ var _atlasLoader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./atlasLoader.mjs */ "./node_modules/@pixi-spine/loader-base/lib/atlasLoader.mjs");
/* harmony import */ var _SpineLoaderAbstract_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpineLoaderAbstract.mjs */ "./node_modules/@pixi-spine/loader-base/lib/SpineLoaderAbstract.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/loader-uni/lib/Spine.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi-spine/loader-uni/lib/Spine.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spine": function() { return /* binding */ Spine; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_spine_runtime_3_8__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/runtime-3.8 */ "./node_modules/@pixi-spine/runtime-3.8/lib/index.mjs");
/* harmony import */ var _pixi_spine_runtime_3_7__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi-spine/runtime-3.7 */ "./node_modules/@pixi-spine/runtime-3.7/lib/index.mjs");
/* harmony import */ var _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi-spine/runtime-4.1 */ "./node_modules/@pixi-spine/runtime-4.1/lib/index.mjs");
/* harmony import */ var _versions_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./versions.mjs */ "./node_modules/@pixi-spine/loader-uni/lib/versions.mjs");






class Spine extends _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.SpineBase {
  createSkeleton(spineData) {
    const ver = (0,_versions_mjs__WEBPACK_IMPORTED_MODULE_4__.detectSpineVersion)(spineData.version);
    let spine = null;
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_4__.SPINE_VERSION.VER37) {
      spine = _pixi_spine_runtime_3_7__WEBPACK_IMPORTED_MODULE_2__;
    }
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_4__.SPINE_VERSION.VER38) {
      spine = _pixi_spine_runtime_3_8__WEBPACK_IMPORTED_MODULE_1__;
    }
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_4__.SPINE_VERSION.VER40 || ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_4__.SPINE_VERSION.VER41) {
      spine = _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_3__;
    }
    if (!spine) {
      const error = `Cant detect version of spine model ${spineData.version}`;
      console.error(error);
    }
    this.skeleton = new spine.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new spine.AnimationStateData(spineData);
    this.state = new spine.AnimationState(this.stateData);
  }
}


//# sourceMappingURL=Spine.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/loader-uni/lib/SpineLoader.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi-spine/loader-uni/lib/SpineLoader.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpineLoader": function() { return /* binding */ SpineLoader; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_loader_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/loader-base */ "./node_modules/@pixi-spine/loader-base/lib/index.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_spine_runtime_3_8__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi-spine/runtime-3.8 */ "./node_modules/@pixi-spine/runtime-3.8/lib/index.mjs");
/* harmony import */ var _pixi_spine_runtime_3_7__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi-spine/runtime-3.7 */ "./node_modules/@pixi-spine/runtime-3.7/lib/index.mjs");
/* harmony import */ var _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi-spine/runtime-4.1 */ "./node_modules/@pixi-spine/runtime-4.1/lib/index.mjs");
/* harmony import */ var _versions_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./versions.mjs */ "./node_modules/@pixi-spine/loader-uni/lib/versions.mjs");







class UniBinaryParser {
  constructor() {
    this.scale = 1;
  }
  readSkeletonData(atlas, dataToParse) {
    let parser = null;
    let version = this.readVersionOldFormat(dataToParse);
    let ver = (0,_versions_mjs__WEBPACK_IMPORTED_MODULE_5__.detectSpineVersion)(version);
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_5__.SPINE_VERSION.VER38) {
      parser = new _pixi_spine_runtime_3_8__WEBPACK_IMPORTED_MODULE_2__.SkeletonBinary(new _pixi_spine_runtime_3_8__WEBPACK_IMPORTED_MODULE_2__.AtlasAttachmentLoader(atlas));
    }
    version = this.readVersionNewFormat(dataToParse);
    ver = (0,_versions_mjs__WEBPACK_IMPORTED_MODULE_5__.detectSpineVersion)(version);
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_5__.SPINE_VERSION.VER40 || ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_5__.SPINE_VERSION.VER41) {
      parser = new _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_4__.SkeletonBinary(new _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_4__.AtlasAttachmentLoader(atlas));
    }
    if (!parser) {
      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;
      console.error(error);
    }
    parser.scale = this.scale;
    return parser.readSkeletonData(dataToParse);
  }
  readVersionOldFormat(dataToParse) {
    const input = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.BinaryInput(dataToParse);
    let version;
    try {
      input.readString();
      version = input.readString();
    } catch (e) {
      version = "";
    }
    return version || "";
  }
  readVersionNewFormat(dataToParse) {
    const input = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.BinaryInput(dataToParse);
    input.readInt32();
    input.readInt32();
    let version;
    try {
      version = input.readString();
    } catch (e) {
      version = "";
    }
    return version || "";
  }
}
class UniJsonParser {
  constructor() {
    this.scale = 1;
  }
  readSkeletonData(atlas, dataToParse) {
    const version = dataToParse.skeleton.spine;
    const ver = (0,_versions_mjs__WEBPACK_IMPORTED_MODULE_5__.detectSpineVersion)(version);
    let parser = null;
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_5__.SPINE_VERSION.VER37) {
      parser = new _pixi_spine_runtime_3_7__WEBPACK_IMPORTED_MODULE_3__.SkeletonJson(new _pixi_spine_runtime_3_7__WEBPACK_IMPORTED_MODULE_3__.AtlasAttachmentLoader(atlas));
    }
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_5__.SPINE_VERSION.VER38) {
      parser = new _pixi_spine_runtime_3_8__WEBPACK_IMPORTED_MODULE_2__.SkeletonJson(new _pixi_spine_runtime_3_8__WEBPACK_IMPORTED_MODULE_2__.AtlasAttachmentLoader(atlas));
    }
    if (ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_5__.SPINE_VERSION.VER40 || ver === _versions_mjs__WEBPACK_IMPORTED_MODULE_5__.SPINE_VERSION.VER41) {
      parser = new _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_4__.SkeletonJson(new _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_4__.AtlasAttachmentLoader(atlas));
    }
    if (!parser) {
      const error = `Unsupported version of spine model ${version}, please update pixi-spine`;
      console.error(error);
    }
    parser.scale = this.scale;
    return parser.readSkeletonData(dataToParse);
  }
}
class SpineLoader extends _pixi_spine_loader_base__WEBPACK_IMPORTED_MODULE_0__.SpineLoaderAbstract {
  createBinaryParser() {
    return new UniBinaryParser();
  }
  createJsonParser() {
    return new UniJsonParser();
  }
  parseData(parser, atlas, dataToParse) {
    const parserCast = parser;
    return {
      spineData: parserCast.readSkeletonData(atlas, dataToParse),
      spineAtlas: atlas
    };
  }
}


//# sourceMappingURL=SpineLoader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/loader-uni/lib/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi-spine/loader-uni/lib/index.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SPINE_VERSION": function() { return /* reexport safe */ _versions_mjs__WEBPACK_IMPORTED_MODULE_3__.SPINE_VERSION; },
/* harmony export */   "Spine": function() { return /* reexport safe */ _Spine_mjs__WEBPACK_IMPORTED_MODULE_2__.Spine; },
/* harmony export */   "detectSpineVersion": function() { return /* reexport safe */ _versions_mjs__WEBPACK_IMPORTED_MODULE_3__.detectSpineVersion; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_loader_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/loader-base */ "./node_modules/@pixi-spine/loader-base/lib/index.mjs");
/* harmony import */ var _SpineLoader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpineLoader.mjs */ "./node_modules/@pixi-spine/loader-uni/lib/SpineLoader.mjs");
/* harmony import */ var _Spine_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Spine.mjs */ "./node_modules/@pixi-spine/loader-uni/lib/Spine.mjs");
/* harmony import */ var _versions_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./versions.mjs */ "./node_modules/@pixi-spine/loader-uni/lib/versions.mjs");





new _SpineLoader_mjs__WEBPACK_IMPORTED_MODULE_1__.SpineLoader().installLoader();
//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/loader-uni/lib/versions.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi-spine/loader-uni/lib/versions.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SPINE_VERSION": function() { return /* binding */ SPINE_VERSION; },
/* harmony export */   "detectSpineVersion": function() { return /* binding */ detectSpineVersion; }
/* harmony export */ });
var SPINE_VERSION = /* @__PURE__ */ ((SPINE_VERSION2) => {
  SPINE_VERSION2[SPINE_VERSION2["UNKNOWN"] = 0] = "UNKNOWN";
  SPINE_VERSION2[SPINE_VERSION2["VER37"] = 37] = "VER37";
  SPINE_VERSION2[SPINE_VERSION2["VER38"] = 38] = "VER38";
  SPINE_VERSION2[SPINE_VERSION2["VER40"] = 40] = "VER40";
  SPINE_VERSION2[SPINE_VERSION2["VER41"] = 41] = "VER41";
  return SPINE_VERSION2;
})(SPINE_VERSION || {});
function detectSpineVersion(version) {
  const ver3 = version.substr(0, 3);
  const verNum = Math.floor(Number(ver3) * 10 + 1e-3);
  if (ver3 === "3.7") {
    return 37 /* VER37 */;
  }
  if (ver3 === "3.8") {
    return 38 /* VER38 */;
  }
  if (ver3 === "4.0") {
    return 40 /* VER40 */;
  }
  if (ver3 === "4.1") {
    return 41 /* VER41 */;
  }
  if (verNum < 37 /* VER37 */) {
    return 37 /* VER37 */;
  }
  return 0 /* UNKNOWN */;
}


//# sourceMappingURL=versions.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/Spine.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/Spine.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spine": function() { return /* binding */ Spine; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/Skeleton.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Skeleton.mjs");
/* harmony import */ var _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/AnimationState.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationState.mjs");
/* harmony import */ var _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/AnimationStateData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationStateData.mjs");





class Spine extends _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_1__.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_3__.AnimationStateData(spineData);
    this.state = new _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_2__.AnimationState(this.stateData);
  }
}


//# sourceMappingURL=Spine.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Animation.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/Animation.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": function() { return /* binding */ Animation; },
/* harmony export */   "AttachmentTimeline": function() { return /* binding */ AttachmentTimeline; },
/* harmony export */   "ColorTimeline": function() { return /* binding */ ColorTimeline; },
/* harmony export */   "CurveTimeline": function() { return /* binding */ CurveTimeline; },
/* harmony export */   "DeformTimeline": function() { return /* binding */ DeformTimeline; },
/* harmony export */   "DrawOrderTimeline": function() { return /* binding */ DrawOrderTimeline; },
/* harmony export */   "EventTimeline": function() { return /* binding */ EventTimeline; },
/* harmony export */   "IkConstraintTimeline": function() { return /* binding */ IkConstraintTimeline; },
/* harmony export */   "PathConstraintMixTimeline": function() { return /* binding */ PathConstraintMixTimeline; },
/* harmony export */   "PathConstraintPositionTimeline": function() { return /* binding */ PathConstraintPositionTimeline; },
/* harmony export */   "PathConstraintSpacingTimeline": function() { return /* binding */ PathConstraintSpacingTimeline; },
/* harmony export */   "RotateTimeline": function() { return /* binding */ RotateTimeline; },
/* harmony export */   "ScaleTimeline": function() { return /* binding */ ScaleTimeline; },
/* harmony export */   "ShearTimeline": function() { return /* binding */ ShearTimeline; },
/* harmony export */   "TimelineType": function() { return /* binding */ TimelineType; },
/* harmony export */   "TransformConstraintTimeline": function() { return /* binding */ TransformConstraintTimeline; },
/* harmony export */   "TranslateTimeline": function() { return /* binding */ TranslateTimeline; },
/* harmony export */   "TwoColorTimeline": function() { return /* binding */ TwoColorTimeline; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs");




class Animation {
  constructor(name, timelines, duration) {
    if (name == null)
      throw new Error("name cannot be null.");
    if (timelines == null)
      throw new Error("timelines cannot be null.");
    this.name = name;
    this.timelines = timelines;
    this.duration = duration;
  }
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
  static binarySearch(values, target, step = 1) {
    let low = 0;
    let high = values.length / step - 2;
    if (high == 0)
      return step;
    let current = high >>> 1;
    while (true) {
      if (values[(current + 1) * step] <= target)
        low = current + 1;
      else
        high = current;
      if (low == high)
        return (low + 1) * step;
      current = low + high >>> 1;
    }
  }
  static linearSearch(values, target, step) {
    for (let i = 0, last = values.length - step; i <= last; i += step)
      if (values[i] > target)
        return i;
    return -1;
  }
}
var TimelineType = /* @__PURE__ */ ((TimelineType2) => {
  TimelineType2[TimelineType2["rotate"] = 0] = "rotate";
  TimelineType2[TimelineType2["translate"] = 1] = "translate";
  TimelineType2[TimelineType2["scale"] = 2] = "scale";
  TimelineType2[TimelineType2["shear"] = 3] = "shear";
  TimelineType2[TimelineType2["attachment"] = 4] = "attachment";
  TimelineType2[TimelineType2["color"] = 5] = "color";
  TimelineType2[TimelineType2["deform"] = 6] = "deform";
  TimelineType2[TimelineType2["event"] = 7] = "event";
  TimelineType2[TimelineType2["drawOrder"] = 8] = "drawOrder";
  TimelineType2[TimelineType2["ikConstraint"] = 9] = "ikConstraint";
  TimelineType2[TimelineType2["transformConstraint"] = 10] = "transformConstraint";
  TimelineType2[TimelineType2["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType2[TimelineType2["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType2[TimelineType2["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType2[TimelineType2["twoColor"] = 14] = "twoColor";
  return TimelineType2;
})(TimelineType || {});
const _CurveTimeline = class {
  constructor(frameCount) {
    if (frameCount <= 0)
      throw new Error(`frameCount must be > 0: ${frameCount}`);
    this.curves = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);
  }
  getFrameCount() {
    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;
  }
  setLinear(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;
  }
  setStepped(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;
  }
  getCurveType(frameIndex) {
    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;
    if (index == this.curves.length)
      return _CurveTimeline.LINEAR;
    const type = this.curves[index];
    if (type == _CurveTimeline.LINEAR)
      return _CurveTimeline.LINEAR;
    if (type == _CurveTimeline.STEPPED)
      return _CurveTimeline.STEPPED;
    return _CurveTimeline.BEZIER;
  }
  /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
   * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
   * the difference between the keyframe's values. */
  setCurve(frameIndex, cx1, cy1, cx2, cy2) {
    const tmpx = (-cx1 * 2 + cx2) * 0.03;
    const tmpy = (-cy1 * 2 + cy2) * 0.03;
    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;
    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
    let ddfx = tmpx * 2 + dddfx;
    let ddfy = tmpy * 2 + dddfy;
    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;
    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const curves = this.curves;
    curves[i++] = _CurveTimeline.BEZIER;
    let x = dfx;
    let y = dfy;
    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      x += dfx;
      y += dfy;
    }
  }
  getCurvePercent(frameIndex, percent) {
    percent = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.clamp(percent, 0, 1);
    const curves = this.curves;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const type = curves[i];
    if (type == _CurveTimeline.LINEAR)
      return percent;
    if (type == _CurveTimeline.STEPPED)
      return 0;
    i++;
    let x = 0;
    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      x = curves[i];
      if (x >= percent) {
        let prevX;
        let prevY;
        if (i == start) {
          prevX = 0;
          prevY = 0;
        } else {
          prevX = curves[i - 2];
          prevY = curves[i - 1];
        }
        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
      }
    }
    const y = curves[i - 1];
    return y + (1 - y) * (percent - x) / (1 - x);
  }
};
let CurveTimeline = _CurveTimeline;
CurveTimeline.LINEAR = 0;
CurveTimeline.STEPPED = 1;
CurveTimeline.BEZIER = 2;
CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
const _RotateTimeline = class extends CurveTimeline {
  // time, degrees, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount << 1);
  }
  getPropertyId() {
    return (0 /* rotate */ << 24) + this.boneIndex;
  }
  /** Sets the time and angle of the specified keyframe. */
  setFrame(frameIndex, time, degrees) {
    frameIndex <<= 1;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          const r2 = bone.data.rotation - bone.rotation;
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;
      }
      return;
    }
    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {
      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.rotation = bone.data.rotation + r2 * alpha;
          break;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
          bone.rotation += r2 * alpha;
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);
    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));
    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;
    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
    }
  }
};
let RotateTimeline = _RotateTimeline;
RotateTimeline.ENTRIES = 2;
RotateTimeline.PREV_TIME = -2;
RotateTimeline.PREV_ROTATION = -1;
RotateTimeline.ROTATION = 1;
const _TranslateTimeline = class extends CurveTimeline {
  // time, x, y, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);
  }
  getPropertyId() {
    return (1 /* translate */ << 24) + this.boneIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, x, y) {
    frameIndex *= _TranslateTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TranslateTimeline.X] = x;
    this.frames[frameIndex + _TranslateTimeline.Y] = y;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {
      x = frames[frames.length + _TranslateTimeline.PREV_X];
      y = frames[frames.length + _TranslateTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);
      x = frames[frame + _TranslateTimeline.PREV_X];
      y = frames[frame + _TranslateTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));
      x += (frames[frame + _TranslateTimeline.X] - x) * percent;
      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
};
let TranslateTimeline = _TranslateTimeline;
TranslateTimeline.ENTRIES = 3;
TranslateTimeline.PREV_TIME = -3;
TranslateTimeline.PREV_X = -2;
TranslateTimeline.PREV_Y = -1;
TranslateTimeline.X = 1;
TranslateTimeline.Y = 2;
class ScaleTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (2 /* scale */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
      x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
      y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
    } else {
      const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
      x = frames[frame + ScaleTimeline.PREV_X];
      y = frames[frame + ScaleTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
      x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
      y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
    }
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bone.data.scaleX) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bx = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
        }
      }
    }
  }
}
class ShearTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (3 /* shear */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
      x = frames[frames.length + ShearTimeline.PREV_X];
      y = frames[frames.length + ShearTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
      x = frames[frame + ShearTimeline.PREV_X];
      y = frames[frame + ShearTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
      x = x + (frames[frame + ShearTimeline.X] - x) * percent;
      y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
}
const _ColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (5 /* color */ << 24) + this.slotIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, r, g, b, a) {
    frameIndex *= _ColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _ColorTimeline.R] = r;
    this.frames[frameIndex + _ColorTimeline.G] = g;
    this.frames[frameIndex + _ColorTimeline.B] = b;
    this.frames[frameIndex + _ColorTimeline.A] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          const color = slot.color;
          const setup = slot.data.color;
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _ColorTimeline.PREV_R];
      g = frames[i + _ColorTimeline.PREV_G];
      b = frames[i + _ColorTimeline.PREV_B];
      a = frames[i + _ColorTimeline.PREV_A];
    } else {
      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);
      r = frames[frame + _ColorTimeline.PREV_R];
      g = frames[frame + _ColorTimeline.PREV_G];
      b = frames[frame + _ColorTimeline.PREV_B];
      a = frames[frame + _ColorTimeline.PREV_A];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _ColorTimeline.R] - r) * percent;
      g += (frames[frame + _ColorTimeline.G] - g) * percent;
      b += (frames[frame + _ColorTimeline.B] - b) * percent;
      a += (frames[frame + _ColorTimeline.A] - a) * percent;
    }
    if (alpha == 1)
      slot.color.set(r, g, b, a);
    else {
      const color = slot.color;
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
};
let ColorTimeline = _ColorTimeline;
ColorTimeline.ENTRIES = 5;
ColorTimeline.PREV_TIME = -5;
ColorTimeline.PREV_R = -4;
ColorTimeline.PREV_G = -3;
ColorTimeline.PREV_B = -2;
ColorTimeline.PREV_A = -1;
ColorTimeline.R = 1;
ColorTimeline.G = 2;
ColorTimeline.B = 3;
ColorTimeline.A = 4;
const _TwoColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, r2, g2, b2, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (14 /* twoColor */ << 24) + this.slotIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {
    frameIndex *= _TwoColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TwoColorTimeline.R] = r;
    this.frames[frameIndex + _TwoColorTimeline.G] = g;
    this.frames[frameIndex + _TwoColorTimeline.B] = b;
    this.frames[frameIndex + _TwoColorTimeline.A] = a;
    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;
    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;
    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          slot.darkColor.setFromColor(slot.data.darkColor);
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          const light = slot.color;
          const dark = slot.darkColor;
          const setupLight = slot.data.color;
          const setupDark = slot.data.darkColor;
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _TwoColorTimeline.PREV_R];
      g = frames[i + _TwoColorTimeline.PREV_G];
      b = frames[i + _TwoColorTimeline.PREV_B];
      a = frames[i + _TwoColorTimeline.PREV_A];
      r2 = frames[i + _TwoColorTimeline.PREV_R2];
      g2 = frames[i + _TwoColorTimeline.PREV_G2];
      b2 = frames[i + _TwoColorTimeline.PREV_B2];
    } else {
      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);
      r = frames[frame + _TwoColorTimeline.PREV_R];
      g = frames[frame + _TwoColorTimeline.PREV_G];
      b = frames[frame + _TwoColorTimeline.PREV_B];
      a = frames[frame + _TwoColorTimeline.PREV_A];
      r2 = frames[frame + _TwoColorTimeline.PREV_R2];
      g2 = frames[frame + _TwoColorTimeline.PREV_G2];
      b2 = frames[frame + _TwoColorTimeline.PREV_B2];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;
      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;
      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;
      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;
      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;
      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;
      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;
    }
    if (alpha == 1) {
      slot.color.set(r, g, b, a);
      slot.darkColor.set(r2, g2, b2, 1);
    } else {
      const light = slot.color;
      const dark = slot.darkColor;
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
        light.setFromColor(slot.data.color);
        dark.setFromColor(slot.data.darkColor);
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
    }
  }
};
let TwoColorTimeline = _TwoColorTimeline;
TwoColorTimeline.ENTRIES = 8;
TwoColorTimeline.PREV_TIME = -8;
TwoColorTimeline.PREV_R = -7;
TwoColorTimeline.PREV_G = -6;
TwoColorTimeline.PREV_B = -5;
TwoColorTimeline.PREV_A = -4;
TwoColorTimeline.PREV_R2 = -3;
TwoColorTimeline.PREV_G2 = -2;
TwoColorTimeline.PREV_B2 = -1;
TwoColorTimeline.R = 1;
TwoColorTimeline.G = 2;
TwoColorTimeline.B = 3;
TwoColorTimeline.A = 4;
TwoColorTimeline.R2 = 5;
TwoColorTimeline.G2 = 6;
TwoColorTimeline.B2 = 7;
class AttachmentTimeline {
  constructor(frameCount) {
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.attachmentNames = new Array(frameCount);
  }
  getPropertyId() {
    return (4 /* attachment */ << 24) + this.slotIndex;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, attachmentName) {
    this.frames[frameIndex] = time;
    this.attachmentNames[frameIndex] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut && blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      const attachmentName2 = slot.data.attachmentName;
      slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first) {
        const attachmentName2 = slot.data.attachmentName;
        slot.setAttachment(attachmentName2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName2));
      }
      return;
    }
    let frameIndex = 0;
    if (time >= frames[frames.length - 1])
      frameIndex = frames.length - 1;
    else
      frameIndex = Animation.binarySearch(frames, time, 1) - 1;
    const attachmentName = this.attachmentNames[frameIndex];
    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
}
let zeros = null;
class DeformTimeline extends CurveTimeline {
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.frameVertices = new Array(frameCount);
    if (zeros == null)
      zeros = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(64);
  }
  getPropertyId() {
    return (6 /* deform */ << 27) + Number(this.attachment.id) + this.slotIndex;
  }
  /** Sets the time of the specified keyframe. */
  setFrame(frameIndex, time, vertices) {
    this.frames[frameIndex] = time;
    this.frameVertices[frameIndex] = vertices;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    const slotAttachment = slot.getAttachment();
    if (!(slotAttachment instanceof _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))
      return;
    const verticesArray = slot.attachmentVertices;
    if (verticesArray.length == 0)
      blend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup;
    const frameVertices = this.frameVertices;
    const vertexCount = frameVertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      const vertexAttachment = slotAttachment;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          verticesArray.length = 0;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          if (alpha == 1) {
            verticesArray.length = 0;
            break;
          }
          const vertices2 = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(verticesArray, vertexCount);
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              vertices2[i] += (setupVertices[i] - vertices2[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              vertices2[i] *= alpha;
          }
      }
      return;
    }
    const vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(verticesArray, vertexCount);
    if (time >= frames[frames.length - 1]) {
      const lastVertices = frameVertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              vertices[i] += lastVertices[i] - setupVertices[i];
            }
          } else {
            for (let i = 0; i < vertexCount; i++)
              vertices[i] += lastVertices[i];
          }
        } else {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
        }
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (vertexAttachment2.bones == null) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                vertices[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                vertices[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++) {
                vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                vertices[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time);
    const prevVertices = frameVertices[frame - 1];
    const nextVertices = frameVertices[frame];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (vertexAttachment.bones == null) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          vertices[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (vertexAttachment2.bones == null) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
          }
          break;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
}
class EventTimeline {
  constructor(frameCount) {
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.events = new Array(frameCount);
  }
  getPropertyId() {
    return 7 /* event */ << 24;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time of the specified keyframe. */
  setFrame(frameIndex, event) {
    this.frames[frameIndex] = event.time;
    this.events[frameIndex] = event;
  }
  /** Fires events for frames > lastTime and <= time. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (firedEvents == null)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let frame = 0;
    if (lastTime < frames[0])
      frame = 0;
    else {
      frame = Animation.binarySearch(frames, lastTime);
      const frameTime = frames[frame];
      while (frame > 0) {
        if (frames[frame - 1] != frameTime)
          break;
        frame--;
      }
    }
    for (; frame < frameCount && time >= frames[frame]; frame++)
      firedEvents.push(this.events[frame]);
  }
}
class DrawOrderTimeline {
  constructor(frameCount) {
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.drawOrders = new Array(frameCount);
  }
  getPropertyId() {
    return 8 /* drawOrder */ << 24;
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time of the specified keyframe.
   * @param drawOrder May be null to use bind pose draw order. */
  setFrame(frameIndex, time, drawOrder) {
    this.frames[frameIndex] = time;
    this.drawOrders[frameIndex] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const drawOrder = skeleton.drawOrder;
    const slots = skeleton.slots;
    if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut && blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    let frame = 0;
    if (time >= frames[frames.length - 1])
      frame = frames.length - 1;
    else
      frame = Animation.binarySearch(frames, time) - 1;
    const drawOrderToSetupIndex = this.drawOrders[frame];
    if (drawOrderToSetupIndex == null)
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
    else {
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
}
const _IkConstraintTimeline = class extends CurveTimeline {
  // time, mix, bendDirection, compress, stretch, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (9 /* ikConstraint */ << 24) + this.ikConstraintIndex;
  }
  /** Sets the time, mix and bend direction of the specified keyframe. */
  setFrame(frameIndex, time, mix, bendDirection, compress, stretch) {
    frameIndex *= _IkConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;
    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
    this.frames[frameIndex + _IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;
    this.frames[frameIndex + _IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
        if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
        if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixIn) {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);
    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    } else {
      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixIn) {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    }
  }
};
let IkConstraintTimeline = _IkConstraintTimeline;
IkConstraintTimeline.ENTRIES = 5;
IkConstraintTimeline.PREV_TIME = -5;
IkConstraintTimeline.PREV_MIX = -4;
IkConstraintTimeline.PREV_BEND_DIRECTION = -3;
IkConstraintTimeline.PREV_COMPRESS = -2;
IkConstraintTimeline.PREV_STRETCH = -1;
IkConstraintTimeline.MIX = 1;
IkConstraintTimeline.BEND_DIRECTION = 2;
IkConstraintTimeline.COMPRESS = 3;
IkConstraintTimeline.STRETCH = 4;
const _TransformConstraintTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, scale mix, shear mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (10 /* transformConstraint */ << 24) + this.transformConstraintIndex;
  }
  /** Sets the time and mixes of the specified keyframe. */
  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
    frameIndex *= _TransformConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.rotateMix = data.rotateMix;
          constraint.translateMix = data.translateMix;
          constraint.scaleMix = data.scaleMix;
          constraint.shearMix = data.shearMix;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    let scale = 0;
    let shear = 0;
    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {
      const i = frames.length;
      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];
    } else {
      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);
      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _TransformConstraintTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;
      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;
      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
      constraint.shearMix += (shear - constraint.shearMix) * alpha;
    }
  }
};
let TransformConstraintTimeline = _TransformConstraintTimeline;
TransformConstraintTimeline.ENTRIES = 5;
TransformConstraintTimeline.PREV_TIME = -5;
TransformConstraintTimeline.PREV_ROTATE = -4;
TransformConstraintTimeline.PREV_TRANSLATE = -3;
TransformConstraintTimeline.PREV_SCALE = -2;
TransformConstraintTimeline.PREV_SHEAR = -1;
TransformConstraintTimeline.ROTATE = 1;
TransformConstraintTimeline.TRANSLATE = 2;
TransformConstraintTimeline.SCALE = 3;
TransformConstraintTimeline.SHEAR = 4;
const _PathConstraintPositionTimeline = class extends CurveTimeline {
  // time, position, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);
  }
  getPropertyId() {
    return (11 /* pathConstraintPosition */ << 24) + this.pathConstraintIndex;
  }
  /** Sets the time and value of the specified keyframe. */
  setFrame(frameIndex, time, value) {
    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    let position = 0;
    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])
      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);
      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintPositionTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)
      );
      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
};
let PathConstraintPositionTimeline = _PathConstraintPositionTimeline;
PathConstraintPositionTimeline.ENTRIES = 2;
PathConstraintPositionTimeline.PREV_TIME = -2;
PathConstraintPositionTimeline.PREV_VALUE = -1;
PathConstraintPositionTimeline.VALUE = 1;
class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (12 /* pathConstraintSpacing */ << 24) + this.pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    let spacing = 0;
    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])
      spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
      spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / PathConstraintSpacingTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)
      );
      spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
}
const _PathConstraintMixTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);
  }
  getPropertyId() {
    return (13 /* pathConstraintMix */ << 24) + this.pathConstraintIndex;
  }
  /** Sets the time and mixes of the specified keyframe. */
  setFrame(frameIndex, time, rotateMix, translateMix) {
    frameIndex *= _PathConstraintMixTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.rotateMix = constraint.data.rotateMix;
          constraint.translateMix = constraint.data.translateMix;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {
      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];
    } else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);
      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintMixTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
    }
  }
};
let PathConstraintMixTimeline = _PathConstraintMixTimeline;
PathConstraintMixTimeline.ENTRIES = 3;
PathConstraintMixTimeline.PREV_TIME = -3;
PathConstraintMixTimeline.PREV_ROTATE = -2;
PathConstraintMixTimeline.PREV_TRANSLATE = -1;
PathConstraintMixTimeline.ROTATE = 1;
PathConstraintMixTimeline.TRANSLATE = 2;


//# sourceMappingURL=Animation.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationState.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationState.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationState": function() { return /* binding */ AnimationState; },
/* harmony export */   "AnimationStateAdapter2": function() { return /* binding */ AnimationStateAdapter2; },
/* harmony export */   "EventQueue": function() { return /* binding */ EventQueue; },
/* harmony export */   "EventType": function() { return /* binding */ EventType; },
/* harmony export */   "TrackEntry": function() { return /* binding */ TrackEntry; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Animation.mjs");



const _AnimationState = class {
  constructor(data) {
    this.tracks = new Array();
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.IntSet();
    this.animationsChanged = false;
    this.timeScale = 1;
    this.trackEntryPool = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Pool(() => new TrackEntry());
    this.data = data;
  }
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next != null) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom != null) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
        tracks[i] = null;
        this.queue.end(current);
        this.disposeNext(current);
        continue;
      }
      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from != null)
          from.mixingTo = null;
        while (from != null) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (from == null)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom != null)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  apply(skeleton) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom != null)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && current.next == null)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      const timelineCount = current.animation.timelines.length;
      const timelines = current.animation.timelines;
      if (i == 0 && mix == 1 || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(mix, blend);
          timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const firstFrame = current.timelinesRotation.length == 0;
        if (firstFrame)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
        const timelinesRotation = current.timelinesRotation;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
          if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
          } else {
            _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom != null)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        blend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        blend = from.mixBlend;
    }
    const events = mix < from.eventThreshold ? this.events : null;
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    const timelineCount = from.animation.timelines.length;
    const timelines = from.animation.timelines;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const firstFrame = from.timelinesRotation.length == 0;
      if (firstFrame)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
      const timelinesRotation = from.timelinesRotation;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case _AnimationState.SUBSEQUENT:
            if (!attachments && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline)
              continue;
            if (!drawOrder && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case _AnimationState.FIRST:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            alpha = alphaMix;
            break;
          case _AnimationState.HOLD:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
        else {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(alpha, blend);
          if (timelineBlend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup) {
            if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline) {
              if (attachments)
                direction = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut;
            } else if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline) {
              if (drawOrder)
                direction = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut;
            }
          }
          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
      return;
    }
    const rotateTimeline = timeline;
    const frames = rotateTimeline.frames;
    const bone = skeleton.bones[rotateTimeline.boneIndex];
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup ? bone.data.rotation : bone.rotation;
      if (time >= frames[frames.length - _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.ENTRIES])
        r2 = bone.data.rotation + frames[frames.length + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.PREV_ROTATION];
      else {
        const frame = _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.Animation.binarySearch(frames, time, _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.ENTRIES);
        const prevRotation = frames[frame + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.PREV_ROTATION];
        const frameTime = frames[frame];
        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.PREV_TIME] - frameTime));
        r2 = frames[frame + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.ROTATION] - prevRotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        r2 = prevRotation + r2 * percent + bone.data.rotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
      }
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastDiff) != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    r1 += total * alpha;
    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, events[i]);
    }
  }
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (current == null)
      return;
    this.queue.end(current);
    this.disposeNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (from == null)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    if (from != null) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom != null && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  setAnimation(trackIndex, animationName, loop) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  setAnimationWith(trackIndex, animation, loop) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current != null) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.disposeNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.disposeNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  addAnimation(trackIndex, animationName, loop, delay) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  addAnimationWith(trackIndex, animation, loop, delay) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last != null) {
      while (last.next != null)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (last == null) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      if (delay <= 0) {
        const duration = last.animationEnd - last.animationStart;
        if (duration != 0) {
          if (last.loop)
            delay += duration * (1 + (last.trackTime / duration | 0));
          else
            delay += Math.max(duration, last.trackTime);
          delay -= this.data.getMix(last.animation, animation);
        } else
          delay = last.trackTime;
      }
    }
    entry.delay = delay;
    return entry;
  }
  setEmptyAnimation(trackIndex, mixDuration) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  addEmptyAnimation(trackIndex, mixDuration, delay) {
    if (delay <= 0)
      delay -= mixDuration;
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  setEmptyAnimations(mixDuration) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current != null)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.interruptAlpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
    return entry;
  }
  disposeNext(entry) {
    let next = entry.next;
    while (next != null) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      let entry = this.tracks[i];
      if (entry == null)
        continue;
      while (entry.mixingFrom != null)
        entry = entry.mixingFrom;
      do {
        if (entry.mixingFrom == null || entry.mixBlend != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add)
          this.setTimelineModes(entry);
        entry = entry.mixingTo;
      } while (entry != null);
    }
  }
  setTimelineModes(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(entry.timelineMode, timelinesCount);
    entry.timelineHoldMix.length = 0;
    const timelineDipMix = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
    const propertyIDs = this.propertyIDs;
    if (to != null && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++) {
        propertyIDs.add(timelines[i].getPropertyId());
        timelineMode[i] = _AnimationState.HOLD;
      }
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const id = timelines[i].getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = _AnimationState.SUBSEQUENT;
        else if (to == null || !this.hasTimeline(to, id))
          timelineMode[i] = _AnimationState.FIRST;
        else {
          for (let next = to.mixingTo; next != null; next = next.mixingTo) {
            if (this.hasTimeline(next, id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = _AnimationState.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = _AnimationState.HOLD;
        }
      }
  }
  hasTimeline(entry, id) {
    const timelines = entry.animation.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      if (timelines[i].getPropertyId() == id)
        return true;
    return false;
  }
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  addListener(listener) {
    if (listener == null)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  clearListeners() {
    this.listeners.length = 0;
  }
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
let AnimationState = _AnimationState;
AnimationState.emptyAnimation = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.Animation("<empty>", [], 0);
AnimationState.SUBSEQUENT = 0;
AnimationState.FIRST = 1;
AnimationState.HOLD = 2;
AnimationState.HOLD_MIX = 3;
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
const _TrackEntry = class {
  constructor() {
    this.mixBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
let TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
const _EventQueue = class {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  deprecateStuff() {
    if (!_EventQueue.deprecatedWarning1) {
      _EventQueue.deprecatedWarning1 = true;
      console.warn(
        "Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'"
      );
    }
    return true;
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener != null && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].start)
              listeners[ii].start(entry);
          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
          break;
        case EventType.interrupt:
          if (entry.listener != null && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].interrupt)
              listeners[ii].interrupt(entry);
          break;
        case EventType.end:
          if (entry.listener != null && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].end)
              listeners[ii].end(entry);
          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
        case EventType.dispose:
          if (entry.listener != null && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].dispose)
              listeners[ii].dispose(entry);
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener != null && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].complete)
              listeners[ii].complete(entry);
          const count = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.toInt(entry.loopsCount());
          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener != null && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].event)
              listeners[ii].event(entry, event);
          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);
          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
};
let EventQueue = _EventQueue;
EventQueue.deprecatedWarning1 = false;
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
  return EventType2;
})(EventType || {});
class AnimationStateAdapter2 {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
}


//# sourceMappingURL=AnimationState.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationStateData.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationStateData.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationStateData": function() { return /* binding */ AnimationStateData; }
/* harmony export */ });
const _AnimationStateData = class {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    this.defaultMix = 0;
    if (skeletonData == null)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (from == null)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (to == null)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  setMixByName(fromName, toName, duration) {
    if (!_AnimationStateData.deprecatedWarning1) {
      _AnimationStateData.deprecatedWarning1 = true;
      console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
    }
    this.setMix(fromName, toName, duration);
  }
  setMixWith(from, to, duration) {
    if (from == null)
      throw new Error("from cannot be null.");
    if (to == null)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
};
let AnimationStateData = _AnimationStateData;
AnimationStateData.deprecatedWarning1 = false;


//# sourceMappingURL=AnimationStateData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AtlasAttachmentLoader.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/AtlasAttachmentLoader.mjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AtlasAttachmentLoader": function() { return /* binding */ AtlasAttachmentLoader; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attachments/BoundingBoxAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/BoundingBoxAttachment.mjs");
/* harmony import */ var _attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/ClippingAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/ClippingAttachment.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./attachments/PointAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PointAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs");








class AtlasAttachmentLoader {
  constructor(atlas) {
    this.atlas = atlas;
  }
  /** @return May be null to not load an attachment. */
  newRegionAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
    const attachment = new _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__.RegionAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newMeshAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
    const attachment = new _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.MeshAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newBoundingBoxAttachment(skin, name) {
    return new _attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__.BoundingBoxAttachment(name);
  }
  /** @return May be null to not load an attachment */
  newPathAttachment(skin, name) {
    return new _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new _attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__.PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new _attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.ClippingAttachment(name);
  }
}


//# sourceMappingURL=AtlasAttachmentLoader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Bone.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/Bone.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bone": function() { return /* binding */ Bone; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class Bone {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    // be careful! Spine b,c is c,b in pixi matrix
    this.matrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.children = new Array();
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 0;
    this.scaleY = 0;
    this.shearX = 0;
    this.shearY = 0;
    this.ax = 0;
    this.ay = 0;
    this.arotation = 0;
    this.ascaleX = 0;
    this.ascaleY = 0;
    this.ashearX = 0;
    this.ashearY = 0;
    this.appliedValid = false;
    this.sorted = false;
    /** NOT USED IN 3.7. Needed for the debug graph code */
    this.active = true;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */
  update() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (parent == null) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY;
        m.b = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rx) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(ry) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rx) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScale:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScaleOrReflection: {
        const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation);
        const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScale && pa * pd - pb * pc < 0 != (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(shearX) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(shearX) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.c * m.c);
  }
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.b * m.b + m.d * m.d);
  }
  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using
   * the applied transform after the world transform has been modified directly (eg, by a constraint).
   * <p>
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */
  updateAppliedTransform() {
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    if (parent == null) {
      this.ax = m.tx;
      this.ay = m.ty;
      this.arotation = Math.atan2(m.b, m.a) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
    }
  }
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  worldToLocalRotation(worldRotation) {
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(worldRotation);
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  localToWorldRotation(localRotation) {
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(localRotation);
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(degrees);
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
    this.appliedValid = false;
  }
}


//# sourceMappingURL=Bone.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/BoneData.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/BoneData.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoneData": function() { return /* binding */ BoneData; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class BoneData {
  constructor(index, name, parent) {
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.shearX = 0;
    this.shearY = 0;
    this.transformMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.Normal;
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
}


//# sourceMappingURL=BoneData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Event.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/Event.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": function() { return /* binding */ Event; }
/* harmony export */ });
class Event {
  constructor(time, data) {
    if (data == null)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
}


//# sourceMappingURL=Event.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/EventData.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/EventData.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventData": function() { return /* binding */ EventData; }
/* harmony export */ });
class EventData {
  constructor(name) {
    this.name = name;
  }
}


//# sourceMappingURL=EventData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraint.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraint.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IkConstraint": function() { return /* binding */ IkConstraint; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class IkConstraint {
  constructor(data, skeleton) {
    this.bendDirection = 0;
    this.compress = false;
    this.stretch = false;
    this.mix = 1;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  getOrder() {
    return this.data.order;
  }
  apply() {
    this.update();
  }
  update() {
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);
        break;
    }
  }
  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
   * coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    if (!bone.appliedValid)
      bone.updateAppliedTransform();
    const p = bone.parent.matrix;
    const id = 1 / (p.a * p.d - p.b * p.c);
    const x = targetX - p.tx;
    const y = targetY - p.ty;
    const tx = (x * p.d - y * p.c) * id - bone.ax;
    const ty = (y * p.a - x * p.b) * id - bone.ay;
    let rotationIK = Math.atan2(ty, tx) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg - bone.ashearX - bone.arotation;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
   * target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, alpha) {
    if (alpha == 0) {
      child.updateWorldTransform();
      return;
    }
    if (!parent.appliedValid)
      parent.updateAppliedTransform();
    if (!child.appliedValid)
      child.updateAppliedTransform();
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let sx = psx;
    let psy = parent.ascaleY;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = targetX - pp.tx;
    let y = targetY - pp.ty;
    const tx = (x * d - y * b) * id - px;
    const ty = (y * a - x * c) * id - py;
    const dd = tx * tx + ty * ty;
    x = cwx - pp.tx;
    y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1 = 0;
    let a2 = 0;
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch && l1 + l2 > 1e-4)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
}


//# sourceMappingURL=IkConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraintData.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraintData.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IkConstraintData": function() { return /* binding */ IkConstraintData; }
/* harmony export */ });
class IkConstraintData {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.bendDirection = 1;
    this.compress = false;
    this.stretch = false;
    this.uniform = false;
    this.mix = 1;
    this.name = name;
  }
}


//# sourceMappingURL=IkConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraint.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraint.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathConstraint": function() { return /* binding */ PathConstraint; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraintData.mjs");






const _PathConstraint = class {
  constructor(data, skeleton) {
    this.position = 0;
    this.spacing = 0;
    this.rotateMix = 0;
    this.translateMix = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findSlot(data.target.name);
    this.position = data.position;
    this.spacing = data.spacing;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
  }
  apply() {
    this.update();
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.PathAttachment))
      return;
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const translate = translateMix > 0;
    const rotate = rotateMix > 0;
    if (!translate && !rotate)
      return;
    const data = this.data;
    const spacingMode = data.spacingMode;
    const lengthSpacing = spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__.SpacingMode.Length;
    const rotateMode = data.rotateMode;
    const tangents = rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.Tangent;
    const scale = rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.ChainScale;
    const boneCount = this.bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const bones = this.bones;
    const spaces = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.spaces, spacesCount);
    let lengths = null;
    const spacing = this.spacing;
    if (scale || lengthSpacing) {
      if (scale)
        lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.lengths, boneCount);
      for (let i = 0, n = spacesCount - 1; i < n; ) {
        const bone = bones[i];
        const setupLength = bone.data.length;
        if (setupLength < _PathConstraint.epsilon) {
          if (scale)
            lengths[i] = 0;
          spaces[++i] = 0;
        } else {
          const x = setupLength * bone.matrix.a;
          const y = setupLength * bone.matrix.b;
          const length = Math.sqrt(x * x + y * y);
          if (scale)
            lengths[i] = length;
          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
        }
      }
    } else {
      for (let i = 1; i < spacesCount; i++)
        spaces[i] = spacing;
    }
    const positions = this.computeWorldPositions(
      attachment,
      spacesCount,
      tangents,
      data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.PositionMode.Percent,
      spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__.SpacingMode.Percent
    );
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * translateMix;
      mat.ty += (boneY - mat.ty) * translateMix;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (rotate) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;
          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;
        } else {
          r += offsetRotation;
        }
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI2;
        r *= rotateMix;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.appliedValid = false;
    }
  }
  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = null;
    const closed = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (percentPosition)
        position *= pathLength2;
      if (percentSpacing) {
        for (let i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength2;
      }
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i];
        position += space;
        let p = position;
        if (closed) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed) {
      verticesLength += 2;
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (percentPosition)
      position *= pathLength;
    if (percentSpacing) {
      for (let i = 0; i < spacesCount; i++)
        spaces[i] *= pathLength;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i];
      position += space;
      let p = position;
      if (closed) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p))
      p = 1e-4;
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents)
      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
  }
  getOrder() {
    return this.data.order;
  }
};
let PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;


//# sourceMappingURL=PathConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraintData.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraintData.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathConstraintData": function() { return /* binding */ PathConstraintData; },
/* harmony export */   "SpacingMode": function() { return /* binding */ SpacingMode; }
/* harmony export */ });
class PathConstraintData {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.name = name;
  }
}
var SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  return SpacingMode2;
})(SpacingMode || {});


//# sourceMappingURL=PathConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Skeleton.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/Skeleton.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Skeleton": function() { return /* binding */ Skeleton; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _Bone_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bone.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Bone.mjs");
/* harmony import */ var _Slot_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Slot.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Slot.mjs");
/* harmony import */ var _IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IkConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraint.mjs");
/* harmony import */ var _TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TransformConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraint.mjs");
/* harmony import */ var _PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PathConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraint.mjs");











const _Skeleton = class {
  constructor(data) {
    this._updateCache = new Array();
    this.updateCacheReset = new Array();
    this.time = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    if (data == null)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (boneData.parent == null)
        bone = new _Bone_mjs__WEBPACK_IMPORTED_MODULE_5__.Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new _Bone_mjs__WEBPACK_IMPORTED_MODULE_5__.Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new _Slot_mjs__WEBPACK_IMPORTED_MODULE_6__.Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new _IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_7__.IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new _TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_8__.TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new _PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraint(pathConstraintData, this));
    }
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.updateCache();
  }
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    this.updateCacheReset.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].sorted = false;
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length > 1) {
      const child = constrained[constrained.length - 1];
      if (!(this._updateCache.indexOf(child) > -1))
        this.updateCacheReset.push(child);
    }
    this._updateCache.push(constraint);
    this.sortReset(parent.children);
    constrained[constrained.length - 1].sorted = true;
  }
  sortPathConstraint(constraint) {
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin != null)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let ii = 0; ii < boneCount; ii++)
      this.sortReset(constrained[ii].children);
    for (let ii = 0; ii < boneCount; ii++)
      constrained[ii].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (pathBones == null)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      let i = 0;
      while (i < pathBones.length) {
        const boneCount = pathBones[i++];
        for (let n = i + boneCount; i < n; i++) {
          const boneIndex = pathBones[i];
          this.sortBone(bones[boneIndex]);
        }
      }
    }
  }
  sortBone(bone) {
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent != null)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies constraints. */
  updateWorldTransform() {
    const updateCacheReset = this.updateCacheReset;
    for (let i = 0, n = updateCacheReset.length; i < n; i++) {
      const bone = updateCacheReset[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
      bone.appliedValid = true;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.mix = constraint.data.mix;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
      constraint.scaleMix = data.scaleMix;
      constraint.shearMix = data.shearMix;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
    }
  }
  setSlotsToSetupPose() {
    const slots = this.slots;
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @return May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @return May be null. */
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** @return May be null. */
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   * @see #setSkin(Skin) */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (skin == null)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin != null) {
      if (this.skin != null)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name != null) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment != null)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
  }
  /** @return May be null. */
  getAttachmentByName(slotName, attachmentName) {
    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
  }
  /** @return May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (attachmentName == null)
      throw new Error("attachmentName cannot be null.");
    if (this.skin != null) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment != null)
        return attachment;
    }
    if (this.data.defaultSkin != null)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** @param attachmentName May be null. */
  setAttachment(slotName, attachmentName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName != null) {
          attachment = this.getAttachment(i, attachmentName);
          if (attachment == null)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** @return May be null. */
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** @return May be null. */
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** @return May be null. */
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size The width and height of the AABB.
   * @param temp Working memory */
  getBounds(offset, size, temp) {
    if (offset == null)
      throw new Error("offset cannot be null.");
    if (size == null)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.RegionAttachment) {
        verticesLength = 8;
        vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
      } else if (attachment instanceof _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices != null) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  update(delta) {
    this.time += delta;
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
let Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;


//# sourceMappingURL=Skeleton.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonBounds.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonBounds.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonBounds": function() { return /* binding */ SkeletonBounds; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class SkeletonBounds extends _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.SkeletonBoundsBase {
}


//# sourceMappingURL=SkeletonBounds.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonData.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonData.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonData": function() { return /* binding */ SkeletonData; }
/* harmony export */ });
class SkeletonData {
  constructor() {
    this.bones = new Array();
    // Ordered parents first.
    this.slots = new Array();
    // Setup pose draw order.
    this.skins = new Array();
    this.events = new Array();
    this.animations = new Array();
    this.ikConstraints = new Array();
    this.transformConstraints = new Array();
    this.pathConstraints = new Array();
    // Nonessential
    this.fps = 0;
  }
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  findSkin(skinName) {
    if (skinName == null)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  findEvent(eventDataName) {
    if (eventDataName == null)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  findAnimation(animationName) {
    if (animationName == null)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
}


//# sourceMappingURL=SkeletonData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonJson.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonJson.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonJson": function() { return /* binding */ SkeletonJson; }
/* harmony export */ });
/* harmony import */ var _Event_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Event.mjs");
/* harmony import */ var _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonData.mjs");
/* harmony import */ var _SlotData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SlotData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SlotData.mjs");
/* harmony import */ var _BoneData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BoneData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/BoneData.mjs");
/* harmony import */ var _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraintData.mjs");
/* harmony import */ var _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraintData.mjs");
/* harmony import */ var _Skin_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Skin.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Skin.mjs");
/* harmony import */ var _EventData_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EventData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/EventData.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Animation.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");













class SkeletonJson {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_1__.SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap != null) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = this.getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new _BoneData_mjs__WEBPACK_IMPORTED_MODULE_3__.BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = this.getValue(boneMap, "length", 0) * scale;
        data.x = this.getValue(boneMap, "x", 0) * scale;
        data.y = this.getValue(boneMap, "y", 0) * scale;
        data.rotation = this.getValue(boneMap, "rotation", 0);
        data.scaleX = this.getValue(boneMap, "scaleX", 1);
        data.scaleY = this.getValue(boneMap, "scaleY", 1);
        data.shearX = this.getValue(boneMap, "shearX", 0);
        data.shearY = this.getValue(boneMap, "shearY", 0);
        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const slotName = slotMap.name;
        const boneName = slotMap.bone;
        const boneData = skeletonData.findBone(boneName);
        if (boneData == null)
          throw new Error(`Slot bone not found: ${boneName}`);
        const data = new _SlotData_mjs__WEBPACK_IMPORTED_MODULE_2__.SlotData(skeletonData.slots.length, slotName, boneData);
        const color = this.getValue(slotMap, "color", null);
        if (color != null)
          data.color.setFromString(color);
        const dark = this.getValue(slotMap, "dark", null);
        if (dark != null) {
          data.darkColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color(1, 1, 1, 1);
          data.darkColor.setFromString(dark);
        }
        data.attachmentName = this.getValue(slotMap, "attachment", null);
        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__.IkConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`IK target bone not found: ${targetName}`);
        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.mix = this.getValue(constraintMap, "mix", 1);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.TransformConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`Transform constraint target bone not found: ${targetName}`);
        data.local = this.getValue(constraintMap, "local", false);
        data.relative = this.getValue(constraintMap, "relative", false);
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.PathConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findSlot(targetName);
        if (data.target == null)
          throw new Error(`Path target slot not found: ${targetName}`);
        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.position = this.getValue(constraintMap, "position", 0);
        if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
          data.position *= scale;
        data.spacing = this.getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed)
          data.spacing *= scale;
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (const skinName in root.skins) {
        const skinMap = root.skins[skinName];
        const skin = new _Skin_mjs__WEBPACK_IMPORTED_MODULE_7__.Skin(skinName);
        for (const slotName in skinMap) {
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotName}`);
          const slotMap = skinMap[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);
            if (attachment != null)
              skin.addAttachment(slotIndex, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new _EventData_mjs__WEBPACK_IMPORTED_MODULE_8__.EventData(eventName);
        data.intValue = this.getValue(eventMap, "int", 0);
        data.floatValue = this.getValue(eventMap, "float", 0);
        data.stringValue = this.getValue(eventMap, "string", "");
        data.audioPath = this.getValue(eventMap, "audio", null);
        if (data.audioPath != null) {
          data.volume = this.getValue(eventMap, "volume", 1);
          data.balance = this.getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = this.getValue(map, "name", name);
    const type = this.getValue(map, "type", "region");
    switch (type) {
      case "region": {
        const path = this.getValue(map, "path", name);
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = this.getValue(map, "x", 0) * scale;
        region.y = this.getValue(map, "y", 0) * scale;
        region.scaleX = this.getValue(map, "scaleX", 1);
        region.scaleY = this.getValue(map, "scaleY", 1);
        region.rotation = this.getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        const color = this.getValue(map, "color", null);
        if (color != null)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = this.getValue(map, "path", name);
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        const color = this.getValue(map, "color", null);
        if (color != null)
          mesh.color.setFromString(color);
        const parent = this.getValue(map, "parent", null);
        if (parent != null) {
          mesh.inheritDeform = this.getValue(map, "deform", true);
          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = this.getValue(map, "closed", false);
        path.constantSpeed = this.getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = this.getValue(map, "color", null);
        if (color != null)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = this.getValue(map, "x", 0) * scale;
        point.y = this.getValue(map, "y", 0) * scale;
        point.rotation = this.getValue(map, "rotation", 0);
        const color = this.getValue(map, "color", null);
        if (color != null)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        const end = this.getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    let duration = 0;
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slotIndex = skeletonData.findSlotIndex(slotName);
        if (slotIndex == -1)
          throw new Error(`Slot not found: ${slotName}`);
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (timelineName == "attachment") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.AttachmentTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          } else if (timelineName == "color") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
              color.setFromString(valueMap.color || "ffffffff");
              timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline.ENTRIES]);
          } else if (timelineName == "twoColor") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const light = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
              const dark = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
              light.setFromString(valueMap.light);
              dark.setFromString(valueMap.dark);
              timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const boneIndex = skeletonData.findBoneIndex(boneName);
        if (boneIndex == -1)
          throw new Error(`Bone not found: ${boneName}`);
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          if (timelineName === "rotate") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline(timelineMap.length);
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline.ENTRIES]);
          } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "scale")
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ScaleTimeline(timelineMap.length);
            else if (timelineName === "shear")
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ShearTimeline(timelineMap.length);
            else {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline(timelineMap.length);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const x = this.getValue(valueMap, "x", 0);
              const y = this.getValue(valueMap, "y", 0);
              timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        const constraint = skeletonData.findIkConstraint(constraintName);
        const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline(constraintMap.length);
        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            valueMap.time,
            this.getValue(valueMap, "mix", 1),
            this.getValue(valueMap, "bendPositive", true) ? 1 : -1,
            this.getValue(valueMap, "compress", false),
            this.getValue(valueMap, "stretch", false)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline.ENTRIES]);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const constraintMap = map.transform[constraintName];
        const constraint = skeletonData.findTransformConstraint(constraintName);
        const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline(constraintMap.length);
        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            valueMap.time,
            this.getValue(valueMap, "rotateMix", 1),
            this.getValue(valueMap, "translateMix", 1),
            this.getValue(valueMap, "scaleMix", 1),
            this.getValue(valueMap, "shearMix", 1)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline.ENTRIES]);
      }
    }
    if (map.paths) {
      for (const constraintName in map.paths) {
        const constraintMap = map.paths[constraintName];
        const index = skeletonData.findPathConstraintIndex(constraintName);
        if (index == -1)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const data = skeletonData.pathConstraints[index];
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          if (timelineName === "position" || timelineName === "spacing") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "spacing") {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintSpacingTimeline(timelineMap.length);
              if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline(timelineMap.length);
              if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline.ENTRIES]);
          } else if (timelineName === "mix") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline(timelineMap.length);
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline.ENTRIES]);
          }
        }
      }
    }
    if (map.deform) {
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const skin = skeletonData.findSkin(deformName);
        if (skin == null) {
          if (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.settings.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${deformName}`);
          } else {
            continue;
          }
        }
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotMap.name}`);
          for (const timelineName in slotMap) {
            const timelineMap = slotMap[timelineName];
            const attachment = skin.getAttachment(slotIndex, timelineName);
            if (attachment == null)
              throw new Error(`Deform attachment not found: ${timelineMap.name}`);
            const weighted = attachment.bones != null;
            const vertices = attachment.vertices;
            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DeformTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            let frameIndex = 0;
            for (let j = 0; j < timelineMap.length; j++) {
              const valueMap = timelineMap[j];
              let deform;
              const verticesValue = this.getValue(valueMap, "vertices", null);
              if (verticesValue == null)
                deform = weighted ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength);
                const start = this.getValue(valueMap, "offset", 0);
                _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                if (scale != 1) {
                  for (let i = start, n = i + verticesValue.length; i < n; i++)
                    deform[i] *= scale;
                }
                if (!weighted) {
                  for (let i = 0; i < deformLength; i++)
                    deform[i] += vertices[i];
                }
              }
              timeline.setFrame(frameIndex, valueMap.time, deform);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
        }
      }
    }
    let drawOrderNode = map.drawOrder;
    if (drawOrderNode == null)
      drawOrderNode = map.draworder;
    if (drawOrderNode != null) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DrawOrderTimeline(drawOrderNode.length);
      const slotCount = skeletonData.slots.length;
      let frameIndex = 0;
      for (let j = 0; j < drawOrderNode.length; j++) {
        const drawOrderMap = drawOrderNode[j];
        let drawOrder = null;
        const offsets = this.getValue(drawOrderMap, "offsets", null);
        if (offsets != null) {
          drawOrder = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount, -1);
          const unchanged = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let i = 0; i < offsets.length; i++) {
            const offsetMap = offsets[i];
            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
            if (slotIndex == -1)
              throw new Error(`Slot not found: ${offsetMap.slot}`);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let i = slotCount - 1; i >= 0; i--)
            if (drawOrder[i] == -1)
              drawOrder[i] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (map.events) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.EventTimeline(map.events.length);
      let frameIndex = 0;
      for (let i = 0; i < map.events.length; i++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (eventData == null)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new _Event_mjs__WEBPACK_IMPORTED_MODULE_0__.Event(_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toSinglePrecision(eventMap.time), eventData);
        event.intValue = this.getValue(eventMap, "int", eventData.intValue);
        event.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath != null) {
          event.volume = this.getValue(eventMap, "volume", 1);
          event.balance = this.getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frameIndex++, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.Animation(name, timelines, duration));
  }
  readCurve(map, timeline, frameIndex) {
    if (!map.curve)
      return;
    if (map.curve === "stepped")
      timeline.setStepped(frameIndex);
    else if (Object.prototype.toString.call(map.curve) === "[object Array]") {
      const curve = map.curve;
      timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
    }
  }
  getValue(map, prop, defaultValue) {
    return map[prop] !== void 0 ? map[prop] : defaultValue;
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.NORMAL;
    if (str == "additive")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.ADD;
    if (str == "multiply")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
  static positionModeFromString(str) {
    str = str.toLowerCase();
    if (str == "fixed")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed;
    if (str == "percent")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static spacingModeFromString(str) {
    str = str.toLowerCase();
    if (str == "length")
      return _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length;
    if (str == "fixed")
      return _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed;
    if (str == "percent")
      return _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static rotateModeFromString(str) {
    str = str.toLowerCase();
    if (str == "tangent")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.Tangent;
    if (str == "chain")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.Chain;
    if (str == "chainscale")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.ChainScale;
    throw new Error(`Unknown rotate mode: ${str}`);
  }
  static transformModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.Normal;
    if (str == "onlytranslation")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.OnlyTranslation;
    if (str == "norotationorreflection")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoRotationOrReflection;
    if (str == "noscale")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoScale;
    if (str == "noscaleorreflection")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoScaleOrReflection;
    throw new Error(`Unknown transform mode: ${str}`);
  }
}
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
  }
}


//# sourceMappingURL=SkeletonJson.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Skin.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/Skin.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Skin": function() { return /* binding */ Skin; }
/* harmony export */ });
class Skin {
  constructor(name) {
    this.attachments = new Array();
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  addAttachment(slotIndex, name, attachment) {
    if (attachment == null)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  /** @return May be null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment != null)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
}


//# sourceMappingURL=Skin.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Slot.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/Slot.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Slot": function() { return /* binding */ Slot; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class Slot {
  constructor(data, bone) {
    this.attachmentVertices = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (bone == null)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    this.darkColor = data.darkColor == null ? null : new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** @return May be null. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.
   * @param attachment May be null. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    this.attachment = attachment;
    this.attachmentTime = this.bone.skeleton.time;
    this.attachmentVertices.length = 0;
  }
  setAttachmentTime(time) {
    this.attachmentTime = this.bone.skeleton.time - time;
  }
  /** Returns the time since the attachment was set. */
  getAttachmentTime() {
    return this.bone.skeleton.time - this.attachmentTime;
  }
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor != null)
      this.darkColor.setFromColor(this.data.darkColor);
    if (this.data.attachmentName == null)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
}


//# sourceMappingURL=Slot.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SlotData.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/SlotData.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SlotData": function() { return /* binding */ SlotData; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class SlotData {
  constructor(index, name, boneData) {
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    if (boneData == null)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
}


//# sourceMappingURL=SlotData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraint.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraint.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformConstraint": function() { return /* binding */ TransformConstraint; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class TransformConstraint {
  constructor(data, skeleton) {
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.temp = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Vector2();
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
    this.scaleMix = data.scaleMix;
    this.shearMix = data.shearMix;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  apply() {
    this.update();
  }
  update() {
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * translateMix;
        mat.ty += (temp.y - mat.ty) * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        let ts = Math.sqrt(ta * ta + tc * tc);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
        mat.a *= s;
        mat.b *= s;
        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        ts = Math.sqrt(tb * tb + td * td);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r = by + (r + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyRelativeWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * translateMix;
        mat.ty += temp.y * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
        mat.a *= s;
        mat.b *= s;
        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI / 2 + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyAbsoluteLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * rotateMix;
      }
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax - x + this.data.offsetX) * translateMix;
        y += (target.ay - y + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
        if (scaleY > 1e-5)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
      }
      const shearY = bone.ashearY;
      if (shearMix > 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        bone.shearY += r * shearMix;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0)
        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax + this.data.offsetX) * translateMix;
        y += (target.ay + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
        if (scaleY > 1e-5)
          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
      }
      let shearY = bone.ashearY;
      if (shearMix > 0)
        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  getOrder() {
    return this.data.order;
  }
}


//# sourceMappingURL=TransformConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraintData.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraintData.mjs ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformConstraintData": function() { return /* binding */ TransformConstraintData; }
/* harmony export */ });
class TransformConstraintData {
  constructor(name) {
    this.order = 0;
    this.bones = new Array();
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.offsetRotation = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.offsetScaleX = 0;
    this.offsetScaleY = 0;
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}


//# sourceMappingURL=TransformConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attachment": function() { return /* binding */ Attachment; },
/* harmony export */   "VertexAttachment": function() { return /* binding */ VertexAttachment; }
/* harmony export */ });
class Attachment {
  constructor(name) {
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}
const _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    this.id = (_VertexAttachment.nextID++ & 65535) << 11;
    this.worldVerticesLength = 0;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms local vertices to world coordinates.
   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.
   * @param worldVertices The output world vertices. Must have a length >= offset + count.
   * @param offset The worldVertices index to begin writing values. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.attachmentVertices;
    let vertices = this.vertices;
    const bones = this.bones;
    if (bones == null) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */
  applyDeform(sourceAttachment) {
    return this == sourceAttachment;
  }
};
let VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;


//# sourceMappingURL=Attachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/BoundingBoxAttachment.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/BoundingBoxAttachment.mjs ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoundingBoxAttachment": function() { return /* binding */ BoundingBoxAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class BoundingBoxAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.BoundingBox;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
}


//# sourceMappingURL=BoundingBoxAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/ClippingAttachment.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/ClippingAttachment.mjs ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClippingAttachment": function() { return /* binding */ ClippingAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class ClippingAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Clipping;
    // Nonessential.
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0.2275, 0.2275, 0.8078, 1);
  }
}


//# sourceMappingURL=ClippingAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/MeshAttachment.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/MeshAttachment.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshAttachment": function() { return /* binding */ MeshAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class MeshAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Mesh;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.inheritDeform = false;
    this.tempColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0, 0, 0, 0);
  }
  applyDeform(sourceAttachment) {
    return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;
  }
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh != null) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  // computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);
}


//# sourceMappingURL=MeshAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PathAttachment.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PathAttachment.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathAttachment": function() { return /* binding */ PathAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class PathAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Path;
    this.closed = false;
    this.constantSpeed = false;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
}


//# sourceMappingURL=PathAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PointAttachment.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PointAttachment.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointAttachment": function() { return /* binding */ PointAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class PointAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Point;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(this.rotation);
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
}


//# sourceMappingURL=PointAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RegionAttachment": function() { return /* binding */ RegionAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _Slot_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Slot.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Slot.mjs");




const _RegionAttachment = class extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.Attachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Region;
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.width = 0;
    this.height = 0;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.offset = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(8);
    this.uvs = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(8);
    this.tempColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
  updateOffset() {
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const localXCos = localX * cos + this.x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + this.y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + this.x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + this.y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[_RegionAttachment.OX1] = localXCos - localYSin;
    offset[_RegionAttachment.OY1] = localYCos + localXSin;
    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;
    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;
    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;
    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;
    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;
    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;
  }
  setRegion(region) {
    this.region = region;
    const uvs = this.uvs;
    if (region.rotate) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  computeWorldVertices(bone, worldVertices, offset, stride) {
    const vertexOffset = this.offset;
    const mat = bone instanceof _Slot_mjs__WEBPACK_IMPORTED_MODULE_2__.Slot ? bone.bone.matrix : bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[_RegionAttachment.OX1];
    offsetY = vertexOffset[_RegionAttachment.OY1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX2];
    offsetY = vertexOffset[_RegionAttachment.OY2];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX3];
    offsetY = vertexOffset[_RegionAttachment.OY3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX4];
    offsetY = vertexOffset[_RegionAttachment.OY4];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
};
let RegionAttachment = _RegionAttachment;
RegionAttachment.OX1 = 0;
RegionAttachment.OY1 = 1;
RegionAttachment.OX2 = 2;
RegionAttachment.OY2 = 3;
RegionAttachment.OX3 = 4;
RegionAttachment.OY3 = 5;
RegionAttachment.OX4 = 6;
RegionAttachment.OY4 = 7;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;


//# sourceMappingURL=RegionAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/JitterEffect.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/JitterEffect.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JitterEffect": function() { return /* binding */ JitterEffect; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class JitterEffect {
  constructor(jitterX, jitterY) {
    this.jitterX = 0;
    this.jitterY = 0;
    this.jitterX = jitterX;
    this.jitterY = jitterY;
  }
  begin(skeleton) {
  }
  transform(position, uv, light, dark) {
    position.x += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    position.y += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
  }
  end() {
  }
}


//# sourceMappingURL=JitterEffect.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/SwirlEffect.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/SwirlEffect.mjs ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SwirlEffect": function() { return /* binding */ SwirlEffect; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


const _SwirlEffect = class {
  constructor(radius) {
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.angle = 0;
    this.worldX = 0;
    this.worldY = 0;
    this.radius = radius;
  }
  begin(skeleton) {
    this.worldX = skeleton.x + this.centerX;
    this.worldY = skeleton.y + this.centerY;
  }
  transform(position, uv, light, dark) {
    const radAngle = this.angle * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degreesToRadians;
    const x = position.x - this.worldX;
    const y = position.y - this.worldY;
    const dist = Math.sqrt(x * x + y * y);
    if (dist < this.radius) {
      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);
      position.x = cos * x - sin * y + this.worldX;
      position.y = sin * x + cos * y + this.worldY;
    }
  }
  end() {
  }
};
let SwirlEffect = _SwirlEffect;
SwirlEffect.interpolation = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.PowOut(2);


//# sourceMappingURL=SwirlEffect.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.7/lib/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.7/lib/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.Animation; },
/* harmony export */   "AnimationState": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.AnimationState; },
/* harmony export */   "AnimationStateAdapter2": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.AnimationStateAdapter2; },
/* harmony export */   "AnimationStateData": function() { return /* reexport safe */ _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_11__.AnimationStateData; },
/* harmony export */   "AtlasAttachmentLoader": function() { return /* reexport safe */ _core_AtlasAttachmentLoader_mjs__WEBPACK_IMPORTED_MODULE_12__.AtlasAttachmentLoader; },
/* harmony export */   "Attachment": function() { return /* reexport safe */ _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.Attachment; },
/* harmony export */   "AttachmentTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.AttachmentTimeline; },
/* harmony export */   "Bone": function() { return /* reexport safe */ _core_Bone_mjs__WEBPACK_IMPORTED_MODULE_13__.Bone; },
/* harmony export */   "BoneData": function() { return /* reexport safe */ _core_BoneData_mjs__WEBPACK_IMPORTED_MODULE_14__.BoneData; },
/* harmony export */   "BoundingBoxAttachment": function() { return /* reexport safe */ _core_attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__.BoundingBoxAttachment; },
/* harmony export */   "ClippingAttachment": function() { return /* reexport safe */ _core_attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.ClippingAttachment; },
/* harmony export */   "ColorTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline; },
/* harmony export */   "CurveTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.CurveTimeline; },
/* harmony export */   "DeformTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DeformTimeline; },
/* harmony export */   "DrawOrderTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DrawOrderTimeline; },
/* harmony export */   "Event": function() { return /* reexport safe */ _core_Event_mjs__WEBPACK_IMPORTED_MODULE_15__.Event; },
/* harmony export */   "EventData": function() { return /* reexport safe */ _core_EventData_mjs__WEBPACK_IMPORTED_MODULE_16__.EventData; },
/* harmony export */   "EventQueue": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.EventQueue; },
/* harmony export */   "EventTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.EventTimeline; },
/* harmony export */   "EventType": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.EventType; },
/* harmony export */   "IkConstraint": function() { return /* reexport safe */ _core_IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_17__.IkConstraint; },
/* harmony export */   "IkConstraintData": function() { return /* reexport safe */ _core_IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_18__.IkConstraintData; },
/* harmony export */   "IkConstraintTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline; },
/* harmony export */   "JitterEffect": function() { return /* reexport safe */ _core_vertexeffects_JitterEffect_mjs__WEBPACK_IMPORTED_MODULE_7__.JitterEffect; },
/* harmony export */   "MeshAttachment": function() { return /* reexport safe */ _core_attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.MeshAttachment; },
/* harmony export */   "PathAttachment": function() { return /* reexport safe */ _core_attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.PathAttachment; },
/* harmony export */   "PathConstraint": function() { return /* reexport safe */ _core_PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_19__.PathConstraint; },
/* harmony export */   "PathConstraintData": function() { return /* reexport safe */ _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_20__.PathConstraintData; },
/* harmony export */   "PathConstraintMixTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline; },
/* harmony export */   "PathConstraintPositionTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline; },
/* harmony export */   "PathConstraintSpacingTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintSpacingTimeline; },
/* harmony export */   "PointAttachment": function() { return /* reexport safe */ _core_attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__.PointAttachment; },
/* harmony export */   "RegionAttachment": function() { return /* reexport safe */ _core_attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__.RegionAttachment; },
/* harmony export */   "RotateTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline; },
/* harmony export */   "ScaleTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ScaleTimeline; },
/* harmony export */   "ShearTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ShearTimeline; },
/* harmony export */   "Skeleton": function() { return /* reexport safe */ _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_21__.Skeleton; },
/* harmony export */   "SkeletonBounds": function() { return /* reexport safe */ _core_SkeletonBounds_mjs__WEBPACK_IMPORTED_MODULE_22__.SkeletonBounds; },
/* harmony export */   "SkeletonData": function() { return /* reexport safe */ _core_SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_23__.SkeletonData; },
/* harmony export */   "SkeletonJson": function() { return /* reexport safe */ _core_SkeletonJson_mjs__WEBPACK_IMPORTED_MODULE_24__.SkeletonJson; },
/* harmony export */   "Skin": function() { return /* reexport safe */ _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_25__.Skin; },
/* harmony export */   "Slot": function() { return /* reexport safe */ _core_Slot_mjs__WEBPACK_IMPORTED_MODULE_26__.Slot; },
/* harmony export */   "SlotData": function() { return /* reexport safe */ _core_SlotData_mjs__WEBPACK_IMPORTED_MODULE_27__.SlotData; },
/* harmony export */   "SpacingMode": function() { return /* reexport safe */ _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_20__.SpacingMode; },
/* harmony export */   "Spine": function() { return /* reexport safe */ _Spine_mjs__WEBPACK_IMPORTED_MODULE_30__.Spine; },
/* harmony export */   "SwirlEffect": function() { return /* reexport safe */ _core_vertexeffects_SwirlEffect_mjs__WEBPACK_IMPORTED_MODULE_8__.SwirlEffect; },
/* harmony export */   "TimelineType": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TimelineType; },
/* harmony export */   "TrackEntry": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.TrackEntry; },
/* harmony export */   "TransformConstraint": function() { return /* reexport safe */ _core_TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_28__.TransformConstraint; },
/* harmony export */   "TransformConstraintData": function() { return /* reexport safe */ _core_TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_29__.TransformConstraintData; },
/* harmony export */   "TransformConstraintTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline; },
/* harmony export */   "TranslateTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline; },
/* harmony export */   "TwoColorTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline; },
/* harmony export */   "VertexAttachment": function() { return /* reexport safe */ _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment; }
/* harmony export */ });
/* harmony import */ var _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _core_attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/attachments/BoundingBoxAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/BoundingBoxAttachment.mjs");
/* harmony import */ var _core_attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/attachments/ClippingAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/ClippingAttachment.mjs");
/* harmony import */ var _core_attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _core_attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _core_attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/attachments/PointAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/PointAttachment.mjs");
/* harmony import */ var _core_attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _core_vertexeffects_JitterEffect_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/vertexeffects/JitterEffect.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/JitterEffect.mjs");
/* harmony import */ var _core_vertexeffects_SwirlEffect_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/vertexeffects/SwirlEffect.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/vertexeffects/SwirlEffect.mjs");
/* harmony import */ var _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/Animation.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Animation.mjs");
/* harmony import */ var _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AnimationState.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationState.mjs");
/* harmony import */ var _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/AnimationStateData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AnimationStateData.mjs");
/* harmony import */ var _core_AtlasAttachmentLoader_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/AtlasAttachmentLoader.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/AtlasAttachmentLoader.mjs");
/* harmony import */ var _core_Bone_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/Bone.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Bone.mjs");
/* harmony import */ var _core_BoneData_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./core/BoneData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/BoneData.mjs");
/* harmony import */ var _core_Event_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./core/Event.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Event.mjs");
/* harmony import */ var _core_EventData_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./core/EventData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/EventData.mjs");
/* harmony import */ var _core_IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./core/IkConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraint.mjs");
/* harmony import */ var _core_IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./core/IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/IkConstraintData.mjs");
/* harmony import */ var _core_PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./core/PathConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraint.mjs");
/* harmony import */ var _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./core/PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/PathConstraintData.mjs");
/* harmony import */ var _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./core/Skeleton.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Skeleton.mjs");
/* harmony import */ var _core_SkeletonBounds_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./core/SkeletonBounds.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonBounds.mjs");
/* harmony import */ var _core_SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./core/SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonData.mjs");
/* harmony import */ var _core_SkeletonJson_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./core/SkeletonJson.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SkeletonJson.mjs");
/* harmony import */ var _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./core/Skin.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Skin.mjs");
/* harmony import */ var _core_Slot_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./core/Slot.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/Slot.mjs");
/* harmony import */ var _core_SlotData_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./core/SlotData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/SlotData.mjs");
/* harmony import */ var _core_TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./core/TransformConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraint.mjs");
/* harmony import */ var _core_TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./core/TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _Spine_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./Spine.mjs */ "./node_modules/@pixi-spine/runtime-3.7/lib/Spine.mjs");































//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/Spine.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/Spine.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spine": function() { return /* binding */ Spine; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/Skeleton.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Skeleton.mjs");
/* harmony import */ var _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/AnimationState.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationState.mjs");
/* harmony import */ var _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/AnimationStateData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationStateData.mjs");





class Spine extends _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_1__.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_3__.AnimationStateData(spineData);
    this.state = new _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_2__.AnimationState(this.stateData);
  }
}


//# sourceMappingURL=Spine.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Animation.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/Animation.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": function() { return /* binding */ Animation; },
/* harmony export */   "AttachmentTimeline": function() { return /* binding */ AttachmentTimeline; },
/* harmony export */   "ColorTimeline": function() { return /* binding */ ColorTimeline; },
/* harmony export */   "CurveTimeline": function() { return /* binding */ CurveTimeline; },
/* harmony export */   "DeformTimeline": function() { return /* binding */ DeformTimeline; },
/* harmony export */   "DrawOrderTimeline": function() { return /* binding */ DrawOrderTimeline; },
/* harmony export */   "EventTimeline": function() { return /* binding */ EventTimeline; },
/* harmony export */   "IkConstraintTimeline": function() { return /* binding */ IkConstraintTimeline; },
/* harmony export */   "PathConstraintMixTimeline": function() { return /* binding */ PathConstraintMixTimeline; },
/* harmony export */   "PathConstraintPositionTimeline": function() { return /* binding */ PathConstraintPositionTimeline; },
/* harmony export */   "PathConstraintSpacingTimeline": function() { return /* binding */ PathConstraintSpacingTimeline; },
/* harmony export */   "RotateTimeline": function() { return /* binding */ RotateTimeline; },
/* harmony export */   "ScaleTimeline": function() { return /* binding */ ScaleTimeline; },
/* harmony export */   "ShearTimeline": function() { return /* binding */ ShearTimeline; },
/* harmony export */   "TimelineType": function() { return /* binding */ TimelineType; },
/* harmony export */   "TransformConstraintTimeline": function() { return /* binding */ TransformConstraintTimeline; },
/* harmony export */   "TranslateTimeline": function() { return /* binding */ TranslateTimeline; },
/* harmony export */   "TwoColorTimeline": function() { return /* binding */ TwoColorTimeline; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs");




class Animation {
  constructor(name, timelines, duration) {
    if (name == null)
      throw new Error("name cannot be null.");
    if (timelines == null)
      throw new Error("timelines cannot be null.");
    this.name = name;
    this.timelines = timelines;
    this.timelineIds = [];
    for (let i = 0; i < timelines.length; i++)
      this.timelineIds[timelines[i].getPropertyId()] = true;
    this.duration = duration;
  }
  hasTimeline(id) {
    return this.timelineIds[id] == true;
  }
  /** Applies all the animation's timelines to the specified skeleton.
   *
   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
   * @param loop If true, the animation repeats after {@link #getDuration()}.
   * @param events May be null to ignore fired events. */
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
  /** @param target After the first and before the last value.
   * @returns index of first value greater than the target. */
  static binarySearch(values, target, step = 1) {
    let low = 0;
    let high = values.length / step - 2;
    if (high == 0)
      return step;
    let current = high >>> 1;
    while (true) {
      if (values[(current + 1) * step] <= target)
        low = current + 1;
      else
        high = current;
      if (low == high)
        return (low + 1) * step;
      current = low + high >>> 1;
    }
  }
  static linearSearch(values, target, step) {
    for (let i = 0, last = values.length - step; i <= last; i += step)
      if (values[i] > target)
        return i;
    return -1;
  }
}
var TimelineType = /* @__PURE__ */ ((TimelineType2) => {
  TimelineType2[TimelineType2["rotate"] = 0] = "rotate";
  TimelineType2[TimelineType2["translate"] = 1] = "translate";
  TimelineType2[TimelineType2["scale"] = 2] = "scale";
  TimelineType2[TimelineType2["shear"] = 3] = "shear";
  TimelineType2[TimelineType2["attachment"] = 4] = "attachment";
  TimelineType2[TimelineType2["color"] = 5] = "color";
  TimelineType2[TimelineType2["deform"] = 6] = "deform";
  TimelineType2[TimelineType2["event"] = 7] = "event";
  TimelineType2[TimelineType2["drawOrder"] = 8] = "drawOrder";
  TimelineType2[TimelineType2["ikConstraint"] = 9] = "ikConstraint";
  TimelineType2[TimelineType2["transformConstraint"] = 10] = "transformConstraint";
  TimelineType2[TimelineType2["pathConstraintPosition"] = 11] = "pathConstraintPosition";
  TimelineType2[TimelineType2["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
  TimelineType2[TimelineType2["pathConstraintMix"] = 13] = "pathConstraintMix";
  TimelineType2[TimelineType2["twoColor"] = 14] = "twoColor";
  return TimelineType2;
})(TimelineType || {});
const _CurveTimeline = class {
  constructor(frameCount) {
    if (frameCount <= 0)
      throw new Error(`frameCount must be > 0: ${frameCount}`);
    this.curves = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray((frameCount - 1) * _CurveTimeline.BEZIER_SIZE);
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.curves.length / _CurveTimeline.BEZIER_SIZE + 1;
  }
  /** Sets the specified key frame to linear interpolation. */
  setLinear(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.LINEAR;
  }
  /** Sets the specified key frame to stepped interpolation. */
  setStepped(frameIndex) {
    this.curves[frameIndex * _CurveTimeline.BEZIER_SIZE] = _CurveTimeline.STEPPED;
  }
  /** Returns the interpolation type for the specified key frame.
   * @returns Linear is 0, stepped is 1, Bezier is 2. */
  getCurveType(frameIndex) {
    const index = frameIndex * _CurveTimeline.BEZIER_SIZE;
    if (index == this.curves.length)
      return _CurveTimeline.LINEAR;
    const type = this.curves[index];
    if (type == _CurveTimeline.LINEAR)
      return _CurveTimeline.LINEAR;
    if (type == _CurveTimeline.STEPPED)
      return _CurveTimeline.STEPPED;
    return _CurveTimeline.BEZIER;
  }
  /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,
   * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the
   * difference between the key frame's values. */
  setCurve(frameIndex, cx1, cy1, cx2, cy2) {
    const tmpx = (-cx1 * 2 + cx2) * 0.03;
    const tmpy = (-cy1 * 2 + cy2) * 0.03;
    const dddfx = ((cx1 - cx2) * 3 + 1) * 6e-3;
    const dddfy = ((cy1 - cy2) * 3 + 1) * 6e-3;
    let ddfx = tmpx * 2 + dddfx;
    let ddfy = tmpy * 2 + dddfy;
    let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667;
    let dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const curves = this.curves;
    curves[i++] = _CurveTimeline.BEZIER;
    let x = dfx;
    let y = dfy;
    for (let n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      x += dfx;
      y += dfy;
    }
  }
  /** Returns the interpolated percentage for the specified key frame and linear percentage. */
  getCurvePercent(frameIndex, percent) {
    percent = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.clamp(percent, 0, 1);
    const curves = this.curves;
    let i = frameIndex * _CurveTimeline.BEZIER_SIZE;
    const type = curves[i];
    if (type == _CurveTimeline.LINEAR)
      return percent;
    if (type == _CurveTimeline.STEPPED)
      return 0;
    i++;
    let x = 0;
    for (let start = i, n = i + _CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
      x = curves[i];
      if (x >= percent) {
        let prevX;
        let prevY;
        if (i == start) {
          prevX = 0;
          prevY = 0;
        } else {
          prevX = curves[i - 2];
          prevY = curves[i - 1];
        }
        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
      }
    }
    const y = curves[i - 1];
    return y + (1 - y) * (percent - x) / (1 - x);
  }
};
let CurveTimeline = _CurveTimeline;
CurveTimeline.LINEAR = 0;
CurveTimeline.STEPPED = 1;
CurveTimeline.BEZIER = 2;
CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
const _RotateTimeline = class extends CurveTimeline {
  // time, degrees, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount << 1);
  }
  getPropertyId() {
    return (0 /* rotate */ << 24) + this.boneIndex;
  }
  /** Sets the time and angle of the specified keyframe. */
  setFrame(frameIndex, time, degrees) {
    frameIndex <<= 1;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _RotateTimeline.ROTATION] = degrees;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          const r2 = bone.data.rotation - bone.rotation;
          bone.rotation += (r2 - (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360) * alpha;
      }
      return;
    }
    if (time >= frames[frames.length - _RotateTimeline.ENTRIES]) {
      let r2 = frames[frames.length + _RotateTimeline.PREV_ROTATION];
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.rotation = bone.data.rotation + r2 * alpha;
          break;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
          r2 += bone.data.rotation - bone.rotation;
          r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
          bone.rotation += r2 * alpha;
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _RotateTimeline.ENTRIES);
    const prevRotation = frames[frame + _RotateTimeline.PREV_ROTATION];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _RotateTimeline.PREV_TIME] - frameTime));
    let r = frames[frame + _RotateTimeline.ROTATION] - prevRotation;
    r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
    }
  }
};
let RotateTimeline = _RotateTimeline;
RotateTimeline.ENTRIES = 2;
RotateTimeline.PREV_TIME = -2;
RotateTimeline.PREV_ROTATION = -1;
RotateTimeline.ROTATION = 1;
const _TranslateTimeline = class extends CurveTimeline {
  // time, x, y, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _TranslateTimeline.ENTRIES);
  }
  getPropertyId() {
    return (1 /* translate */ << 24) + this.boneIndex;
  }
  /** Sets the time in seconds, x, and y values for the specified key frame. */
  setFrame(frameIndex, time, x, y) {
    frameIndex *= _TranslateTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TranslateTimeline.X] = x;
    this.frames[frameIndex + _TranslateTimeline.Y] = y;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - _TranslateTimeline.ENTRIES]) {
      x = frames[frames.length + _TranslateTimeline.PREV_X];
      y = frames[frames.length + _TranslateTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, _TranslateTimeline.ENTRIES);
      x = frames[frame + _TranslateTimeline.PREV_X];
      y = frames[frame + _TranslateTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TranslateTimeline.PREV_TIME] - frameTime));
      x += (frames[frame + _TranslateTimeline.X] - x) * percent;
      y += (frames[frame + _TranslateTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
};
let TranslateTimeline = _TranslateTimeline;
TranslateTimeline.ENTRIES = 3;
TranslateTimeline.PREV_TIME = -3;
TranslateTimeline.PREV_X = -2;
TranslateTimeline.PREV_Y = -1;
TranslateTimeline.X = 1;
TranslateTimeline.Y = 2;
class ScaleTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (2 /* scale */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
      x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
      y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
    } else {
      const frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
      x = frames[frame + ScaleTimeline.PREV_X];
      y = frames[frame + ScaleTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
      x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
      y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
    }
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bone.data.scaleX) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bx = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
        }
      }
    }
  }
}
class ShearTimeline extends TranslateTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (3 /* shear */ << 24) + this.boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const frames = this.frames;
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
      x = frames[frames.length + ShearTimeline.PREV_X];
      y = frames[frames.length + ShearTimeline.PREV_Y];
    } else {
      const frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
      x = frames[frame + ShearTimeline.PREV_X];
      y = frames[frame + ShearTimeline.PREV_Y];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
      x = x + (frames[frame + ShearTimeline.X] - x) * percent;
      y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
    }
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
}
const _ColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _ColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (5 /* color */ << 24) + this.slotIndex;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frameIndex, time, r, g, b, a) {
    frameIndex *= _ColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _ColorTimeline.R] = r;
    this.frames[frameIndex + _ColorTimeline.G] = g;
    this.frames[frameIndex + _ColorTimeline.B] = b;
    this.frames[frameIndex + _ColorTimeline.A] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          const color = slot.color;
          const setup = slot.data.color;
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    if (time >= frames[frames.length - _ColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _ColorTimeline.PREV_R];
      g = frames[i + _ColorTimeline.PREV_G];
      b = frames[i + _ColorTimeline.PREV_B];
      a = frames[i + _ColorTimeline.PREV_A];
    } else {
      const frame = Animation.binarySearch(frames, time, _ColorTimeline.ENTRIES);
      r = frames[frame + _ColorTimeline.PREV_R];
      g = frames[frame + _ColorTimeline.PREV_G];
      b = frames[frame + _ColorTimeline.PREV_B];
      a = frames[frame + _ColorTimeline.PREV_A];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _ColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _ColorTimeline.R] - r) * percent;
      g += (frames[frame + _ColorTimeline.G] - g) * percent;
      b += (frames[frame + _ColorTimeline.B] - b) * percent;
      a += (frames[frame + _ColorTimeline.A] - a) * percent;
    }
    if (alpha == 1)
      slot.color.set(r, g, b, a);
    else {
      const color = slot.color;
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
};
let ColorTimeline = _ColorTimeline;
ColorTimeline.ENTRIES = 5;
ColorTimeline.PREV_TIME = -5;
ColorTimeline.PREV_R = -4;
ColorTimeline.PREV_G = -3;
ColorTimeline.PREV_B = -2;
ColorTimeline.PREV_A = -1;
ColorTimeline.R = 1;
ColorTimeline.G = 2;
ColorTimeline.B = 3;
ColorTimeline.A = 4;
const _TwoColorTimeline = class extends CurveTimeline {
  // time, r, g, b, a, r2, g2, b2, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _TwoColorTimeline.ENTRIES);
  }
  getPropertyId() {
    return (14 /* twoColor */ << 24) + this.slotIndex;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frameIndex, time, r, g, b, a, r2, g2, b2) {
    frameIndex *= _TwoColorTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TwoColorTimeline.R] = r;
    this.frames[frameIndex + _TwoColorTimeline.G] = g;
    this.frames[frameIndex + _TwoColorTimeline.B] = b;
    this.frames[frameIndex + _TwoColorTimeline.A] = a;
    this.frames[frameIndex + _TwoColorTimeline.R2] = r2;
    this.frames[frameIndex + _TwoColorTimeline.G2] = g2;
    this.frames[frameIndex + _TwoColorTimeline.B2] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          slot.color.setFromColor(slot.data.color);
          slot.darkColor.setFromColor(slot.data.darkColor);
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          const light = slot.color;
          const dark = slot.darkColor;
          const setupLight = slot.data.color;
          const setupDark = slot.data.darkColor;
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    if (time >= frames[frames.length - _TwoColorTimeline.ENTRIES]) {
      const i = frames.length;
      r = frames[i + _TwoColorTimeline.PREV_R];
      g = frames[i + _TwoColorTimeline.PREV_G];
      b = frames[i + _TwoColorTimeline.PREV_B];
      a = frames[i + _TwoColorTimeline.PREV_A];
      r2 = frames[i + _TwoColorTimeline.PREV_R2];
      g2 = frames[i + _TwoColorTimeline.PREV_G2];
      b2 = frames[i + _TwoColorTimeline.PREV_B2];
    } else {
      const frame = Animation.binarySearch(frames, time, _TwoColorTimeline.ENTRIES);
      r = frames[frame + _TwoColorTimeline.PREV_R];
      g = frames[frame + _TwoColorTimeline.PREV_G];
      b = frames[frame + _TwoColorTimeline.PREV_B];
      a = frames[frame + _TwoColorTimeline.PREV_A];
      r2 = frames[frame + _TwoColorTimeline.PREV_R2];
      g2 = frames[frame + _TwoColorTimeline.PREV_G2];
      b2 = frames[frame + _TwoColorTimeline.PREV_B2];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(frame / _TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _TwoColorTimeline.PREV_TIME] - frameTime));
      r += (frames[frame + _TwoColorTimeline.R] - r) * percent;
      g += (frames[frame + _TwoColorTimeline.G] - g) * percent;
      b += (frames[frame + _TwoColorTimeline.B] - b) * percent;
      a += (frames[frame + _TwoColorTimeline.A] - a) * percent;
      r2 += (frames[frame + _TwoColorTimeline.R2] - r2) * percent;
      g2 += (frames[frame + _TwoColorTimeline.G2] - g2) * percent;
      b2 += (frames[frame + _TwoColorTimeline.B2] - b2) * percent;
    }
    if (alpha == 1) {
      slot.color.set(r, g, b, a);
      slot.darkColor.set(r2, g2, b2, 1);
    } else {
      const light = slot.color;
      const dark = slot.darkColor;
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
        light.setFromColor(slot.data.color);
        dark.setFromColor(slot.data.darkColor);
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
    }
  }
};
let TwoColorTimeline = _TwoColorTimeline;
TwoColorTimeline.ENTRIES = 8;
TwoColorTimeline.PREV_TIME = -8;
TwoColorTimeline.PREV_R = -7;
TwoColorTimeline.PREV_G = -6;
TwoColorTimeline.PREV_B = -5;
TwoColorTimeline.PREV_A = -4;
TwoColorTimeline.PREV_R2 = -3;
TwoColorTimeline.PREV_G2 = -2;
TwoColorTimeline.PREV_B2 = -1;
TwoColorTimeline.R = 1;
TwoColorTimeline.G = 2;
TwoColorTimeline.B = 3;
TwoColorTimeline.A = 4;
TwoColorTimeline.R2 = 5;
TwoColorTimeline.G2 = 6;
TwoColorTimeline.B2 = 7;
class AttachmentTimeline {
  constructor(frameCount) {
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.attachmentNames = new Array(frameCount);
  }
  getPropertyId() {
    return (4 /* attachment */ << 24) + this.slotIndex;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the attachment name for the specified key frame. */
  setFrame(frameIndex, time, attachmentName) {
    this.frames[frameIndex] = time;
    this.attachmentNames[frameIndex] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    let frameIndex = 0;
    if (time >= frames[frames.length - 1])
      frameIndex = frames.length - 1;
    else
      frameIndex = Animation.binarySearch(frames, time, 1) - 1;
    const attachmentName = this.attachmentNames[frameIndex];
    skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
  setAttachment(skeleton, slot, attachmentName) {
    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
}
let zeros = null;
class DeformTimeline extends CurveTimeline {
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.frameVertices = new Array(frameCount);
    if (zeros == null)
      zeros = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(64);
  }
  getPropertyId() {
    return (6 /* deform */ << 27) + Number(this.attachment.id) + this.slotIndex;
  }
  /** Sets the time in seconds and the vertices for the specified key frame.
   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
  setFrame(frameIndex, time, vertices) {
    this.frames[frameIndex] = time;
    this.frameVertices[frameIndex] = vertices;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.getAttachment();
    if (!(slotAttachment instanceof _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment))
      return;
    const deformArray = slot.deform;
    if (deformArray.length == 0)
      blend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup;
    const frameVertices = this.frameVertices;
    const vertexCount = frameVertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      const vertexAttachment = slotAttachment;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          deformArray.length = 0;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          if (alpha == 1) {
            deformArray.length = 0;
            break;
          }
          const deform2 = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(deformArray, vertexCount);
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform2[i] += (setupVertices[i] - deform2[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              deform2[i] *= alpha;
          }
      }
      return;
    }
    const deform = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(deformArray, vertexCount);
    if (time >= frames[frames.length - 1]) {
      const lastVertices = frameVertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              deform[i] += lastVertices[i] - setupVertices[i];
            }
          } else {
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i];
          }
        } else {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
        }
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (vertexAttachment2.bones == null) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                deform[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (lastVertices[i] - deform[i]) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (vertexAttachment.bones == null) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++) {
                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time);
    const prevVertices = frameVertices[frame - 1];
    const nextVertices = frameVertices[frame];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (vertexAttachment.bones == null) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          deform[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (vertexAttachment2.bones == null) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;
          }
          break;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (vertexAttachment.bones == null) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
}
class EventTimeline {
  constructor(frameCount) {
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.events = new Array(frameCount);
  }
  getPropertyId() {
    return 7 /* event */ << 24;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the event for the specified key frame. */
  setFrame(frameIndex, event) {
    this.frames[frameIndex] = event.time;
    this.events[frameIndex] = event;
  }
  /** Fires events for frames > `lastTime` and <= `time`. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (firedEvents == null)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let frame = 0;
    if (lastTime < frames[0])
      frame = 0;
    else {
      frame = Animation.binarySearch(frames, lastTime);
      const frameTime = frames[frame];
      while (frame > 0) {
        if (frames[frame - 1] != frameTime)
          break;
        frame--;
      }
    }
    for (; frame < frameCount && time >= frames[frame]; frame++)
      firedEvents.push(this.events[frame]);
  }
}
class DrawOrderTimeline {
  constructor(frameCount) {
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount);
    this.drawOrders = new Array(frameCount);
  }
  getPropertyId() {
    return 8 /* drawOrder */ << 24;
  }
  /** The number of key frames for this timeline. */
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the draw order for the specified key frame.
   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
   *           draw order. */
  setFrame(frameIndex, time, drawOrder) {
    this.frames[frameIndex] = time;
    this.drawOrders[frameIndex] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const drawOrder = skeleton.drawOrder;
    const slots = skeleton.slots;
    if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut && blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    let frame = 0;
    if (time >= frames[frames.length - 1])
      frame = frames.length - 1;
    else
      frame = Animation.binarySearch(frames, time) - 1;
    const drawOrderToSetupIndex = this.drawOrders[frame];
    if (drawOrderToSetupIndex == null)
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
    else {
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
}
const _IkConstraintTimeline = class extends CurveTimeline {
  // time, mix, softness, bendDirection, compress, stretch, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _IkConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (9 /* ikConstraint */ << 24) + this.ikConstraintIndex;
  }
  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
  setFrame(frameIndex, time, mix, softness, bendDirection, compress, stretch) {
    frameIndex *= _IkConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _IkConstraintTimeline.MIX] = mix;
    this.frames[frameIndex + _IkConstraintTimeline.SOFTNESS] = softness;
    this.frames[frameIndex + _IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
    this.frames[frameIndex + _IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;
    this.frames[frameIndex + _IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.softness = constraint.data.softness;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    if (time >= frames[frames.length - _IkConstraintTimeline.ENTRIES]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
        constraint.mix = constraint.data.mix + (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
        constraint.softness = constraint.data.softness + (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;
        if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
        } else {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      } else {
        constraint.mix += (frames[frames.length + _IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
        constraint.softness += (frames[frames.length + _IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;
        if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixIn) {
          constraint.bendDirection = frames[frames.length + _IkConstraintTimeline.PREV_BEND_DIRECTION];
          constraint.compress = frames[frames.length + _IkConstraintTimeline.PREV_COMPRESS] != 0;
          constraint.stretch = frames[frames.length + _IkConstraintTimeline.PREV_STRETCH] != 0;
        }
      }
      return;
    }
    const frame = Animation.binarySearch(frames, time, _IkConstraintTimeline.ENTRIES);
    const mix = frames[frame + _IkConstraintTimeline.PREV_MIX];
    const softness = frames[frame + _IkConstraintTimeline.PREV_SOFTNESS];
    const frameTime = frames[frame];
    const percent = this.getCurvePercent(frame / _IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + _IkConstraintTimeline.PREV_TIME] - frameTime));
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
      constraint.softness = constraint.data.softness + (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    } else {
      constraint.mix += (mix + (frames[frame + _IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
      constraint.softness += (softness + (frames[frame + _IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixIn) {
        constraint.bendDirection = frames[frame + _IkConstraintTimeline.PREV_BEND_DIRECTION];
        constraint.compress = frames[frame + _IkConstraintTimeline.PREV_COMPRESS] != 0;
        constraint.stretch = frames[frame + _IkConstraintTimeline.PREV_STRETCH] != 0;
      }
    }
  }
};
let IkConstraintTimeline = _IkConstraintTimeline;
IkConstraintTimeline.ENTRIES = 6;
IkConstraintTimeline.PREV_TIME = -6;
IkConstraintTimeline.PREV_MIX = -5;
IkConstraintTimeline.PREV_SOFTNESS = -4;
IkConstraintTimeline.PREV_BEND_DIRECTION = -3;
IkConstraintTimeline.PREV_COMPRESS = -2;
IkConstraintTimeline.PREV_STRETCH = -1;
IkConstraintTimeline.MIX = 1;
IkConstraintTimeline.SOFTNESS = 2;
IkConstraintTimeline.BEND_DIRECTION = 3;
IkConstraintTimeline.COMPRESS = 4;
IkConstraintTimeline.STRETCH = 5;
const _TransformConstraintTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, scale mix, shear mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _TransformConstraintTimeline.ENTRIES);
  }
  getPropertyId() {
    return (10 /* transformConstraint */ << 24) + this.transformConstraintIndex;
  }
  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
  setFrame(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
    frameIndex *= _TransformConstraintTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _TransformConstraintTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.TRANSLATE] = translateMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SCALE] = scaleMix;
    this.frames[frameIndex + _TransformConstraintTimeline.SHEAR] = shearMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.rotateMix = data.rotateMix;
          constraint.translateMix = data.translateMix;
          constraint.scaleMix = data.scaleMix;
          constraint.shearMix = data.shearMix;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
          constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
          constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    let scale = 0;
    let shear = 0;
    if (time >= frames[frames.length - _TransformConstraintTimeline.ENTRIES]) {
      const i = frames.length;
      rotate = frames[i + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[i + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[i + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[i + _TransformConstraintTimeline.PREV_SHEAR];
    } else {
      const frame = Animation.binarySearch(frames, time, _TransformConstraintTimeline.ENTRIES);
      rotate = frames[frame + _TransformConstraintTimeline.PREV_ROTATE];
      translate = frames[frame + _TransformConstraintTimeline.PREV_TRANSLATE];
      scale = frames[frame + _TransformConstraintTimeline.PREV_SCALE];
      shear = frames[frame + _TransformConstraintTimeline.PREV_SHEAR];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _TransformConstraintTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _TransformConstraintTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _TransformConstraintTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _TransformConstraintTimeline.TRANSLATE] - translate) * percent;
      scale += (frames[frame + _TransformConstraintTimeline.SCALE] - scale) * percent;
      shear += (frames[frame + _TransformConstraintTimeline.SHEAR] - shear) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
      constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
      constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
      constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
      constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
      constraint.shearMix += (shear - constraint.shearMix) * alpha;
    }
  }
};
let TransformConstraintTimeline = _TransformConstraintTimeline;
TransformConstraintTimeline.ENTRIES = 5;
TransformConstraintTimeline.PREV_TIME = -5;
TransformConstraintTimeline.PREV_ROTATE = -4;
TransformConstraintTimeline.PREV_TRANSLATE = -3;
TransformConstraintTimeline.PREV_SCALE = -2;
TransformConstraintTimeline.PREV_SHEAR = -1;
TransformConstraintTimeline.ROTATE = 1;
TransformConstraintTimeline.TRANSLATE = 2;
TransformConstraintTimeline.SCALE = 3;
TransformConstraintTimeline.SHEAR = 4;
const _PathConstraintPositionTimeline = class extends CurveTimeline {
  // time, position, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _PathConstraintPositionTimeline.ENTRIES);
  }
  getPropertyId() {
    return (11 /* pathConstraintPosition */ << 24) + this.pathConstraintIndex;
  }
  /** Sets the time in seconds and path constraint position for the specified key frame. */
  setFrame(frameIndex, time, value) {
    frameIndex *= _PathConstraintPositionTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintPositionTimeline.VALUE] = value;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    let position = 0;
    if (time >= frames[frames.length - _PathConstraintPositionTimeline.ENTRIES])
      position = frames[frames.length + _PathConstraintPositionTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintPositionTimeline.ENTRIES);
      position = frames[frame + _PathConstraintPositionTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintPositionTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintPositionTimeline.PREV_TIME] - frameTime)
      );
      position += (frames[frame + _PathConstraintPositionTimeline.VALUE] - position) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
};
let PathConstraintPositionTimeline = _PathConstraintPositionTimeline;
PathConstraintPositionTimeline.ENTRIES = 2;
PathConstraintPositionTimeline.PREV_TIME = -2;
PathConstraintPositionTimeline.PREV_VALUE = -1;
PathConstraintPositionTimeline.VALUE = 1;
class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {
  constructor(frameCount) {
    super(frameCount);
  }
  getPropertyId() {
    return (12 /* pathConstraintSpacing */ << 24) + this.pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    let spacing = 0;
    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])
      spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
    else {
      const frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
      spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / PathConstraintSpacingTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime)
      );
      spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
}
const _PathConstraintMixTimeline = class extends CurveTimeline {
  // time, rotate mix, translate mix, ...
  constructor(frameCount) {
    super(frameCount);
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * _PathConstraintMixTimeline.ENTRIES);
  }
  getPropertyId() {
    return (13 /* pathConstraintMix */ << 24) + this.pathConstraintIndex;
  }
  /** The time in seconds, rotate mix, and translate mix for the specified key frame. */
  setFrame(frameIndex, time, rotateMix, translateMix) {
    frameIndex *= _PathConstraintMixTimeline.ENTRIES;
    this.frames[frameIndex] = time;
    this.frames[frameIndex + _PathConstraintMixTimeline.ROTATE] = rotateMix;
    this.frames[frameIndex + _PathConstraintMixTimeline.TRANSLATE] = translateMix;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const frames = this.frames;
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.rotateMix = constraint.data.rotateMix;
          constraint.translateMix = constraint.data.translateMix;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
          constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
      }
      return;
    }
    let rotate = 0;
    let translate = 0;
    if (time >= frames[frames.length - _PathConstraintMixTimeline.ENTRIES]) {
      rotate = frames[frames.length + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frames.length + _PathConstraintMixTimeline.PREV_TRANSLATE];
    } else {
      const frame = Animation.binarySearch(frames, time, _PathConstraintMixTimeline.ENTRIES);
      rotate = frames[frame + _PathConstraintMixTimeline.PREV_ROTATE];
      translate = frames[frame + _PathConstraintMixTimeline.PREV_TRANSLATE];
      const frameTime = frames[frame];
      const percent = this.getCurvePercent(
        frame / _PathConstraintMixTimeline.ENTRIES - 1,
        1 - (time - frameTime) / (frames[frame + _PathConstraintMixTimeline.PREV_TIME] - frameTime)
      );
      rotate += (frames[frame + _PathConstraintMixTimeline.ROTATE] - rotate) * percent;
      translate += (frames[frame + _PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
      constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
    } else {
      constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
      constraint.translateMix += (translate - constraint.translateMix) * alpha;
    }
  }
};
let PathConstraintMixTimeline = _PathConstraintMixTimeline;
PathConstraintMixTimeline.ENTRIES = 3;
PathConstraintMixTimeline.PREV_TIME = -3;
PathConstraintMixTimeline.PREV_ROTATE = -2;
PathConstraintMixTimeline.PREV_TRANSLATE = -1;
PathConstraintMixTimeline.ROTATE = 1;
PathConstraintMixTimeline.TRANSLATE = 2;


//# sourceMappingURL=Animation.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationState.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationState.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationState": function() { return /* binding */ AnimationState; },
/* harmony export */   "AnimationStateAdapter": function() { return /* binding */ AnimationStateAdapter; },
/* harmony export */   "EventQueue": function() { return /* binding */ EventQueue; },
/* harmony export */   "EventType": function() { return /* binding */ EventType; },
/* harmony export */   "TrackEntry": function() { return /* binding */ TrackEntry; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Animation.mjs");



const _AnimationState = class {
  constructor(data) {
    /** The list of tracks that currently have animations, which may contain null entries. */
    this.tracks = new Array();
    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
     * or faster. Defaults to 1.
     *
     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */
    this.timeScale = 1;
    this.unkeyedState = 0;
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.IntSet();
    this.animationsChanged = false;
    this.trackEntryPool = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Pool(() => new TrackEntry());
    this.data = data;
  }
  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next != null) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom != null) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
        tracks[i] = null;
        this.queue.end(current);
        this.disposeNext(current);
        continue;
      }
      if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from != null)
          from.mixingTo = null;
        while (from != null) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  /** Returns true when all mixing from entries are complete. */
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (from == null)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom != null)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
   * animation state can be applied to multiple skeletons to pose them identically.
   * @returns True if any animations were applied. */
  apply(skeleton) {
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (current == null || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom != null)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && current.next == null)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      const timelineCount = current.animation.timelines.length;
      const timelines = current.animation.timelines;
      if (i == 0 && mix == 1 || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(mix, blend);
          const timeline = timelines[ii];
          if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
          else
            timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const firstFrame = current.timelinesRotation.length == 0;
        if (firstFrame)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
        const timelinesRotation = current.timelinesRotation;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == _AnimationState.SUBSEQUENT ? blend : _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
          if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
          } else if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline) {
            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);
          } else {
            _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    const setupState = this.unkeyedState + _AnimationState.SETUP;
    const slots = skeleton.slots;
    for (let i = 0, n = skeleton.slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.attachmentState == setupState) {
        const attachmentName = slot.data.attachmentName;
        slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      }
    }
    this.unkeyedState += 2;
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom != null)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        blend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        blend = from.mixBlend;
    }
    const events = mix < from.eventThreshold ? this.events : null;
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    const timelineCount = from.animation.timelines.length;
    const timelines = from.animation.timelines;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const firstFrame = from.timelinesRotation.length == 0;
      if (firstFrame)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
      const timelinesRotation = from.timelinesRotation;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case _AnimationState.SUBSEQUENT:
            if (!drawOrder && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case _AnimationState.FIRST:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            alpha = alphaMix;
            break;
          case _AnimationState.HOLD_SUBSEQUENT:
            timelineBlend = blend;
            alpha = alphaHold;
            break;
          case _AnimationState.HOLD_FIRST:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
        else if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline)
          this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);
        else {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(alpha, blend);
          if (drawOrder && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline && timelineBlend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup)
            direction = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn;
          timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {
    const slot = skeleton.slots[timeline.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = timeline.frames;
    if (time < frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
    } else {
      let frameIndex;
      if (time >= frames[frames.length - 1])
        frameIndex = frames.length - 1;
      else
        frameIndex = _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.Animation.binarySearch(frames, time) - 1;
      this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);
    }
    if (slot.attachmentState <= this.unkeyedState)
      slot.attachmentState = this.unkeyedState + _AnimationState.SETUP;
  }
  setAttachment(skeleton, slot, attachmentName, attachments) {
    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));
    if (attachments)
      slot.attachmentState = this.unkeyedState + _AnimationState.CURRENT;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
      return;
    }
    const rotateTimeline = timeline;
    const frames = rotateTimeline.frames;
    const bone = skeleton.bones[rotateTimeline.boneIndex];
    if (!bone.active)
      return;
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup ? bone.data.rotation : bone.rotation;
      if (time >= frames[frames.length - _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.ENTRIES])
        r2 = bone.data.rotation + frames[frames.length + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.PREV_ROTATION];
      else {
        const frame = _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.Animation.binarySearch(frames, time, _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.ENTRIES);
        const prevRotation = frames[frame + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.PREV_ROTATION];
        const frameTime = frames[frame];
        const percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.PREV_TIME] - frameTime));
        r2 = frames[frame + _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline.ROTATION] - prevRotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
        r2 = prevRotation + r2 * percent + bone.data.rotation;
        r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
      }
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastDiff) != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    r1 += total * alpha;
    bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, events[i]);
    }
  }
  /** Removes all animations from all tracks, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  /** Removes all animations from the track, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (current == null)
      return;
    this.queue.end(current);
    this.disposeNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (from == null)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    if (from != null) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom != null && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  /** Sets an animation by name.
   *
   * {@link #setAnimationWith(}. */
  setAnimation(trackIndex, animationName, loop) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
   * applied to a skeleton, it is replaced (not mixed from).
   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  setAnimationWith(trackIndex, animation, loop) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current != null) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.disposeNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.disposeNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  /** Queues an animation by name.
   *
   * See {@link #addAnimationWith()}. */
  addAnimation(trackIndex, animationName, loop, delay) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (animation == null)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
   * equivalent to calling {@link #setAnimationWith()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
   *           previous entry is looping, its next loop completion is used instead of its duration.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addAnimationWith(trackIndex, animation, loop, delay) {
    if (animation == null)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last != null) {
      while (last.next != null)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (last == null) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      if (delay <= 0) {
        const duration = last.animationEnd - last.animationStart;
        if (duration != 0) {
          if (last.loop)
            delay += duration * (1 + (last.trackTime / duration | 0));
          else
            delay += Math.max(duration, last.trackTime);
          delay -= this.data.getMix(last.animation, animation);
        } else
          delay = last.trackTime;
      }
    }
    entry.delay = delay;
    return entry;
  }
  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
   *
   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
   * 0 still mixes out over one frame.
   *
   * Mixing in is done by first setting an empty animation, then adding an animation using
   * {@link #addAnimation()} and on the returned track entry, set the
   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
  setEmptyAnimation(trackIndex, mixDuration) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation, false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
   * {@link #setEmptyAnimation()}.
   *
   * See {@link #setEmptyAnimation()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
   *           loop completion is used instead of its duration.
   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addEmptyAnimation(trackIndex, mixDuration, delay) {
    if (delay <= 0)
      delay -= mixDuration;
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation, false, delay);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
   * duration. */
  setEmptyAnimations(mixDuration) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current != null)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.ensureArrayCapacity(this.tracks, index + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  /** @param last May be null. */
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.interruptAlpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
    entry.mixBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.replace;
    return entry;
  }
  disposeNext(entry) {
    let next = entry.next;
    while (next != null) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      let entry = this.tracks[i];
      if (entry == null)
        continue;
      while (entry.mixingFrom != null)
        entry = entry.mixingFrom;
      do {
        if (entry.mixingFrom == null || entry.mixBlend != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add)
          this.computeHold(entry);
        entry = entry.mixingTo;
      } while (entry != null);
    }
  }
  computeHold(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(entry.timelineMode, timelinesCount);
    entry.timelineHoldMix.length = 0;
    const timelineDipMix = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
    const propertyIDs = this.propertyIDs;
    if (to != null && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++) {
        timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? _AnimationState.HOLD_FIRST : _AnimationState.HOLD_SUBSEQUENT;
      }
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const timeline = timelines[i];
        const id = timeline.getPropertyId();
        if (!propertyIDs.add(id))
          timelineMode[i] = _AnimationState.SUBSEQUENT;
        else if (to == null || timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline || timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline || timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.EventTimeline || !to.animation.hasTimeline(id)) {
          timelineMode[i] = _AnimationState.FIRST;
        } else {
          for (let next = to.mixingTo; next != null; next = next.mixingTo) {
            if (next.animation.hasTimeline(id))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = _AnimationState.HOLD_MIX;
              timelineDipMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = _AnimationState.HOLD_FIRST;
        }
      }
  }
  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  /** Adds a listener to receive events for all track entries. */
  addListener(listener) {
    if (listener == null)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener()}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  /** Removes all listeners added with {@link #addListener()}. */
  clearListeners() {
    this.listeners.length = 0;
  }
  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
   * are not wanted because new animations are being set. */
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
let AnimationState = _AnimationState;
AnimationState.emptyAnimation = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.Animation("<empty>", [], 0);
/** 1. A previously applied timeline has set this property.
 *
 * Result: Mix from the current pose to the timeline pose. */
AnimationState.SUBSEQUENT = 0;
/** 1. This is the first timeline to set this property.
 * 2. The next track entry applied after this one does not have a timeline to set this property.
 *
 * Result: Mix from the setup pose to the timeline pose. */
AnimationState.FIRST = 1;
/** 1) A previously applied timeline has set this property.<br>
 * 2) The next track entry to be applied does have a timeline to set this property.<br>
 * 3) The next track entry after that one does not have a timeline to set this property.<br>
 * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids "dipping" when crossfading
 * animations that key the same property. A subsequent timeline will set this property using a mix. */
AnimationState.HOLD_SUBSEQUENT = 2;
/** 1) This is the first timeline to set this property.<br>
 * 2) The next track entry to be applied does have a timeline to set this property.<br>
 * 3) The next track entry after that one does not have a timeline to set this property.<br>
 * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids "dipping" when crossfading animations
 * that key the same property. A subsequent timeline will set this property using a mix. */
AnimationState.HOLD_FIRST = 3;
/** 1. This is the first timeline to set this property.
 * 2. The next track entry to be applied does have a timeline to set this property.
 * 3. The next track entry after that one does have a timeline to set this property.
 * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.
 *
 * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than
 * 2 track entries in a row have a timeline that sets the same property.
 *
 * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid
 * "dipping" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A
 * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into
 * place. */
AnimationState.HOLD_MIX = 4;
AnimationState.SETUP = 1;
AnimationState.CURRENT = 2;
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
const _TrackEntry = class {
  constructor() {
    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which
     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to
     * the values from the lower tracks.
     *
     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first
     * called. */
    this.mixBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
   * `animationStart` time. */
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  /** Returns true if at least one loop has been completed.
   *
   * See {@link AnimationStateListener#complete()}. */
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
   * long way around when using {@link #alpha} and starting animations on other tracks.
   *
   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
let TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
const _EventQueue = class {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  deprecateStuff() {
    if (!_EventQueue.deprecatedWarning1) {
      _EventQueue.deprecatedWarning1 = true;
      console.warn(
        "Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'"
      );
    }
    return true;
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener != null && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].start)
              listeners[ii].start(entry);
          entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);
          this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);
          break;
        case EventType.interrupt:
          if (entry.listener != null && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].interrupt)
              listeners[ii].interrupt(entry);
          break;
        case EventType.end:
          if (entry.listener != null && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].end)
              listeners[ii].end(entry);
          entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);
          this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);
        case EventType.dispose:
          if (entry.listener != null && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].dispose)
              listeners[ii].dispose(entry);
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener != null && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].complete)
              listeners[ii].complete(entry);
          const count = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.toInt(entry.loopsCount());
          entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);
          this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener != null && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++)
            if (listeners[ii].event)
              listeners[ii].event(entry, event);
          entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);
          this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
};
let EventQueue = _EventQueue;
EventQueue.deprecatedWarning1 = false;
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
  return EventType2;
})(EventType || {});
class AnimationStateAdapter {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
}


//# sourceMappingURL=AnimationState.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationStateData.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationStateData.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationStateData": function() { return /* binding */ AnimationStateData; }
/* harmony export */ });
const _AnimationStateData = class {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    this.defaultMix = 0;
    if (skeletonData == null)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (from == null)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (to == null)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  setMixByName(fromName, toName, duration) {
    if (!_AnimationStateData.deprecatedWarning1) {
      _AnimationStateData.deprecatedWarning1 = true;
      console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.");
    }
    this.setMix(fromName, toName, duration);
  }
  setMixWith(from, to, duration) {
    if (from == null)
      throw new Error("from cannot be null.");
    if (to == null)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
};
let AnimationStateData = _AnimationStateData;
AnimationStateData.deprecatedWarning1 = false;


//# sourceMappingURL=AnimationStateData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AtlasAttachmentLoader.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/AtlasAttachmentLoader.mjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AtlasAttachmentLoader": function() { return /* binding */ AtlasAttachmentLoader; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attachments/BoundingBoxAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/BoundingBoxAttachment.mjs");
/* harmony import */ var _attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/ClippingAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/ClippingAttachment.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./attachments/PointAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PointAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs");








class AtlasAttachmentLoader {
  constructor(atlas) {
    this.atlas = atlas;
  }
  /** @return May be null to not load an attachment. */
  newRegionAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
    const attachment = new _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__.RegionAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newMeshAttachment(skin, name, path) {
    const region = this.atlas.findRegion(path);
    if (region == null)
      throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
    const attachment = new _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.MeshAttachment(name);
    attachment.region = region;
    return attachment;
  }
  /** @return May be null to not load an attachment. */
  newBoundingBoxAttachment(skin, name) {
    return new _attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__.BoundingBoxAttachment(name);
  }
  /** @return May be null to not load an attachment */
  newPathAttachment(skin, name) {
    return new _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new _attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__.PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new _attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.ClippingAttachment(name);
  }
}


//# sourceMappingURL=AtlasAttachmentLoader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Bone.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/Bone.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bone": function() { return /* binding */ Bone; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class Bone {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    // be careful! Spine b,c is c,b in pixi matrix
    this.matrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.children = new Array();
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 0;
    this.scaleY = 0;
    this.shearX = 0;
    this.shearY = 0;
    this.ax = 0;
    this.ay = 0;
    this.arotation = 0;
    this.ascaleX = 0;
    this.ascaleY = 0;
    this.ashearX = 0;
    this.ashearY = 0;
    this.appliedValid = false;
    this.sorted = false;
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  isActive() {
    return this.active;
  }
  /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */
  update() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (parent == null) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY;
        m.b = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pa /= this.skeleton.scaleX;
          pc /= this.skeleton.scaleY;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rx) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(ry) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rx) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScale:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScaleOrReflection: {
        const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation);
        const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScale && pa * pd - pb * pc < 0 != (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.settings.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(shearX) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(shearX) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.c * m.c);
  }
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.b * m.b + m.d * m.d);
  }
  /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using
   * the applied transform after the world transform has been modified directly (eg, by a constraint).
   * <p>
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */
  updateAppliedTransform() {
    this.appliedValid = true;
    const parent = this.parent;
    const m = this.matrix;
    if (parent == null) {
      this.ax = m.tx;
      this.ay = m.ty;
      this.arotation = Math.atan2(m.b, m.a) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
    }
  }
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  worldToLocalRotation(worldRotation) {
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(worldRotation);
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  localToWorldRotation(localRotation) {
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(localRotation);
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(degrees);
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
    this.appliedValid = false;
  }
}


//# sourceMappingURL=Bone.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/BoneData.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/BoneData.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoneData": function() { return /* binding */ BoneData; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class BoneData {
  constructor(index, name, parent) {
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.shearX = 0;
    this.shearY = 0;
    this.transformMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.Normal;
    this.skinRequired = false;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
}


//# sourceMappingURL=BoneData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Constraint.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/Constraint.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstraintData": function() { return /* binding */ ConstraintData; }
/* harmony export */ });
class ConstraintData {
  constructor(name, order, skinRequired) {
    this.name = name;
    this.order = order;
    this.skinRequired = skinRequired;
  }
}


//# sourceMappingURL=Constraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Event.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/Event.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": function() { return /* binding */ Event; }
/* harmony export */ });
class Event {
  constructor(time, data) {
    if (data == null)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
}


//# sourceMappingURL=Event.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/EventData.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/EventData.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventData": function() { return /* binding */ EventData; }
/* harmony export */ });
class EventData {
  constructor(name) {
    this.name = name;
  }
}


//# sourceMappingURL=EventData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraint.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraint.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IkConstraint": function() { return /* binding */ IkConstraint; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class IkConstraint {
  constructor(data, skeleton) {
    this.bendDirection = 0;
    this.compress = false;
    this.stretch = false;
    this.mix = 1;
    this.softness = 0;
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.softness = data.softness;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
        break;
    }
  }
  /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world
   * coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    if (!bone.appliedValid)
      bone.updateAppliedTransform();
    const p = bone.parent.matrix;
    const pa = p.a;
    let pb = p.c;
    const pc = p.b;
    let pd = p.d;
    let rotationIK = -bone.ashearX - bone.arotation;
    let tx = 0;
    let ty = 0;
    switch (bone.data.transformMode) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.OnlyTranslation:
        tx = targetX - bone.worldX;
        ty = targetY - bone.worldY;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.NoRotationOrReflection:
        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
        const sa = pa / bone.skeleton.scaleX;
        const sc = pc / bone.skeleton.scaleY;
        pb = -sc * s * bone.skeleton.scaleX;
        pd = sa * s * bone.skeleton.scaleY;
        rotationIK += Math.atan2(sc, sa) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg;
      default:
        const x = targetX - p.tx;
        const y = targetY - p.ty;
        const d = pa * pd - pb * pc;
        tx = (x * pd - y * pb) / d - bone.ax;
        ty = (y * pa - x * pc) / d - bone.ay;
    }
    rotationIK += Math.atan2(ty, tx) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      switch (bone.data.transformMode) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.NoScale:
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.NoScaleOrReflection:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
      }
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The
   * target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
    if (alpha == 0) {
      child.updateWorldTransform();
      return;
    }
    if (!parent.appliedValid)
      parent.updateAppliedTransform();
    if (!child.appliedValid)
      child.updateAppliedTransform();
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let sx = psx;
    let psy = parent.ascaleY;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = cwx - pp.tx;
    let y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1;
    let a2;
    if (l1 < 1e-4) {
      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
      return;
    }
    x = targetX - pp.tx;
    y = targetY - pp.ty;
    let tx = (x * d - y * b) * id - px;
    let ty = (y * a - x * c) * id - py;
    let dd = tx * tx + ty * ty;
    if (softness != 0) {
      softness *= psx * (csx + 1) / 2;
      const td = Math.sqrt(dd);
      const sd = td - l1 - l2 * psx + softness;
      if (sd > 0) {
        let p = Math.min(1, sd / (softness * 2)) - 1;
        p = (sd - softness * (1 - p * p)) / td;
        tx -= p * tx;
        ty -= p * ty;
        dd = tx * tx + ty * ty;
      }
    }
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1)
          cos = -1;
        else if (cos > 1) {
          cos = 1;
          if (stretch)
            sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
        }
        a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) / 2;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) / 2) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
}


//# sourceMappingURL=IkConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraintData.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraintData.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IkConstraintData": function() { return /* binding */ IkConstraintData; }
/* harmony export */ });
/* harmony import */ var _Constraint_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Constraint.mjs");


class IkConstraintData extends _Constraint_mjs__WEBPACK_IMPORTED_MODULE_0__.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this.bendDirection = 1;
    this.compress = false;
    this.stretch = false;
    this.uniform = false;
    this.mix = 1;
    this.softness = 0;
  }
}


//# sourceMappingURL=IkConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraint.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraint.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathConstraint": function() { return /* binding */ PathConstraint; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraintData.mjs");






const _PathConstraint = class {
  constructor(data, skeleton) {
    this.position = 0;
    this.spacing = 0;
    this.rotateMix = 0;
    this.translateMix = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findSlot(data.target.name);
    this.position = data.position;
    this.spacing = data.spacing;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.PathAttachment))
      return;
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const translate = translateMix > 0;
    const rotate = rotateMix > 0;
    if (!translate && !rotate)
      return;
    const data = this.data;
    const spacingMode = data.spacingMode;
    const lengthSpacing = spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__.SpacingMode.Length;
    const rotateMode = data.rotateMode;
    const tangents = rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.Tangent;
    const scale = rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.ChainScale;
    const boneCount = this.bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const bones = this.bones;
    const spaces = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.spaces, spacesCount);
    let lengths = null;
    const spacing = this.spacing;
    if (scale || lengthSpacing) {
      if (scale)
        lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.lengths, boneCount);
      for (let i = 0, n = spacesCount - 1; i < n; ) {
        const bone = bones[i];
        const setupLength = bone.data.length;
        if (setupLength < _PathConstraint.epsilon) {
          if (scale)
            lengths[i] = 0;
          spaces[++i] = 0;
        } else {
          const x = setupLength * bone.matrix.a;
          const y = setupLength * bone.matrix.b;
          const length = Math.sqrt(x * x + y * y);
          if (scale)
            lengths[i] = length;
          spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
        }
      }
    } else {
      for (let i = 1; i < spacesCount; i++)
        spaces[i] = spacing;
    }
    const positions = this.computeWorldPositions(
      attachment,
      spacesCount,
      tangents,
      data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.PositionMode.Percent,
      spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__.SpacingMode.Percent
    );
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * translateMix;
      mat.ty += (boneY - mat.ty) * translateMix;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (rotate) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          if (tangents)
            r = positions[p - 1];
          else if (spaces[i + 1] == 0)
            r = positions[p + 2];
          else
            r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * rotateMix;
          boneY += (length * (sin * a + cos * c) - dy) * rotateMix;
        } else {
          r += offsetRotation;
        }
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI2;
        r *= rotateMix;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.appliedValid = false;
    }
  }
  computeWorldPositions(path, spacesCount, tangents, percentPosition, percentSpacing) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = null;
    const closed = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (percentPosition)
        position *= pathLength2;
      if (percentSpacing) {
        for (let i = 0; i < spacesCount; i++)
          spaces[i] *= pathLength2;
      }
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i];
        position += space;
        let p = position;
        if (closed) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed) {
      verticesLength += 2;
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (percentPosition)
      position *= pathLength;
    if (percentSpacing) {
      for (let i = 0; i < spacesCount; i++)
        spaces[i] *= pathLength;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i];
      position += space;
      let p = position;
      if (closed) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p))
      p = 1e-4;
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents)
      out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
  }
};
let PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;


//# sourceMappingURL=PathConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraintData.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraintData.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathConstraintData": function() { return /* binding */ PathConstraintData; },
/* harmony export */   "SpacingMode": function() { return /* binding */ SpacingMode; }
/* harmony export */ });
/* harmony import */ var _Constraint_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Constraint.mjs");


class PathConstraintData extends _Constraint_mjs__WEBPACK_IMPORTED_MODULE_0__.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
  }
}
var SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  return SpacingMode2;
})(SpacingMode || {});


//# sourceMappingURL=PathConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Skeleton.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/Skeleton.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Skeleton": function() { return /* binding */ Skeleton; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _Bone_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bone.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Bone.mjs");
/* harmony import */ var _Slot_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Slot.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Slot.mjs");
/* harmony import */ var _IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IkConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraint.mjs");
/* harmony import */ var _TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TransformConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraint.mjs");
/* harmony import */ var _PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PathConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraint.mjs");











const _Skeleton = class {
  constructor(data) {
    this._updateCache = new Array();
    this.updateCacheReset = new Array();
    this.time = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.x = 0;
    this.y = 0;
    if (data == null)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (boneData.parent == null)
        bone = new _Bone_mjs__WEBPACK_IMPORTED_MODULE_5__.Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new _Bone_mjs__WEBPACK_IMPORTED_MODULE_5__.Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new _Slot_mjs__WEBPACK_IMPORTED_MODULE_6__.Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new _IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_7__.IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new _TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_8__.TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new _PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraint(pathConstraintData, this));
    }
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.updateCache();
  }
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    this.updateCacheReset.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.sorted = bone.data.skinRequired;
      bone.active = !bone.sorted;
    }
    if (this.skin != null) {
      const skinBones = this.skin.bones;
      for (let i = 0, n = this.skin.bones.length; i < n; i++) {
        let bone = this.bones[skinBones[i].index];
        do {
          bone.sorted = false;
          bone.active = true;
          bone = bone.parent;
        } while (bone != null);
      }
    }
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length > 1) {
      const child = constrained[constrained.length - 1];
      if (!(this._updateCache.indexOf(child) > -1))
        this.updateCacheReset.push(child);
    }
    this._updateCache.push(constraint);
    this.sortReset(parent.children);
    constrained[constrained.length - 1].sorted = true;
  }
  sortPathConstraint(constraint) {
    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin != null)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        if (!(this._updateCache.indexOf(child) > -1))
          this.updateCacheReset.push(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let ii = 0; ii < boneCount; ii++)
      this.sortReset(constrained[ii].children);
    for (let ii = 0; ii < boneCount; ii++)
      constrained[ii].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (pathBones == null)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      let i = 0;
      while (i < pathBones.length) {
        const boneCount = pathBones[i++];
        for (let n = i + boneCount; i < n; i++) {
          const boneIndex = pathBones[i];
          this.sortBone(bones[boneIndex]);
        }
      }
    }
  }
  sortBone(bone) {
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent != null)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.active)
        continue;
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies constraints. */
  updateWorldTransform() {
    const updateCacheReset = this.updateCacheReset;
    for (let i = 0, n = updateCacheReset.length; i < n; i++) {
      const bone = updateCacheReset[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
      bone.appliedValid = true;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.mix = constraint.data.mix;
      constraint.softness = constraint.data.softness;
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.compress = constraint.data.compress;
      constraint.stretch = constraint.data.stretch;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
      constraint.scaleMix = data.scaleMix;
      constraint.shearMix = data.shearMix;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.rotateMix = data.rotateMix;
      constraint.translateMix = data.translateMix;
    }
  }
  setSlotsToSetupPose() {
    const slots = this.slots;
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @return May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @return May be null. */
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** @return May be null. */
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @return -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   * @see #setSkin(Skin) */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (skin == null)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin == this.skin)
      return;
    if (newSkin != null) {
      if (this.skin != null)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name != null) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment != null)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
    this.updateCache();
  }
  /** @return May be null. */
  getAttachmentByName(slotName, attachmentName) {
    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
  }
  /** @return May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (attachmentName == null)
      throw new Error("attachmentName cannot be null.");
    if (this.skin != null) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment != null)
        return attachment;
    }
    if (this.data.defaultSkin != null)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** @param attachmentName May be null. */
  setAttachment(slotName, attachmentName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName != null) {
          attachment = this.getAttachment(i, attachmentName);
          if (attachment == null)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** @return May be null. */
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** @return May be null. */
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** @return May be null. */
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size The width and height of the AABB.
   * @param temp Working memory */
  getBounds(offset, size, temp = new Array(2)) {
    if (offset == null)
      throw new Error("offset cannot be null.");
    if (size == null)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      if (!slot.bone.active)
        continue;
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.RegionAttachment) {
        verticesLength = 8;
        vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
      } else if (attachment instanceof _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices != null) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  update(delta) {
    this.time += delta;
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
let Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;


//# sourceMappingURL=Skeleton.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBinary.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBinary.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonBinary": function() { return /* binding */ SkeletonBinary; }
/* harmony export */ });
/* harmony import */ var _Event_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Event.mjs");
/* harmony import */ var _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonData.mjs");
/* harmony import */ var _SlotData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SlotData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SlotData.mjs");
/* harmony import */ var _BoneData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BoneData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/BoneData.mjs");
/* harmony import */ var _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraintData.mjs");
/* harmony import */ var _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraintData.mjs");
/* harmony import */ var _Skin_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Skin.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Skin.mjs");
/* harmony import */ var _EventData_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EventData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/EventData.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Animation.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");













const _SkeletonBinary = class {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(binary) {
    const scale = this.scale;
    const skeletonData = new _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_1__.SkeletonData();
    skeletonData.name = "";
    const input = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.BinaryInput(binary);
    skeletonData.hash = input.readString();
    skeletonData.version = input.readString();
    if (skeletonData.version === "3.8.75") {
      const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;
      console.error(error);
    }
    skeletonData.x = input.readFloat();
    skeletonData.y = input.readFloat();
    skeletonData.width = input.readFloat();
    skeletonData.height = input.readFloat();
    const nonessential = input.readBoolean();
    if (nonessential) {
      skeletonData.fps = input.readFloat();
      skeletonData.imagesPath = input.readString();
      skeletonData.audioPath = input.readString();
    }
    let n = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++)
      input.strings.push(input.readString());
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const name = input.readString();
      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];
      const data = new _BoneData_mjs__WEBPACK_IMPORTED_MODULE_3__.BoneData(i, name, parent);
      data.rotation = input.readFloat();
      data.x = input.readFloat() * scale;
      data.y = input.readFloat() * scale;
      data.scaleX = input.readFloat();
      data.scaleY = input.readFloat();
      data.shearX = input.readFloat();
      data.shearY = input.readFloat();
      data.length = input.readFloat() * scale;
      data.transformMode = _SkeletonBinary.TransformModeValues[input.readInt(true)];
      data.skinRequired = input.readBoolean();
      if (nonessential)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(data.color, input.readInt32());
      skeletonData.bones.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const slotName = input.readString();
      const boneData = skeletonData.bones[input.readInt(true)];
      const data = new _SlotData_mjs__WEBPACK_IMPORTED_MODULE_2__.SlotData(i, slotName, boneData);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(data.color, input.readInt32());
      const darkColor = input.readInt32();
      if (darkColor != -1)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgb888ToColor(data.darkColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color(), darkColor);
      data.attachmentName = input.readStringRef();
      data.blendMode = _SkeletonBinary.BlendModeValues[input.readInt(true)];
      skeletonData.slots.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__.IkConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.mix = input.readFloat();
      data.softness = input.readFloat() * scale;
      data.bendDirection = input.readByte();
      data.compress = input.readBoolean();
      data.stretch = input.readBoolean();
      data.uniform = input.readBoolean();
      skeletonData.ikConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.TransformConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.local = input.readBoolean();
      data.relative = input.readBoolean();
      data.offsetRotation = input.readFloat();
      data.offsetX = input.readFloat() * scale;
      data.offsetY = input.readFloat() * scale;
      data.offsetScaleX = input.readFloat();
      data.offsetScaleY = input.readFloat();
      data.offsetShearY = input.readFloat();
      data.rotateMix = input.readFloat();
      data.translateMix = input.readFloat();
      data.scaleMix = input.readFloat();
      data.shearMix = input.readFloat();
      skeletonData.transformConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const data = new _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.PathConstraintData(input.readString());
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.slots[input.readInt(true)];
      data.positionMode = _SkeletonBinary.PositionModeValues[input.readInt(true)];
      data.spacingMode = _SkeletonBinary.SpacingModeValues[input.readInt(true)];
      data.rotateMode = _SkeletonBinary.RotateModeValues[input.readInt(true)];
      data.offsetRotation = input.readFloat();
      data.position = input.readFloat();
      if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
        data.position *= scale;
      data.spacing = input.readFloat();
      if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed)
        data.spacing *= scale;
      data.rotateMix = input.readFloat();
      data.translateMix = input.readFloat();
      skeletonData.pathConstraints.push(data);
    }
    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
    if (defaultSkin != null) {
      skeletonData.defaultSkin = defaultSkin;
      skeletonData.skins.push(defaultSkin);
    }
    {
      let i = skeletonData.skins.length;
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
      for (; i < n; i++)
        skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);
    }
    n = this.linkedMeshes.length;
    for (let i = 0; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const data = new _EventData_mjs__WEBPACK_IMPORTED_MODULE_8__.EventData(input.readStringRef());
      data.intValue = input.readInt(false);
      data.floatValue = input.readFloat();
      data.stringValue = input.readString();
      data.audioPath = input.readString();
      if (data.audioPath != null) {
        data.volume = input.readFloat();
        data.balance = input.readFloat();
      }
      skeletonData.events.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++)
      skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));
    return skeletonData;
  }
  readSkin(input, skeletonData, defaultSkin, nonessential) {
    let skin = null;
    let slotCount = 0;
    if (defaultSkin) {
      slotCount = input.readInt(true);
      if (slotCount == 0)
        return null;
      skin = new _Skin_mjs__WEBPACK_IMPORTED_MODULE_7__.Skin("default");
    } else {
      skin = new _Skin_mjs__WEBPACK_IMPORTED_MODULE_7__.Skin(input.readStringRef());
      skin.bones.length = input.readInt(true);
      for (let i = 0, n = skin.bones.length; i < n; i++)
        skin.bones[i] = skeletonData.bones[input.readInt(true)];
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
      slotCount = input.readInt(true);
    }
    for (let i = 0; i < slotCount; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const name = input.readStringRef();
        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
        if (attachment != null)
          skin.setAttachment(slotIndex, name, attachment);
      }
    }
    return skin;
  }
  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
    const scale = this.scale;
    let name = input.readStringRef();
    if (name == null)
      name = attachmentName;
    const typeIndex = input.readByte();
    const type = _SkeletonBinary.AttachmentTypeValues[typeIndex];
    switch (type) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Region: {
        let path = input.readStringRef();
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const scaleX = input.readFloat();
        const scaleY = input.readFloat();
        const width = input.readFloat();
        const height = input.readFloat();
        const color = input.readInt32();
        if (path == null)
          path = name;
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = x * scale;
        region.y = y * scale;
        region.scaleX = scaleX;
        region.scaleY = scaleY;
        region.rotation = rotation;
        region.width = width * scale;
        region.height = height * scale;
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(region.color, color);
        return region;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.BoundingBox: {
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        box.worldVerticesLength = vertexCount << 1;
        box.vertices = vertices.vertices;
        box.bones = vertices.bones;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(box.color, color);
        return box;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Mesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const vertexCount = input.readInt(true);
        const uvs = this.readFloatArray(input, vertexCount << 1, 1);
        const triangles = this.readShortArray(input);
        const vertices = this.readVertices(input, vertexCount);
        const hullLength = input.readInt(true);
        let edges = null;
        let width = 0;
        let height = 0;
        if (nonessential) {
          edges = this.readShortArray(input);
          width = input.readFloat();
          height = input.readFloat();
        }
        if (path == null)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(mesh.color, color);
        mesh.bones = vertices.bones;
        mesh.vertices = vertices.vertices;
        mesh.worldVerticesLength = vertexCount << 1;
        mesh.triangles = triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = hullLength << 1;
        if (nonessential) {
          mesh.edges = edges;
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        return mesh;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.LinkedMesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const skinName = input.readStringRef();
        const parent = input.readStringRef();
        const inheritDeform = input.readBoolean();
        let width = 0;
        let height = 0;
        if (nonessential) {
          width = input.readFloat();
          height = input.readFloat();
        }
        if (path == null)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(mesh.color, color);
        if (nonessential) {
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));
        return mesh;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Path: {
        const closed = input.readBoolean();
        const constantSpeed = input.readBoolean();
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0, n = lengths.length; i < n; i++)
          lengths[i] = input.readFloat() * scale;
        const color = nonessential ? input.readInt32() : 0;
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = closed;
        path.constantSpeed = constantSpeed;
        path.worldVerticesLength = vertexCount << 1;
        path.vertices = vertices.vertices;
        path.bones = vertices.bones;
        path.lengths = lengths;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(path.color, color);
        return path;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Point: {
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const color = nonessential ? input.readInt32() : 0;
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = x * scale;
        point.y = y * scale;
        point.rotation = rotation;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(point.color, color);
        return point;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Clipping: {
        const endSlotIndex = input.readInt(true);
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        clip.endSlot = skeletonData.slots[endSlotIndex];
        clip.worldVerticesLength = vertexCount << 1;
        clip.vertices = vertices.vertices;
        clip.bones = vertices.bones;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(clip.color, color);
        return clip;
      }
    }
    return null;
  }
  readVertices(input, vertexCount) {
    const verticesLength = vertexCount << 1;
    const vertices = new Vertices();
    const scale = this.scale;
    if (!input.readBoolean()) {
      vertices.vertices = this.readFloatArray(input, verticesLength, scale);
      return vertices;
    }
    const weights = new Array();
    const bonesArray = new Array();
    for (let i = 0; i < vertexCount; i++) {
      const boneCount = input.readInt(true);
      bonesArray.push(boneCount);
      for (let ii = 0; ii < boneCount; ii++) {
        bonesArray.push(input.readInt(true));
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat());
      }
    }
    vertices.vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(weights);
    vertices.bones = bonesArray;
    return vertices;
  }
  readFloatArray(input, n, scale) {
    const array = new Array(n);
    if (scale == 1) {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat();
    } else {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat() * scale;
    }
    return array;
  }
  readShortArray(input) {
    const n = input.readInt(true);
    const array = new Array(n);
    for (let i = 0; i < n; i++)
      array[i] = input.readShort();
    return array;
  }
  readAnimation(input, name, skeletonData) {
    const timelines = new Array();
    const scale = this.scale;
    let duration = 0;
    const tempColor1 = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
    const tempColor2 = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.SLOT_ATTACHMENT: {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.AttachmentTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++)
              timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[frameCount - 1]);
            break;
          }
          case _SkeletonBinary.SLOT_COLOR: {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              const time = input.readFloat();
              _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(tempColor1, input.readInt32());
              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.SLOT_TWO_COLOR: {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline(frameCount);
            timeline.slotIndex = slotIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              const time = input.readFloat();
              _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(tempColor1, input.readInt32());
              _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgb888ToColor(tempColor2, input.readInt32());
              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const boneIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.BONE_ROTATE: {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline(frameCount);
            timeline.boneIndex = boneIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.BONE_TRANSLATE:
          case _SkeletonBinary.BONE_SCALE:
          case _SkeletonBinary.BONE_SHEAR: {
            let timeline;
            let timelineScale = 1;
            if (timelineType == _SkeletonBinary.BONE_SCALE)
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ScaleTimeline(frameCount);
            else if (timelineType == _SkeletonBinary.BONE_SHEAR)
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ShearTimeline(frameCount);
            else {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline(frameCount);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline(frameCount);
      timeline.ikConstraintIndex = index;
      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());
        if (frameIndex < frameCount - 1)
          this.readCurve(input, frameIndex, timeline);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline.ENTRIES]);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline(frameCount);
      timeline.transformConstraintIndex = index;
      for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
        timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
        if (frameIndex < frameCount - 1)
          this.readCurve(input, frameIndex, timeline);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline.ENTRIES]);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const data = skeletonData.pathConstraints[index];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        switch (timelineType) {
          case _SkeletonBinary.PATH_POSITION:
          case _SkeletonBinary.PATH_SPACING: {
            let timeline;
            let timelineScale = 1;
            if (timelineType == _SkeletonBinary.PATH_SPACING) {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintSpacingTimeline(frameCount);
              if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline(frameCount);
              if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline.ENTRIES]);
            break;
          }
          case _SkeletonBinary.PATH_MIX: {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline(frameCount);
            timeline.pathConstraintIndex = index;
            for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());
              if (frameIndex < frameCount - 1)
                this.readCurve(input, frameIndex, timeline);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(frameCount - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline.ENTRIES]);
            break;
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const skin = skeletonData.skins[input.readInt(true)];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const slotIndex = input.readInt(true);
        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          const attachment = skin.getAttachment(slotIndex, input.readStringRef());
          const weighted = attachment.bones != null;
          const vertices = attachment.vertices;
          const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
          const frameCount = input.readInt(true);
          const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DeformTimeline(frameCount);
          timeline.slotIndex = slotIndex;
          timeline.attachment = attachment;
          for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
            const time = input.readFloat();
            let deform;
            let end = input.readInt(true);
            if (end == 0)
              deform = weighted ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength) : vertices;
            else {
              deform = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength);
              const start = input.readInt(true);
              end += start;
              if (scale == 1) {
                for (let v = start; v < end; v++)
                  deform[v] = input.readFloat();
              } else {
                for (let v = start; v < end; v++)
                  deform[v] = input.readFloat() * scale;
              }
              if (!weighted) {
                for (let v = 0, vn = deform.length; v < vn; v++)
                  deform[v] += vertices[v];
              }
            }
            timeline.setFrame(frameIndex, time, deform);
            if (frameIndex < frameCount - 1)
              this.readCurve(input, frameIndex, timeline);
          }
          timelines.push(timeline);
          duration = Math.max(duration, timeline.frames[frameCount - 1]);
        }
      }
    }
    const drawOrderCount = input.readInt(true);
    if (drawOrderCount > 0) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DrawOrderTimeline(drawOrderCount);
      const slotCount = skeletonData.slots.length;
      for (let i = 0; i < drawOrderCount; i++) {
        const time = input.readFloat();
        const offsetCount = input.readInt(true);
        const drawOrder = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount, 0);
        for (let ii = slotCount - 1; ii >= 0; ii--)
          drawOrder[ii] = -1;
        const unchanged = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount - offsetCount, 0);
        let originalIndex = 0;
        let unchangedIndex = 0;
        for (let ii = 0; ii < offsetCount; ii++) {
          const slotIndex = input.readInt(true);
          while (originalIndex != slotIndex)
            unchanged[unchangedIndex++] = originalIndex++;
          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
        }
        while (originalIndex < slotCount)
          unchanged[unchangedIndex++] = originalIndex++;
        for (let ii = slotCount - 1; ii >= 0; ii--)
          if (drawOrder[ii] == -1)
            drawOrder[ii] = unchanged[--unchangedIndex];
        timeline.setFrame(i, time, drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
    }
    const eventCount = input.readInt(true);
    if (eventCount > 0) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.EventTimeline(eventCount);
      for (let i = 0; i < eventCount; i++) {
        const time = input.readFloat();
        const eventData = skeletonData.events[input.readInt(true)];
        const event = new _Event_mjs__WEBPACK_IMPORTED_MODULE_0__.Event(time, eventData);
        event.intValue = input.readInt(false);
        event.floatValue = input.readFloat();
        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
        if (event.data.audioPath != null) {
          event.volume = input.readFloat();
          event.balance = input.readFloat();
        }
        timeline.setFrame(i, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[eventCount - 1]);
    }
    return new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.Animation(name, timelines, duration);
  }
  readCurve(input, frameIndex, timeline) {
    switch (input.readByte()) {
      case _SkeletonBinary.CURVE_STEPPED:
        timeline.setStepped(frameIndex);
        break;
      case _SkeletonBinary.CURVE_BEZIER:
        this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
        break;
    }
  }
  setCurve(timeline, frameIndex, cx1, cy1, cx2, cy2) {
    timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
  }
};
let SkeletonBinary = _SkeletonBinary;
SkeletonBinary.AttachmentTypeValues = [
  0,
  1,
  2,
  3,
  4,
  5,
  6
];
SkeletonBinary.TransformModeValues = [
  _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.Normal,
  _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.OnlyTranslation,
  _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoRotationOrReflection,
  _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoScale,
  _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoScaleOrReflection
];
SkeletonBinary.PositionModeValues = [_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Percent];
SkeletonBinary.SpacingModeValues = [_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length, _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed, _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Percent];
SkeletonBinary.RotateModeValues = [_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.Tangent, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.Chain, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.ChainScale];
SkeletonBinary.BlendModeValues = [_pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.NORMAL, _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.ADD, _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.MULTIPLY, _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.SCREEN];
SkeletonBinary.BONE_ROTATE = 0;
SkeletonBinary.BONE_TRANSLATE = 1;
SkeletonBinary.BONE_SCALE = 2;
SkeletonBinary.BONE_SHEAR = 3;
SkeletonBinary.SLOT_ATTACHMENT = 0;
SkeletonBinary.SLOT_COLOR = 1;
SkeletonBinary.SLOT_TWO_COLOR = 2;
SkeletonBinary.PATH_POSITION = 0;
SkeletonBinary.PATH_SPACING = 1;
SkeletonBinary.PATH_MIX = 2;
SkeletonBinary.CURVE_LINEAR = 0;
SkeletonBinary.CURVE_STEPPED = 1;
SkeletonBinary.CURVE_BEZIER = 2;
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritDeform = inheritDeform;
  }
}
class Vertices {
  constructor(bones = null, vertices = null) {
    this.bones = bones;
    this.vertices = vertices;
  }
}


//# sourceMappingURL=SkeletonBinary.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBounds.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBounds.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonBounds": function() { return /* binding */ SkeletonBounds; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class SkeletonBounds extends _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.SkeletonBoundsBase {
}


//# sourceMappingURL=SkeletonBounds.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonData.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonData.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonData": function() { return /* binding */ SkeletonData; }
/* harmony export */ });
class SkeletonData {
  constructor() {
    this.bones = new Array();
    // Ordered parents first.
    this.slots = new Array();
    // Setup pose draw order.
    this.skins = new Array();
    this.events = new Array();
    this.animations = new Array();
    this.ikConstraints = new Array();
    this.transformConstraints = new Array();
    this.pathConstraints = new Array();
    // Nonessential
    this.fps = 0;
  }
  findBone(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  findBoneIndex(boneName) {
    if (boneName == null)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  findSlot(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  findSlotIndex(slotName) {
    if (slotName == null)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  findSkin(skinName) {
    if (skinName == null)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  findEvent(eventDataName) {
    if (eventDataName == null)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  findAnimation(animationName) {
    if (animationName == null)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  findIkConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findTransformConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraint(constraintName) {
    if (constraintName == null)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
}


//# sourceMappingURL=SkeletonData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonJson.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonJson.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonJson": function() { return /* binding */ SkeletonJson; }
/* harmony export */ });
/* harmony import */ var _Event_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Event.mjs");
/* harmony import */ var _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonData.mjs");
/* harmony import */ var _SlotData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SlotData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SlotData.mjs");
/* harmony import */ var _BoneData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BoneData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/BoneData.mjs");
/* harmony import */ var _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraintData.mjs");
/* harmony import */ var _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraintData.mjs");
/* harmony import */ var _Skin_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Skin.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Skin.mjs");
/* harmony import */ var _EventData_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EventData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/EventData.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Animation.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");













class SkeletonJson {
  constructor(attachmentLoader) {
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_1__.SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap != null) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      if (skeletonData.version.substr(0, 3) !== "3.8") {
        const error = `Spine 3.8 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;
        console.error(error);
      }
      if (skeletonData.version === "3.8.75") {
        const error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;
        console.error(error);
      }
      skeletonData.x = skeletonMap.x;
      skeletonData.y = skeletonMap.y;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = this.getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new _BoneData_mjs__WEBPACK_IMPORTED_MODULE_3__.BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = this.getValue(boneMap, "length", 0) * scale;
        data.x = this.getValue(boneMap, "x", 0) * scale;
        data.y = this.getValue(boneMap, "y", 0) * scale;
        data.rotation = this.getValue(boneMap, "rotation", 0);
        data.scaleX = this.getValue(boneMap, "scaleX", 1);
        data.scaleY = this.getValue(boneMap, "scaleY", 1);
        data.shearX = this.getValue(boneMap, "shearX", 0);
        data.shearY = this.getValue(boneMap, "shearY", 0);
        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
        data.skinRequired = this.getValue(boneMap, "skin", false);
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const slotName = slotMap.name;
        const boneName = slotMap.bone;
        const boneData = skeletonData.findBone(boneName);
        if (boneData == null)
          throw new Error(`Slot bone not found: ${boneName}`);
        const data = new _SlotData_mjs__WEBPACK_IMPORTED_MODULE_2__.SlotData(skeletonData.slots.length, slotName, boneData);
        const color = this.getValue(slotMap, "color", null);
        if (color != null)
          data.color.setFromString(color);
        const dark = this.getValue(slotMap, "dark", null);
        if (dark != null) {
          data.darkColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color(1, 1, 1, 1);
          data.darkColor.setFromString(dark);
        }
        data.attachmentName = this.getValue(slotMap, "attachment", null);
        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_4__.IkConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`IK target bone not found: ${targetName}`);
        data.mix = this.getValue(constraintMap, "mix", 1);
        data.softness = this.getValue(constraintMap, "softness", 0) * scale;
        data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.compress = this.getValue(constraintMap, "compress", false);
        data.stretch = this.getValue(constraintMap, "stretch", false);
        data.uniform = this.getValue(constraintMap, "uniform", false);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.TransformConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findBone(targetName);
        if (data.target == null)
          throw new Error(`Transform constraint target bone not found: ${targetName}`);
        data.local = this.getValue(constraintMap, "local", false);
        data.relative = this.getValue(constraintMap, "relative", false);
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
        data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
        data.shearMix = this.getValue(constraintMap, "shearMix", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.PathConstraintData(constraintMap.name);
        data.order = this.getValue(constraintMap, "order", 0);
        data.skinRequired = this.getValue(constraintMap, "skin", false);
        for (let j = 0; j < constraintMap.bones.length; j++) {
          const boneName = constraintMap.bones[j];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`Transform constraint bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        data.target = skeletonData.findSlot(targetName);
        if (data.target == null)
          throw new Error(`Path target slot not found: ${targetName}`);
        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
        data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
        data.position = this.getValue(constraintMap, "position", 0);
        if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
          data.position *= scale;
        data.spacing = this.getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed)
          data.spacing *= scale;
        data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
        data.translateMix = this.getValue(constraintMap, "translateMix", 1);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (let i = 0; i < root.skins.length; i++) {
        const skinMap = root.skins[i];
        const skin = new _Skin_mjs__WEBPACK_IMPORTED_MODULE_7__.Skin(skinMap.name);
        if (skinMap.bones) {
          for (let ii = 0; ii < skinMap.bones.length; ii++) {
            const bone = skeletonData.findBone(skinMap.bones[ii]);
            if (bone == null)
              throw new Error(`Skin bone not found: ${skinMap.bones[i]}`);
            skin.bones.push(bone);
          }
        }
        if (skinMap.ik) {
          for (let ii = 0; ii < skinMap.ik.length; ii++) {
            const constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);
            if (constraint == null)
              throw new Error(`Skin IK constraint not found: ${skinMap.ik[i]}`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.transform) {
          for (let ii = 0; ii < skinMap.transform.length; ii++) {
            const constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);
            if (constraint == null)
              throw new Error(`Skin transform constraint not found: ${skinMap.transform[i]}`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.path) {
          for (let ii = 0; ii < skinMap.path.length; ii++) {
            const constraint = skeletonData.findPathConstraint(skinMap.path[ii]);
            if (constraint == null)
              throw new Error(`Skin path constraint not found: ${skinMap.path[i]}`);
            skin.constraints.push(constraint);
          }
        }
        for (const slotName in skinMap.attachments) {
          const slot = skeletonData.findSlot(slotName);
          if (slot == null)
            throw new Error(`Slot not found: ${slotName}`);
          const slotMap = skinMap.attachments[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
            if (attachment != null)
              skin.setAttachment(slot.index, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (skin == null)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (parent == null)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new _EventData_mjs__WEBPACK_IMPORTED_MODULE_8__.EventData(eventName);
        data.intValue = this.getValue(eventMap, "int", 0);
        data.floatValue = this.getValue(eventMap, "float", 0);
        data.stringValue = this.getValue(eventMap, "string", "");
        data.audioPath = this.getValue(eventMap, "audio", null);
        if (data.audioPath != null) {
          data.volume = this.getValue(eventMap, "volume", 1);
          data.balance = this.getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = this.getValue(map, "name", name);
    const type = this.getValue(map, "type", "region");
    switch (type) {
      case "region": {
        const path = this.getValue(map, "path", name);
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path);
        if (region == null)
          return null;
        region.path = path;
        region.x = this.getValue(map, "x", 0) * scale;
        region.y = this.getValue(map, "y", 0) * scale;
        region.scaleX = this.getValue(map, "scaleX", 1);
        region.scaleY = this.getValue(map, "scaleY", 1);
        region.rotation = this.getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        const color = this.getValue(map, "color", null);
        if (color != null)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (box == null)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = this.getValue(map, "path", name);
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
        if (mesh == null)
          return null;
        mesh.path = path;
        const color = this.getValue(map, "color", null);
        if (color != null)
          mesh.color.setFromString(color);
        mesh.width = this.getValue(map, "width", 0) * scale;
        mesh.height = this.getValue(map, "height", 0) * scale;
        const parent = this.getValue(map, "parent", null);
        if (parent != null) {
          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent, this.getValue(map, "deform", true)));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.edges = this.getValue(map, "edges", null);
        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (path == null)
          return null;
        path.closed = this.getValue(map, "closed", false);
        path.constantSpeed = this.getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = this.getValue(map, "color", null);
        if (color != null)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (point == null)
          return null;
        point.x = this.getValue(map, "x", 0) * scale;
        point.y = this.getValue(map, "y", 0) * scale;
        point.rotation = this.getValue(map, "rotation", 0);
        const color = this.getValue(map, "color", null);
        if (color != null)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (clip == null)
          return null;
        const end = this.getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = this.getValue(map, "color", null);
        if (color != null)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    let duration = 0;
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slotIndex = skeletonData.findSlotIndex(slotName);
        if (slotIndex == -1)
          throw new Error(`Slot not found: ${slotName}`);
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (timelineName == "attachment") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.AttachmentTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          } else if (timelineName == "color") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
              color.setFromString(valueMap.color || "ffffffff");
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color.r, color.g, color.b, color.a);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline.ENTRIES]);
          } else if (timelineName == "twoColor") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const light = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
              const dark = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color();
              light.setFromString(valueMap.light);
              dark.setFromString(valueMap.dark);
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a slot: ${timelineName} (${slotName})`);
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const boneIndex = skeletonData.findBoneIndex(boneName);
        if (boneIndex == -1)
          throw new Error(`Bone not found: ${boneName}`);
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          if (timelineName === "rotate") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline(timelineMap.length);
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline.ENTRIES]);
          } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
            let timeline = null;
            let timelineScale = 1;
            let defaultValue = 0;
            if (timelineName === "scale") {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ScaleTimeline(timelineMap.length);
              defaultValue = 1;
            } else if (timelineName === "shear")
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ShearTimeline(timelineMap.length);
            else {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline(timelineMap.length);
              timelineScale = scale;
            }
            timeline.boneIndex = boneIndex;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              const x = this.getValue(valueMap, "x", defaultValue);
              const y = this.getValue(valueMap, "y", defaultValue);
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline.ENTRIES]);
          } else
            throw new Error(`Invalid timeline type for a bone: ${timelineName} (${boneName})`);
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        const constraint = skeletonData.findIkConstraint(constraintName);
        const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline(constraintMap.length);
        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            this.getValue(valueMap, "time", 0),
            this.getValue(valueMap, "mix", 1),
            this.getValue(valueMap, "softness", 0) * scale,
            this.getValue(valueMap, "bendPositive", true) ? 1 : -1,
            this.getValue(valueMap, "compress", false),
            this.getValue(valueMap, "stretch", false)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline.ENTRIES]);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const constraintMap = map.transform[constraintName];
        const constraint = skeletonData.findTransformConstraint(constraintName);
        const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline(constraintMap.length);
        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        let frameIndex = 0;
        for (let i = 0; i < constraintMap.length; i++) {
          const valueMap = constraintMap[i];
          timeline.setFrame(
            frameIndex,
            this.getValue(valueMap, "time", 0),
            this.getValue(valueMap, "rotateMix", 1),
            this.getValue(valueMap, "translateMix", 1),
            this.getValue(valueMap, "scaleMix", 1),
            this.getValue(valueMap, "shearMix", 1)
          );
          this.readCurve(valueMap, timeline, frameIndex);
          frameIndex++;
        }
        timelines.push(timeline);
        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline.ENTRIES]);
      }
    }
    if (map.path) {
      for (const constraintName in map.path) {
        const constraintMap = map.path[constraintName];
        const index = skeletonData.findPathConstraintIndex(constraintName);
        if (index == -1)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const data = skeletonData.pathConstraints[index];
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          if (timelineName === "position" || timelineName === "spacing") {
            let timeline = null;
            let timelineScale = 1;
            if (timelineName === "spacing") {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintSpacingTimeline(timelineMap.length);
              if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed)
                timelineScale = scale;
            } else {
              timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline(timelineMap.length);
              if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
                timelineScale = scale;
            }
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline.ENTRIES]);
          } else if (timelineName === "mix") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline(timelineMap.length);
            timeline.pathConstraintIndex = index;
            let frameIndex = 0;
            for (let i = 0; i < timelineMap.length; i++) {
              const valueMap = timelineMap[i];
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline.ENTRIES]);
          }
        }
      }
    }
    if (map.deform) {
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const skin = skeletonData.findSkin(deformName);
        if (skin == null) {
          if (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.settings.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${deformName}`);
          } else {
            continue;
          }
        }
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const slotIndex = skeletonData.findSlotIndex(slotName);
          if (slotIndex == -1)
            throw new Error(`Slot not found: ${slotMap.name}`);
          for (const timelineName in slotMap) {
            const timelineMap = slotMap[timelineName];
            const attachment = skin.getAttachment(slotIndex, timelineName);
            if (attachment == null)
              throw new Error(`Deform attachment not found: ${timelineMap.name}`);
            const weighted = attachment.bones != null;
            const vertices = attachment.vertices;
            const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DeformTimeline(timelineMap.length);
            timeline.slotIndex = slotIndex;
            timeline.attachment = attachment;
            let frameIndex = 0;
            for (let j = 0; j < timelineMap.length; j++) {
              const valueMap = timelineMap[j];
              let deform;
              const verticesValue = this.getValue(valueMap, "vertices", null);
              if (verticesValue == null)
                deform = weighted ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength) : vertices;
              else {
                deform = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength);
                const start = this.getValue(valueMap, "offset", 0);
                _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                if (scale != 1) {
                  for (let i = start, n = i + verticesValue.length; i < n; i++)
                    deform[i] *= scale;
                }
                if (!weighted) {
                  for (let i = 0; i < deformLength; i++)
                    deform[i] += vertices[i];
                }
              }
              timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
        }
      }
    }
    let drawOrderNode = map.drawOrder;
    if (drawOrderNode == null)
      drawOrderNode = map.draworder;
    if (drawOrderNode != null) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DrawOrderTimeline(drawOrderNode.length);
      const slotCount = skeletonData.slots.length;
      let frameIndex = 0;
      for (let j = 0; j < drawOrderNode.length; j++) {
        const drawOrderMap = drawOrderNode[j];
        let drawOrder = null;
        const offsets = this.getValue(drawOrderMap, "offsets", null);
        if (offsets != null) {
          drawOrder = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount, -1);
          const unchanged = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let i = 0; i < offsets.length; i++) {
            const offsetMap = offsets[i];
            const slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
            if (slotIndex == -1)
              throw new Error(`Slot not found: ${offsetMap.slot}`);
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let i = slotCount - 1; i >= 0; i--)
            if (drawOrder[i] == -1)
              drawOrder[i] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (map.events) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.EventTimeline(map.events.length);
      let frameIndex = 0;
      for (let i = 0; i < map.events.length; i++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (eventData == null)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new _Event_mjs__WEBPACK_IMPORTED_MODULE_0__.Event(_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
        event.intValue = this.getValue(eventMap, "int", eventData.intValue);
        event.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath != null) {
          event.volume = this.getValue(eventMap, "volume", 1);
          event.balance = this.getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frameIndex++, event);
      }
      timelines.push(timeline);
      duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
    }
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new _Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.Animation(name, timelines, duration));
  }
  readCurve(map, timeline, frameIndex) {
    if (!map.hasOwnProperty("curve"))
      return;
    if (map.curve === "stepped")
      timeline.setStepped(frameIndex);
    else {
      const curve = map.curve;
      timeline.setCurve(frameIndex, curve, this.getValue(map, "c2", 0), this.getValue(map, "c3", 1), this.getValue(map, "c4", 1));
    }
  }
  getValue(map, prop, defaultValue) {
    return map[prop] !== void 0 ? map[prop] : defaultValue;
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.NORMAL;
    if (str == "additive")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.ADD;
    if (str == "multiply")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
  static positionModeFromString(str) {
    str = str.toLowerCase();
    if (str == "fixed")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed;
    if (str == "percent")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static spacingModeFromString(str) {
    str = str.toLowerCase();
    if (str == "length")
      return _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Length;
    if (str == "fixed")
      return _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Fixed;
    if (str == "percent")
      return _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.SpacingMode.Percent;
    throw new Error(`Unknown position mode: ${str}`);
  }
  static rotateModeFromString(str) {
    str = str.toLowerCase();
    if (str == "tangent")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.Tangent;
    if (str == "chain")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.Chain;
    if (str == "chainscale")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode.ChainScale;
    throw new Error(`Unknown rotate mode: ${str}`);
  }
  static transformModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.Normal;
    if (str == "onlytranslation")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.OnlyTranslation;
    if (str == "norotationorreflection")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoRotationOrReflection;
    if (str == "noscale")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoScale;
    if (str == "noscaleorreflection")
      return _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode.NoScaleOrReflection;
    throw new Error(`Unknown transform mode: ${str}`);
  }
}
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritDeform = inheritDeform;
  }
}


//# sourceMappingURL=SkeletonJson.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Skin.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/Skin.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Skin": function() { return /* binding */ Skin; },
/* harmony export */   "SkinEntry": function() { return /* binding */ SkinEntry; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs");





class SkinEntry {
  constructor(slotIndex, name, attachment) {
    this.slotIndex = slotIndex;
    this.name = name;
    this.attachment = attachment;
  }
}
class Skin {
  constructor(name) {
    this.attachments = new Array();
    this.bones = Array();
    this.constraints = new Array();
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  setAttachment(slotIndex, name, attachment) {
    if (attachment == null)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  addSkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let j = 0; j < this.bones.length; j++) {
        if (this.bones[j] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let j = 0; j < this.constraints.length; j++) {
        if (this.constraints[j] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
    }
  }
  copySkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let j = 0; j < this.bones.length; j++) {
        if (this.bones[j] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let j = 0; j < this.constraints.length; j++) {
        if (this.constraints[j] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (attachment.attachment == null)
        continue;
      if (attachment.attachment instanceof _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.MeshAttachment) {
        attachment.attachment = attachment.attachment.newLinkedMesh();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      } else {
        attachment.attachment = attachment.attachment.copy();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
  }
  /** @return May be null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  removeAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    if (dictionary)
      dictionary[name] = null;
  }
  getAttachments() {
    const entries = new Array();
    for (let i = 0; i < this.attachments.length; i++) {
      const slotAttachments = this.attachments[i];
      if (slotAttachments) {
        for (const name in slotAttachments) {
          const attachment = slotAttachments[name];
          if (attachment)
            entries.push(new SkinEntry(i, name, attachment));
        }
      }
    }
    return entries;
  }
  getAttachmentsForSlot(slotIndex, attachments) {
    const slotAttachments = this.attachments[slotIndex];
    if (slotAttachments) {
      for (const name in slotAttachments) {
        const attachment = slotAttachments[name];
        if (attachment)
          attachments.push(new SkinEntry(slotIndex, name, attachment));
      }
    }
  }
  clear() {
    this.attachments.length = 0;
    this.bones.length = 0;
    this.constraints.length = 0;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment != null)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
}


//# sourceMappingURL=Skin.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Slot.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/Slot.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Slot": function() { return /* binding */ Slot; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class Slot {
  constructor(data, bone) {
    this.deform = new Array();
    if (data == null)
      throw new Error("data cannot be null.");
    if (bone == null)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    this.darkColor = data.darkColor == null ? null : new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** @return May be null. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.
   * @param attachment May be null. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    this.attachment = attachment;
    this.attachmentTime = this.bone.skeleton.time;
    this.deform.length = 0;
  }
  setAttachmentTime(time) {
    this.attachmentTime = this.bone.skeleton.time - time;
  }
  /** Returns the time since the attachment was set. */
  getAttachmentTime() {
    return this.bone.skeleton.time - this.attachmentTime;
  }
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor != null)
      this.darkColor.setFromColor(this.data.darkColor);
    if (this.data.attachmentName == null)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
}


//# sourceMappingURL=Slot.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SlotData.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/SlotData.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SlotData": function() { return /* binding */ SlotData; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class SlotData {
  constructor(index, name, boneData) {
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (name == null)
      throw new Error("name cannot be null.");
    if (boneData == null)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
}


//# sourceMappingURL=SlotData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraint.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraint.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformConstraint": function() { return /* binding */ TransformConstraint; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class TransformConstraint {
  constructor(data, skeleton) {
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.temp = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Vector2();
    this.active = false;
    if (data == null)
      throw new Error("data cannot be null.");
    if (skeleton == null)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.rotateMix = data.rotateMix;
    this.translateMix = data.translateMix;
    this.scaleMix = data.scaleMix;
    this.shearMix = data.shearMix;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++)
      this.bones.push(skeleton.findBone(data.bones[i].name));
    this.target = skeleton.findBone(data.target.name);
  }
  isActive() {
    return this.active;
  }
  apply() {
    this.update();
  }
  update() {
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * translateMix;
        mat.ty += (temp.y - mat.ty) * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        let ts = Math.sqrt(ta * ta + tc * tc);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
        mat.a *= s;
        mat.b *= s;
        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        ts = Math.sqrt(tb * tb + td * td);
        if (s > 1e-5)
          s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r = by + (r + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyRelativeWorld() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let modified = false;
      const mat = bone.matrix;
      if (rotateMix != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r *= rotateMix;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
        modified = true;
      }
      if (translateMix != 0) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * translateMix;
        mat.ty += temp.y * translateMix;
        modified = true;
      }
      if (scaleMix > 0) {
        let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
        mat.a *= s;
        mat.b *= s;
        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
        mat.c *= s;
        mat.d *= s;
        modified = true;
      }
      if (shearMix > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI / 2 + offsetShearY) * shearMix;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
        modified = true;
      }
      if (modified)
        bone.appliedValid = false;
    }
  }
  applyAbsoluteLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * rotateMix;
      }
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax - x + this.data.offsetX) * translateMix;
        y += (target.ay - y + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
        if (scaleY > 1e-5)
          scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
      }
      const shearY = bone.ashearY;
      if (shearMix > 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        bone.shearY += r * shearMix;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const rotateMix = this.rotateMix;
    const translateMix = this.translateMix;
    const scaleMix = this.scaleMix;
    const shearMix = this.shearMix;
    const target = this.target;
    if (!target.appliedValid)
      target.updateAppliedTransform();
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.appliedValid)
        bone.updateAppliedTransform();
      let rotation = bone.arotation;
      if (rotateMix != 0)
        rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
      let x = bone.ax;
      let y = bone.ay;
      if (translateMix != 0) {
        x += (target.ax + this.data.offsetX) * translateMix;
        y += (target.ay + this.data.offsetY) * translateMix;
      }
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (scaleMix > 0) {
        if (scaleX > 1e-5)
          scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
        if (scaleY > 1e-5)
          scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
      }
      let shearY = bone.ashearY;
      if (shearMix > 0)
        shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
}


//# sourceMappingURL=TransformConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraintData.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraintData.mjs ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformConstraintData": function() { return /* binding */ TransformConstraintData; }
/* harmony export */ });
/* harmony import */ var _Constraint_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Constraint.mjs");


class TransformConstraintData extends _Constraint_mjs__WEBPACK_IMPORTED_MODULE_0__.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    this.bones = new Array();
    this.rotateMix = 0;
    this.translateMix = 0;
    this.scaleMix = 0;
    this.shearMix = 0;
    this.offsetRotation = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.offsetScaleX = 0;
    this.offsetScaleY = 0;
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
  }
}


//# sourceMappingURL=TransformConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attachment": function() { return /* binding */ Attachment; },
/* harmony export */   "VertexAttachment": function() { return /* binding */ VertexAttachment; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class Attachment {
  constructor(name) {
    if (name == null)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}
const _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    this.id = (_VertexAttachment.nextID++ & 65535) << 11;
    this.worldVerticesLength = 0;
    this.deformAttachment = this;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms local vertices to world coordinates.
   * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.
   * @param worldVertices The output world vertices. Must have a length >= offset + count.
   * @param offset The worldVertices index to begin writing values. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.deform;
    let vertices = this.vertices;
    const bones = this.bones;
    if (bones == null) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  copyTo(attachment) {
    if (this.bones != null) {
      attachment.bones = new Array(this.bones.length);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
    } else
      attachment.bones = null;
    if (this.vertices != null) {
      attachment.vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.newFloatArray(this.vertices.length);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
    } else
      attachment.vertices = null;
    attachment.worldVerticesLength = this.worldVerticesLength;
    attachment.deformAttachment = this.deformAttachment;
  }
};
let VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;


//# sourceMappingURL=Attachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/BoundingBoxAttachment.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/BoundingBoxAttachment.mjs ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoundingBoxAttachment": function() { return /* binding */ BoundingBoxAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class BoundingBoxAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.BoundingBox;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new BoundingBoxAttachment(this.name);
    this.copyTo(copy);
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=BoundingBoxAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/ClippingAttachment.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/ClippingAttachment.mjs ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClippingAttachment": function() { return /* binding */ ClippingAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class ClippingAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Clipping;
    // Nonessential.
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0.2275, 0.2275, 0.8078, 1);
  }
  copy() {
    const copy = new ClippingAttachment(this.name);
    this.copyTo(copy);
    copy.endSlot = this.endSlot;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=ClippingAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/MeshAttachment.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/MeshAttachment.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshAttachment": function() { return /* binding */ MeshAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class MeshAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Mesh;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.tempColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0, 0, 0, 0);
  }
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh != null) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  copy() {
    if (this.parentMesh != null)
      return this.newLinkedMesh();
    const copy = new MeshAttachment(this.name);
    copy.region = this.region;
    copy.path = this.path;
    copy.color.setFromColor(this.color);
    this.copyTo(copy);
    copy.regionUVs = new Float32Array(this.regionUVs.length);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
    copy.triangles = new Array(this.triangles.length);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
    copy.hullLength = this.hullLength;
    if (this.edges != null) {
      copy.edges = new Array(this.edges.length);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
    }
    copy.width = this.width;
    copy.height = this.height;
    return copy;
  }
  newLinkedMesh() {
    const copy = new MeshAttachment(this.name);
    copy.region = this.region;
    copy.path = this.path;
    copy.color.setFromColor(this.color);
    copy.deformAttachment = this.deformAttachment;
    copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);
    return copy;
  }
}


//# sourceMappingURL=MeshAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PathAttachment.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PathAttachment.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathAttachment": function() { return /* binding */ PathAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class PathAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Path;
    this.closed = false;
    this.constantSpeed = false;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new PathAttachment(this.name);
    this.copyTo(copy);
    copy.lengths = new Array(this.lengths.length);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
    copy.closed = closed;
    copy.constantSpeed = this.constantSpeed;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=PathAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PointAttachment.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PointAttachment.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointAttachment": function() { return /* binding */ PointAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class PointAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Point;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(this.rotation);
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  copy() {
    const copy = new PointAttachment(this.name);
    copy.x = this.x;
    copy.y = this.y;
    copy.rotation = this.rotation;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=PointAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RegionAttachment": function() { return /* binding */ RegionAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _Slot_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Slot.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Slot.mjs");




const _RegionAttachment = class extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.Attachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Region;
    this.x = 0;
    this.y = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.rotation = 0;
    this.width = 0;
    this.height = 0;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.offset = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(8);
    this.uvs = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(8);
    this.tempColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
  updateOffset() {
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const localXCos = localX * cos + this.x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + this.y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + this.x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + this.y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[_RegionAttachment.OX1] = localXCos - localYSin;
    offset[_RegionAttachment.OY1] = localYCos + localXSin;
    offset[_RegionAttachment.OX2] = localXCos - localY2Sin;
    offset[_RegionAttachment.OY2] = localY2Cos + localXSin;
    offset[_RegionAttachment.OX3] = localX2Cos - localY2Sin;
    offset[_RegionAttachment.OY3] = localY2Cos + localX2Sin;
    offset[_RegionAttachment.OX4] = localX2Cos - localYSin;
    offset[_RegionAttachment.OY4] = localYCos + localX2Sin;
  }
  setRegion(region) {
    this.region = region;
    const uvs = this.uvs;
    if (region.rotate) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  computeWorldVertices(bone, worldVertices, offset, stride) {
    const vertexOffset = this.offset;
    const mat = bone instanceof _Slot_mjs__WEBPACK_IMPORTED_MODULE_2__.Slot ? bone.bone.matrix : bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[_RegionAttachment.OX1];
    offsetY = vertexOffset[_RegionAttachment.OY1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX2];
    offsetY = vertexOffset[_RegionAttachment.OY2];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX3];
    offsetY = vertexOffset[_RegionAttachment.OY3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[_RegionAttachment.OX4];
    offsetY = vertexOffset[_RegionAttachment.OY4];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
  copy() {
    const copy = new _RegionAttachment(this.name);
    copy.region = this.region;
    copy.rendererObject = this.rendererObject;
    copy.path = this.path;
    copy.x = this.x;
    copy.y = this.y;
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.width = this.width;
    copy.height = this.height;
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
    copy.color.setFromColor(this.color);
    return copy;
  }
};
let RegionAttachment = _RegionAttachment;
RegionAttachment.OX1 = 0;
RegionAttachment.OY1 = 1;
RegionAttachment.OX2 = 2;
RegionAttachment.OY2 = 3;
RegionAttachment.OX3 = 4;
RegionAttachment.OY3 = 5;
RegionAttachment.OX4 = 6;
RegionAttachment.OY4 = 7;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;


//# sourceMappingURL=RegionAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/JitterEffect.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/JitterEffect.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JitterEffect": function() { return /* binding */ JitterEffect; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class JitterEffect {
  constructor(jitterX, jitterY) {
    this.jitterX = 0;
    this.jitterY = 0;
    this.jitterX = jitterX;
    this.jitterY = jitterY;
  }
  begin(skeleton) {
  }
  transform(position, uv, light, dark) {
    position.x += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
    position.y += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
  }
  end() {
  }
}


//# sourceMappingURL=JitterEffect.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/SwirlEffect.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/SwirlEffect.mjs ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SwirlEffect": function() { return /* binding */ SwirlEffect; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


const _SwirlEffect = class {
  constructor(radius) {
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 0;
    this.angle = 0;
    this.worldX = 0;
    this.worldY = 0;
    this.radius = radius;
  }
  begin(skeleton) {
    this.worldX = skeleton.x + this.centerX;
    this.worldY = skeleton.y + this.centerY;
  }
  transform(position, uv, light, dark) {
    const radAngle = this.angle * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degreesToRadians;
    const x = position.x - this.worldX;
    const y = position.y - this.worldY;
    const dist = Math.sqrt(x * x + y * y);
    if (dist < this.radius) {
      const theta = _SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);
      position.x = cos * x - sin * y + this.worldX;
      position.y = sin * x + cos * y + this.worldY;
    }
  }
  end() {
  }
};
let SwirlEffect = _SwirlEffect;
SwirlEffect.interpolation = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.PowOut(2);


//# sourceMappingURL=SwirlEffect.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-3.8/lib/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-3.8/lib/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.Animation; },
/* harmony export */   "AnimationState": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.AnimationState; },
/* harmony export */   "AnimationStateAdapter": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.AnimationStateAdapter; },
/* harmony export */   "AnimationStateData": function() { return /* reexport safe */ _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_11__.AnimationStateData; },
/* harmony export */   "AtlasAttachmentLoader": function() { return /* reexport safe */ _core_AtlasAttachmentLoader_mjs__WEBPACK_IMPORTED_MODULE_12__.AtlasAttachmentLoader; },
/* harmony export */   "Attachment": function() { return /* reexport safe */ _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.Attachment; },
/* harmony export */   "AttachmentTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.AttachmentTimeline; },
/* harmony export */   "Bone": function() { return /* reexport safe */ _core_Bone_mjs__WEBPACK_IMPORTED_MODULE_13__.Bone; },
/* harmony export */   "BoneData": function() { return /* reexport safe */ _core_BoneData_mjs__WEBPACK_IMPORTED_MODULE_14__.BoneData; },
/* harmony export */   "BoundingBoxAttachment": function() { return /* reexport safe */ _core_attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__.BoundingBoxAttachment; },
/* harmony export */   "ClippingAttachment": function() { return /* reexport safe */ _core_attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.ClippingAttachment; },
/* harmony export */   "ColorTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ColorTimeline; },
/* harmony export */   "ConstraintData": function() { return /* reexport safe */ _core_Constraint_mjs__WEBPACK_IMPORTED_MODULE_15__.ConstraintData; },
/* harmony export */   "CurveTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.CurveTimeline; },
/* harmony export */   "DeformTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DeformTimeline; },
/* harmony export */   "DrawOrderTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.DrawOrderTimeline; },
/* harmony export */   "Event": function() { return /* reexport safe */ _core_Event_mjs__WEBPACK_IMPORTED_MODULE_16__.Event; },
/* harmony export */   "EventData": function() { return /* reexport safe */ _core_EventData_mjs__WEBPACK_IMPORTED_MODULE_17__.EventData; },
/* harmony export */   "EventQueue": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.EventQueue; },
/* harmony export */   "EventTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.EventTimeline; },
/* harmony export */   "EventType": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.EventType; },
/* harmony export */   "IkConstraint": function() { return /* reexport safe */ _core_IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_18__.IkConstraint; },
/* harmony export */   "IkConstraintData": function() { return /* reexport safe */ _core_IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_19__.IkConstraintData; },
/* harmony export */   "IkConstraintTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.IkConstraintTimeline; },
/* harmony export */   "JitterEffect": function() { return /* reexport safe */ _core_vertexeffects_JitterEffect_mjs__WEBPACK_IMPORTED_MODULE_7__.JitterEffect; },
/* harmony export */   "MeshAttachment": function() { return /* reexport safe */ _core_attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.MeshAttachment; },
/* harmony export */   "PathAttachment": function() { return /* reexport safe */ _core_attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.PathAttachment; },
/* harmony export */   "PathConstraint": function() { return /* reexport safe */ _core_PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_20__.PathConstraint; },
/* harmony export */   "PathConstraintData": function() { return /* reexport safe */ _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_21__.PathConstraintData; },
/* harmony export */   "PathConstraintMixTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintMixTimeline; },
/* harmony export */   "PathConstraintPositionTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintPositionTimeline; },
/* harmony export */   "PathConstraintSpacingTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.PathConstraintSpacingTimeline; },
/* harmony export */   "PointAttachment": function() { return /* reexport safe */ _core_attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__.PointAttachment; },
/* harmony export */   "RegionAttachment": function() { return /* reexport safe */ _core_attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__.RegionAttachment; },
/* harmony export */   "RotateTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.RotateTimeline; },
/* harmony export */   "ScaleTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ScaleTimeline; },
/* harmony export */   "ShearTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.ShearTimeline; },
/* harmony export */   "Skeleton": function() { return /* reexport safe */ _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_22__.Skeleton; },
/* harmony export */   "SkeletonBinary": function() { return /* reexport safe */ _core_SkeletonBinary_mjs__WEBPACK_IMPORTED_MODULE_23__.SkeletonBinary; },
/* harmony export */   "SkeletonBounds": function() { return /* reexport safe */ _core_SkeletonBounds_mjs__WEBPACK_IMPORTED_MODULE_24__.SkeletonBounds; },
/* harmony export */   "SkeletonData": function() { return /* reexport safe */ _core_SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_25__.SkeletonData; },
/* harmony export */   "SkeletonJson": function() { return /* reexport safe */ _core_SkeletonJson_mjs__WEBPACK_IMPORTED_MODULE_26__.SkeletonJson; },
/* harmony export */   "Skin": function() { return /* reexport safe */ _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_27__.Skin; },
/* harmony export */   "SkinEntry": function() { return /* reexport safe */ _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_27__.SkinEntry; },
/* harmony export */   "Slot": function() { return /* reexport safe */ _core_Slot_mjs__WEBPACK_IMPORTED_MODULE_28__.Slot; },
/* harmony export */   "SlotData": function() { return /* reexport safe */ _core_SlotData_mjs__WEBPACK_IMPORTED_MODULE_29__.SlotData; },
/* harmony export */   "SpacingMode": function() { return /* reexport safe */ _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_21__.SpacingMode; },
/* harmony export */   "Spine": function() { return /* reexport safe */ _Spine_mjs__WEBPACK_IMPORTED_MODULE_32__.Spine; },
/* harmony export */   "SwirlEffect": function() { return /* reexport safe */ _core_vertexeffects_SwirlEffect_mjs__WEBPACK_IMPORTED_MODULE_8__.SwirlEffect; },
/* harmony export */   "TimelineType": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TimelineType; },
/* harmony export */   "TrackEntry": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__.TrackEntry; },
/* harmony export */   "TransformConstraint": function() { return /* reexport safe */ _core_TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_30__.TransformConstraint; },
/* harmony export */   "TransformConstraintData": function() { return /* reexport safe */ _core_TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_31__.TransformConstraintData; },
/* harmony export */   "TransformConstraintTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraintTimeline; },
/* harmony export */   "TranslateTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TranslateTimeline; },
/* harmony export */   "TwoColorTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__.TwoColorTimeline; },
/* harmony export */   "VertexAttachment": function() { return /* reexport safe */ _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment; }
/* harmony export */ });
/* harmony import */ var _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _core_attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/attachments/BoundingBoxAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/BoundingBoxAttachment.mjs");
/* harmony import */ var _core_attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/attachments/ClippingAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/ClippingAttachment.mjs");
/* harmony import */ var _core_attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _core_attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _core_attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/attachments/PointAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/PointAttachment.mjs");
/* harmony import */ var _core_attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _core_vertexeffects_JitterEffect_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/vertexeffects/JitterEffect.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/JitterEffect.mjs");
/* harmony import */ var _core_vertexeffects_SwirlEffect_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/vertexeffects/SwirlEffect.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/vertexeffects/SwirlEffect.mjs");
/* harmony import */ var _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/Animation.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Animation.mjs");
/* harmony import */ var _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AnimationState.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationState.mjs");
/* harmony import */ var _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/AnimationStateData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AnimationStateData.mjs");
/* harmony import */ var _core_AtlasAttachmentLoader_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/AtlasAttachmentLoader.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/AtlasAttachmentLoader.mjs");
/* harmony import */ var _core_Bone_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/Bone.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Bone.mjs");
/* harmony import */ var _core_BoneData_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./core/BoneData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/BoneData.mjs");
/* harmony import */ var _core_Constraint_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./core/Constraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Constraint.mjs");
/* harmony import */ var _core_Event_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./core/Event.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Event.mjs");
/* harmony import */ var _core_EventData_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./core/EventData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/EventData.mjs");
/* harmony import */ var _core_IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./core/IkConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraint.mjs");
/* harmony import */ var _core_IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./core/IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/IkConstraintData.mjs");
/* harmony import */ var _core_PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./core/PathConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraint.mjs");
/* harmony import */ var _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./core/PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/PathConstraintData.mjs");
/* harmony import */ var _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./core/Skeleton.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Skeleton.mjs");
/* harmony import */ var _core_SkeletonBinary_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./core/SkeletonBinary.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBinary.mjs");
/* harmony import */ var _core_SkeletonBounds_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./core/SkeletonBounds.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonBounds.mjs");
/* harmony import */ var _core_SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./core/SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonData.mjs");
/* harmony import */ var _core_SkeletonJson_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./core/SkeletonJson.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SkeletonJson.mjs");
/* harmony import */ var _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./core/Skin.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Skin.mjs");
/* harmony import */ var _core_Slot_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./core/Slot.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/Slot.mjs");
/* harmony import */ var _core_SlotData_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./core/SlotData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/SlotData.mjs");
/* harmony import */ var _core_TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./core/TransformConstraint.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraint.mjs");
/* harmony import */ var _core_TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./core/TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _Spine_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./Spine.mjs */ "./node_modules/@pixi-spine/runtime-3.8/lib/Spine.mjs");

































//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/Spine.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/Spine.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spine": function() { return /* binding */ Spine; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/Skeleton.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Skeleton.mjs");
/* harmony import */ var _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/AnimationState.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationState.mjs");
/* harmony import */ var _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/AnimationStateData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationStateData.mjs");





class Spine extends _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.SpineBase {
  createSkeleton(spineData) {
    this.skeleton = new _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_1__.Skeleton(spineData);
    this.skeleton.updateWorldTransform();
    this.stateData = new _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_3__.AnimationStateData(spineData);
    this.state = new _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_2__.AnimationState(this.stateData);
  }
}


//# sourceMappingURL=Spine.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlphaTimeline": function() { return /* binding */ AlphaTimeline; },
/* harmony export */   "Animation": function() { return /* binding */ Animation; },
/* harmony export */   "AttachmentTimeline": function() { return /* binding */ AttachmentTimeline; },
/* harmony export */   "CurveTimeline": function() { return /* binding */ CurveTimeline; },
/* harmony export */   "CurveTimeline1": function() { return /* binding */ CurveTimeline1; },
/* harmony export */   "CurveTimeline2": function() { return /* binding */ CurveTimeline2; },
/* harmony export */   "DeformTimeline": function() { return /* binding */ DeformTimeline; },
/* harmony export */   "DrawOrderTimeline": function() { return /* binding */ DrawOrderTimeline; },
/* harmony export */   "EventTimeline": function() { return /* binding */ EventTimeline; },
/* harmony export */   "IkConstraintTimeline": function() { return /* binding */ IkConstraintTimeline; },
/* harmony export */   "PathConstraintMixTimeline": function() { return /* binding */ PathConstraintMixTimeline; },
/* harmony export */   "PathConstraintPositionTimeline": function() { return /* binding */ PathConstraintPositionTimeline; },
/* harmony export */   "PathConstraintSpacingTimeline": function() { return /* binding */ PathConstraintSpacingTimeline; },
/* harmony export */   "RGB2Timeline": function() { return /* binding */ RGB2Timeline; },
/* harmony export */   "RGBA2Timeline": function() { return /* binding */ RGBA2Timeline; },
/* harmony export */   "RGBATimeline": function() { return /* binding */ RGBATimeline; },
/* harmony export */   "RGBTimeline": function() { return /* binding */ RGBTimeline; },
/* harmony export */   "RotateTimeline": function() { return /* binding */ RotateTimeline; },
/* harmony export */   "ScaleTimeline": function() { return /* binding */ ScaleTimeline; },
/* harmony export */   "ScaleXTimeline": function() { return /* binding */ ScaleXTimeline; },
/* harmony export */   "ScaleYTimeline": function() { return /* binding */ ScaleYTimeline; },
/* harmony export */   "SequenceTimeline": function() { return /* binding */ SequenceTimeline; },
/* harmony export */   "ShearTimeline": function() { return /* binding */ ShearTimeline; },
/* harmony export */   "ShearXTimeline": function() { return /* binding */ ShearXTimeline; },
/* harmony export */   "ShearYTimeline": function() { return /* binding */ ShearYTimeline; },
/* harmony export */   "Timeline": function() { return /* binding */ Timeline; },
/* harmony export */   "TransformConstraintTimeline": function() { return /* binding */ TransformConstraintTimeline; },
/* harmony export */   "TranslateTimeline": function() { return /* binding */ TranslateTimeline; },
/* harmony export */   "TranslateXTimeline": function() { return /* binding */ TranslateXTimeline; },
/* harmony export */   "TranslateYTimeline": function() { return /* binding */ TranslateYTimeline; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");





class Animation {
  constructor(name, timelines, duration) {
    this.timelines = [];
    this.timelineIds = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.StringSet();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
    this.setTimelines(timelines);
    this.duration = duration;
  }
  setTimelines(timelines) {
    if (!timelines)
      throw new Error("timelines cannot be null.");
    this.timelines = timelines;
    this.timelineIds.clear();
    for (let i = 0; i < timelines.length; i++)
      this.timelineIds.addAll(timelines[i].getPropertyIds());
  }
  hasTimeline(ids) {
    for (let i = 0; i < ids.length; i++)
      if (this.timelineIds.contains(ids[i]))
        return true;
    return false;
  }
  /** Applies all the animation's timelines to the specified skeleton.
   *
   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.
   * @param loop If true, the animation repeats after {@link #getDuration()}.
   * @param events May be null to ignore fired events. */
  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (loop && this.duration != 0) {
      time %= this.duration;
      if (lastTime > 0)
        lastTime %= this.duration;
    }
    const timelines = this.timelines;
    for (let i = 0, n = timelines.length; i < n; i++)
      timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
  }
}
const Property = {
  rotate: 0,
  x: 1,
  y: 2,
  scaleX: 3,
  scaleY: 4,
  shearX: 5,
  shearY: 6,
  rgb: 7,
  alpha: 8,
  rgb2: 9,
  attachment: 10,
  deform: 11,
  event: 12,
  drawOrder: 13,
  ikConstraint: 14,
  transformConstraint: 15,
  pathConstraintPosition: 16,
  pathConstraintSpacing: 17,
  pathConstraintMix: 18,
  sequence: 19
};
class Timeline {
  constructor(frameCount, propertyIds) {
    this.propertyIds = propertyIds;
    this.frames = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(frameCount * this.getFrameEntries());
  }
  getPropertyIds() {
    return this.propertyIds;
  }
  getFrameEntries() {
    return 1;
  }
  getFrameCount() {
    return this.frames.length / this.getFrameEntries();
  }
  getDuration() {
    return this.frames[this.frames.length - this.getFrameEntries()];
  }
  static search1(frames, time) {
    const n = frames.length;
    for (let i = 1; i < n; i++)
      if (frames[i] > time)
        return i - 1;
    return n - 1;
  }
  static search(frames, time, step) {
    const n = frames.length;
    for (let i = step; i < n; i += step)
      if (frames[i] > time)
        return i - step;
    return n - step;
  }
}
class CurveTimeline extends Timeline {
  // type, x, y, ...
  constructor(frameCount, bezierCount, propertyIds) {
    super(frameCount, propertyIds);
    this.curves = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(
      frameCount + bezierCount * 18
      /* BEZIER_SIZE*/
    );
    this.curves[frameCount - 1] = 1;
  }
  /** Sets the specified key frame to linear interpolation. */
  setLinear(frame) {
    this.curves[frame] = 0;
  }
  /** Sets the specified key frame to stepped interpolation. */
  setStepped(frame) {
    this.curves[frame] = 1;
  }
  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger
   * than the actual number of Bezier curves. */
  shrink(bezierCount) {
    const size = this.getFrameCount() + bezierCount * 18;
    if (this.curves.length > size) {
      const newCurves = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(size);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.curves, 0, newCurves, 0, size);
      this.curves = newCurves;
    }
  }
  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than
   * one curve per frame.
   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified
   *           in the constructor), inclusive.
   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.
   * @param value The index of the value for this frame that this curve is used for.
   * @param time1 The time for the first key.
   * @param value1 The value for the first key.
   * @param cx1 The time for the first Bezier handle.
   * @param cy1 The value for the first Bezier handle.
   * @param cx2 The time of the second Bezier handle.
   * @param cy2 The value for the second Bezier handle.
   * @param time2 The time for the second key.
   * @param value2 The value for the second key. */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = value1 + dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  /** Returns the Bezier interpolated value for the specified time.
   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.
   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.
   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */
  getBezierValue(time, frameIndex, valueOffset, i) {
    const curves = this.curves;
    if (curves[i] > time) {
      const x2 = this.frames[frameIndex];
      const y2 = this.frames[frameIndex + valueOffset];
      return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    frameIndex += this.getFrameEntries();
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);
  }
}
class CurveTimeline1 extends CurveTimeline {
  constructor(frameCount, bezierCount, propertyId) {
    super(frameCount, bezierCount, [propertyId]);
  }
  getFrameEntries() {
    return 2;
  }
  /** Sets the time and value for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value) {
    frame <<= 1;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE*/
    ] = value;
  }
  /** Returns the interpolated value for the specified time. */
  getCurveValue(time) {
    const frames = this.frames;
    let i = frames.length - 2;
    for (let ii = 2; ii <= i; ii += 2) {
      if (frames[ii] > time) {
        i = ii - 2;
        break;
      }
    }
    const curveType = this.curves[i >> 1];
    switch (curveType) {
      case 0:
        const before = frames[i];
        const value = frames[
          i + 1
          /* VALUE*/
        ];
        return value + (time - before) / (frames[
          i + 2
          /* ENTRIES*/
        ] - before) * (frames[
          i + 2 + 1
          /* VALUE*/
        ] - value);
      case 1:
        return frames[
          i + 1
          /* VALUE*/
        ];
    }
    return this.getBezierValue(
      time,
      i,
      1,
      curveType - 2
      /* BEZIER*/
    );
  }
}
class CurveTimeline2 extends CurveTimeline {
  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.
   * @param propertyIds Unique identifiers for the properties the timeline modifies. */
  constructor(frameCount, bezierCount, propertyId1, propertyId2) {
    super(frameCount, bezierCount, [propertyId1, propertyId2]);
  }
  getFrameEntries() {
    return 3;
  }
  /** Sets the time and values for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time The frame time in seconds. */
  setFrame(frame, time, value1, value2) {
    frame *= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* VALUE1*/
    ] = value1;
    this.frames[
      frame + 2
      /* VALUE2*/
    ] = value2;
  }
}
class RotateTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.rotation = bone.data.rotation;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;
      }
      return;
    }
    let r = this.getCurveValue(time);
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.rotation = bone.data.rotation + r * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        r += bone.data.rotation - bone.rotation;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.rotation += r * alpha;
    }
  }
}
class TranslateTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.x = bone.data.x;
          bone.y = bone.data.y;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        bone.y = bone.data.y + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.x += x * alpha;
        bone.y += y * alpha;
    }
  }
}
class TranslateXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.x = bone.data.x;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.x += (bone.data.x - bone.x) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.x = bone.data.x + x * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.x += (bone.data.x + x - bone.x) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.x += x * alpha;
    }
  }
}
class TranslateYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.y = bone.data.y;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.y += (bone.data.y - bone.y) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.y = bone.data.y + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.y += (bone.data.y + y - bone.y) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.y += y * alpha;
    }
  }
}
class ScaleTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          bone.scaleY = bone.data.scaleY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    x *= bone.data.scaleX;
    y *= bone.data.scaleY;
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
        bone.scaleX += x - bone.data.scaleX;
        bone.scaleY += y - bone.data.scaleY;
      } else {
        bone.scaleX = x;
        bone.scaleY = y;
      }
    } else {
      let bx = 0;
      let by = 0;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = bone.data.scaleX;
            by = bone.data.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = bone.scaleX;
            by = bone.scaleY;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = Math.abs(bone.data.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            by = Math.abs(bone.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
}
class ScaleXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.scaleX = bone.data.scaleX;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time) * bone.data.scaleX;
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add)
        bone.scaleX += x - bone.data.scaleX;
      else
        bone.scaleX = x;
    } else {
      let bx = 0;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = bone.data.scaleX;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = bone.scaleX;
            bone.scaleX = bx + (Math.abs(x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(bx) - bx) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            bx = Math.abs(bone.data.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            bx = Math.abs(bone.scaleX) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(x);
            bone.scaleX = bx + (x - bx) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bone.scaleX += (x - bone.data.scaleX) * alpha;
        }
      }
    }
  }
}
class ScaleYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.scaleY = bone.data.scaleY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time) * bone.data.scaleY;
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add)
        bone.scaleY += y - bone.data.scaleY;
      else
        bone.scaleY = y;
    } else {
      let by = 0;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            by = bone.data.scaleY;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            by = bone.scaleY;
            bone.scaleY = by + (Math.abs(y) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(by) - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
            by = Math.abs(bone.data.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            by = Math.abs(bone.scaleY) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.signum(y);
            bone.scaleY = by + (y - by) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            bone.scaleY += (y - bone.data.scaleY) * alpha;
        }
      }
    }
  }
}
class ShearTimeline extends CurveTimeline2 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          bone.shearY = bone.data.shearY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    let x = 0;
    let y = 0;
    const i = Timeline.search(
      frames,
      time,
      3
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 3
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        const t = (time - before) / (frames[
          i + 3
          /* ENTRIES*/
        ] - before);
        x += (frames[
          i + 3 + 1
          /* VALUE1*/
        ] - x) * t;
        y += (frames[
          i + 3 + 2
          /* VALUE2*/
        ] - y) * t;
        break;
      case 1:
        x = frames[
          i + 1
          /* VALUE1*/
        ];
        y = frames[
          i + 2
          /* VALUE2*/
        ];
        break;
      default:
        x = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.shearX += x * alpha;
        bone.shearY += y * alpha;
    }
  }
}
class ShearXTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.shearX = bone.data.shearX;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
      }
      return;
    }
    const x = this.getCurveValue(time);
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.shearX = bone.data.shearX + x * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.shearX += x * alpha;
    }
  }
}
class ShearYTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, boneIndex) {
    super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);
    this.boneIndex = 0;
    this.boneIndex = boneIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const bone = skeleton.bones[this.boneIndex];
    if (!bone.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          bone.shearY = bone.data.shearY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
      }
      return;
    }
    const y = this.getCurveValue(time);
    switch (blend) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
        bone.shearY = bone.data.shearY + y * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
        bone.shearY += y * alpha;
    }
  }
}
class RGBATimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 5;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b, a) {
    frame *= 5;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          color.setFromColor(setup);
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    const i = Timeline.search(
      frames,
      time,
      5
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 5
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        const t = (time - before) / (frames[
          i + 5
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 5 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 5 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 5 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 5 + 4
          /* A*/
        ] - a) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1)
      color.set(r, g, b, a);
    else {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
        color.setFromColor(slot.data.color);
      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
    }
  }
}
class RGBTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 4;
  }
  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */
  setFrame(frame, time, r, g, b) {
    frame <<= 2;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const color = slot.color;
    if (time < frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          color.r = setup.r;
          color.g = setup.g;
          color.b = setup.b;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          color.r += (setup.r - color.r) * alpha;
          color.g += (setup.g - color.g) * alpha;
          color.b += (setup.b - color.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 4 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 4 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 4 + 3
          /* B*/
        ] - b) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      color.r = r;
      color.g = g;
      color.b = b;
    } else {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
        const setup = slot.data.color;
        color.r = setup.r;
        color.g = setup.g;
        color.b = setup.b;
      }
      color.r += (r - color.r) * alpha;
      color.g += (g - color.g) * alpha;
      color.b += (b - color.b) * alpha;
    }
  }
}
class AlphaTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const color = slot.color;
    if (time < this.frames[0]) {
      const setup = slot.data.color;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          color.a = setup.a;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          color.a += (setup.a - color.a) * alpha;
      }
      return;
    }
    const a = this.getCurveValue(time);
    if (alpha == 1)
      color.a = a;
    else {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
        color.a = slot.data.color.a;
      color.a += (a - color.a) * alpha;
    }
  }
}
class RGBA2Timeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 8;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, a, r2, g2, b2) {
    frame <<= 3;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* A*/
    ] = a;
    this.frames[
      frame + 5
      /* R2*/
    ] = r2;
    this.frames[
      frame + 6
      /* G2*/
    ] = g2;
    this.frames[
      frame + 7
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          light.setFromColor(setupLight);
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let a = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      8
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 3];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 8
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 8 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 8 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 8 + 3
          /* B*/
        ] - b) * t;
        a += (frames[
          i + 8 + 4
          /* A*/
        ] - a) * t;
        r2 += (frames[
          i + 8 + 5
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 8 + 6
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 8 + 7
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        a = frames[
          i + 4
          /* A*/
        ];
        r2 = frames[
          i + 5
          /* R2*/
        ];
        g2 = frames[
          i + 6
          /* G2*/
        ];
        b2 = frames[
          i + 7
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        a = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          7,
          curveType + 18 * 6 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.set(r, g, b, a);
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
        light.setFromColor(slot.data.color);
        const setupDark = slot.data.darkColor;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
}
class RGB2Timeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex) {
    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** Sets the time in seconds, light, and dark colors for the specified key frame. */
  setFrame(frame, time, r, g, b, r2, g2, b2) {
    frame *= 7;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* R*/
    ] = r;
    this.frames[
      frame + 2
      /* G*/
    ] = g;
    this.frames[
      frame + 3
      /* B*/
    ] = b;
    this.frames[
      frame + 4
      /* R2*/
    ] = r2;
    this.frames[
      frame + 5
      /* G2*/
    ] = g2;
    this.frames[
      frame + 6
      /* B2*/
    ] = b2;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const frames = this.frames;
    const light = slot.color;
    const dark = slot.darkColor;
    if (time < frames[0]) {
      const setupLight = slot.data.color;
      const setupDark = slot.data.darkColor;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          light.r = setupLight.r;
          light.g = setupLight.g;
          light.b = setupLight.b;
          dark.r = setupDark.r;
          dark.g = setupDark.g;
          dark.b = setupDark.b;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          light.r += (setupLight.r - light.r) * alpha;
          light.g += (setupLight.g - light.g) * alpha;
          light.b += (setupLight.b - light.b) * alpha;
          dark.r += (setupDark.r - dark.r) * alpha;
          dark.g += (setupDark.g - dark.g) * alpha;
          dark.b += (setupDark.b - dark.b) * alpha;
      }
      return;
    }
    let r = 0;
    let g = 0;
    let b = 0;
    let r2 = 0;
    let g2 = 0;
    let b2 = 0;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        r += (frames[
          i + 7 + 1
          /* R*/
        ] - r) * t;
        g += (frames[
          i + 7 + 2
          /* G*/
        ] - g) * t;
        b += (frames[
          i + 7 + 3
          /* B*/
        ] - b) * t;
        r2 += (frames[
          i + 7 + 4
          /* R2*/
        ] - r2) * t;
        g2 += (frames[
          i + 7 + 5
          /* G2*/
        ] - g2) * t;
        b2 += (frames[
          i + 7 + 6
          /* B2*/
        ] - b2) * t;
        break;
      case 1:
        r = frames[
          i + 1
          /* R*/
        ];
        g = frames[
          i + 2
          /* G*/
        ];
        b = frames[
          i + 3
          /* B*/
        ];
        r2 = frames[
          i + 4
          /* R2*/
        ];
        g2 = frames[
          i + 5
          /* G2*/
        ];
        b2 = frames[
          i + 6
          /* B2*/
        ];
        break;
      default:
        r = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        g = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        b = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        r2 = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        g2 = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        b2 = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (alpha == 1) {
      light.r = r;
      light.g = g;
      light.b = b;
      dark.r = r2;
      dark.g = g2;
      dark.b = b2;
    } else {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
        const setupLight = slot.data.color;
        const setupDark = slot.data.darkColor;
        light.r = setupLight.r;
        light.g = setupLight.g;
        light.b = setupLight.b;
        dark.r = setupDark.r;
        dark.g = setupDark.g;
        dark.b = setupDark.b;
      }
      light.r += (r - light.r) * alpha;
      light.g += (g - light.g) * alpha;
      light.b += (b - light.b) * alpha;
      dark.r += (r2 - dark.r) * alpha;
      dark.g += (g2 - dark.g) * alpha;
      dark.b += (b2 - dark.b) * alpha;
    }
  }
}
class AttachmentTimeline extends Timeline {
  constructor(frameCount, slotIndex) {
    super(frameCount, [`${Property.attachment}|${slotIndex}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachmentNames = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the attachment name for the specified key frame. */
  setFrame(frame, time, attachmentName) {
    this.frames[frame] = time;
    this.attachmentNames[frame] = attachmentName;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName);
      return;
    }
    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);
  }
  setAttachment(skeleton, slot, attachmentName) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
  }
}
class DeformTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, slotIndex, attachment) {
    super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);
    this.slotIndex = 0;
    this.slotIndex = slotIndex;
    this.attachment = attachment;
    this.vertices = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the vertices for the specified key frame.
   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */
  setFrame(frame, time, vertices) {
    this.frames[frame] = time;
    this.vertices[frame] = vertices;
  }
  /** @param value1 Ignored (0 is used for a deform timeline).
   * @param value2 Ignored (1 is used for a deform timeline). */
  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
    const curves = this.curves;
    let i = this.getFrameCount() + bezier * 18;
    if (value == 0)
      curves[frame] = 2 + i;
    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;
    const tmpy = cy2 * 0.03 - cy1 * 0.06;
    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;
    const dddy = (cy1 - cy2 + 0.33333333) * 0.018;
    let ddx = tmpx * 2 + dddx;
    let ddy = tmpy * 2 + dddy;
    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;
    let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;
    let x = time1 + dx;
    let y = dy;
    for (let n = i + 18; i < n; i += 2) {
      curves[i] = x;
      curves[i + 1] = y;
      dx += ddx;
      dy += ddy;
      ddx += dddx;
      ddy += dddy;
      x += dx;
      y += dy;
    }
  }
  getCurvePercent(time, frame) {
    const curves = this.curves;
    let i = curves[frame];
    switch (i) {
      case 0:
        const x2 = this.frames[frame];
        return (time - x2) / (this.frames[frame + this.getFrameEntries()] - x2);
      case 1:
        return 0;
    }
    i -= 2;
    if (curves[i] > time) {
      const x2 = this.frames[frame];
      return curves[i + 1] * (time - x2) / (curves[i] - x2);
    }
    const n = i + 18;
    for (i += 2; i < n; i += 2) {
      if (curves[i] >= time) {
        const x2 = curves[i - 2];
        const y2 = curves[i - 1];
        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);
      }
    }
    const x = curves[n - 2];
    const y = curves[n - 1];
    return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.getAttachment();
    if (!slotAttachment)
      return;
    if (!(slotAttachment instanceof _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment) || slotAttachment.timelineAttachment != this.attachment)
      return;
    const deform = slot.deform;
    if (deform.length == 0)
      blend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup;
    const vertices = this.vertices;
    const vertexCount = vertices[0].length;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          deform.length = 0;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          if (alpha == 1) {
            deform.length = 0;
            return;
          }
          deform.length = vertexCount;
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (setupVertices[i] - deform[i]) * alpha;
          } else {
            alpha = 1 - alpha;
            for (let i = 0; i < vertexCount; i++)
              deform[i] *= alpha;
          }
      }
      return;
    }
    deform.length = vertexCount;
    if (time >= frames[frames.length - 1]) {
      const lastVertices = vertices[frames.length - 1];
      if (alpha == 1) {
        if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i] - setupVertices[i];
          } else {
            for (let i = 0; i < vertexCount; i++)
              deform[i] += lastVertices[i];
          }
        } else
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
      } else {
        switch (blend) {
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup: {
            const vertexAttachment2 = slotAttachment;
            if (!vertexAttachment2.bones) {
              const setupVertices = vertexAttachment2.vertices;
              for (let i = 0; i < vertexCount; i++) {
                const setup = setupVertices[i];
                deform[i] = setup + (lastVertices[i] - setup) * alpha;
              }
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] = lastVertices[i] * alpha;
            }
            break;
          }
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
            for (let i = 0; i < vertexCount; i++)
              deform[i] += (lastVertices[i] - deform[i]) * alpha;
            break;
          case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
            const vertexAttachment = slotAttachment;
            if (!vertexAttachment.bones) {
              const setupVertices = vertexAttachment.vertices;
              for (let i = 0; i < vertexCount; i++)
                deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;
            } else {
              for (let i = 0; i < vertexCount; i++)
                deform[i] += lastVertices[i] * alpha;
            }
        }
      }
      return;
    }
    const frame = Timeline.search1(frames, time);
    const percent = this.getCurvePercent(time, frame);
    const prevVertices = vertices[frame];
    const nextVertices = vertices[frame + 1];
    if (alpha == 1) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add) {
        const vertexAttachment = slotAttachment;
        if (!vertexAttachment.bones) {
          const setupVertices = vertexAttachment.vertices;
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];
          }
        } else {
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += prev + (nextVertices[i] - prev) * percent;
          }
        }
      } else {
        for (let i = 0; i < vertexCount; i++) {
          const prev = prevVertices[i];
          deform[i] = prev + (nextVertices[i] - prev) * percent;
        }
      }
    } else {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup: {
          const vertexAttachment2 = slotAttachment;
          if (!vertexAttachment2.bones) {
            const setupVertices = vertexAttachment2.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              const setup = setupVertices[i];
              deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
          break;
        }
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.replace:
          for (let i = 0; i < vertexCount; i++) {
            const prev = prevVertices[i];
            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;
          }
          break;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.add:
          const vertexAttachment = slotAttachment;
          if (!vertexAttachment.bones) {
            const setupVertices = vertexAttachment.vertices;
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;
            }
          } else {
            for (let i = 0; i < vertexCount; i++) {
              const prev = prevVertices[i];
              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          }
      }
    }
  }
}
const _EventTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _EventTimeline.propertyIds);
    this.events = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the event for the specified key frame. */
  setFrame(frame, event) {
    this.frames[frame] = event.time;
    this.events[frame] = event;
  }
  /** Fires events for frames > `lastTime` and <= `time`. */
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (!firedEvents)
      return;
    const frames = this.frames;
    const frameCount = this.frames.length;
    if (lastTime > time) {
      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
      lastTime = -1;
    } else if (lastTime >= frames[frameCount - 1])
      return;
    if (time < frames[0])
      return;
    let i = 0;
    if (lastTime < frames[0])
      i = 0;
    else {
      i = Timeline.search1(frames, lastTime) + 1;
      const frameTime = frames[i];
      while (i > 0) {
        if (frames[i - 1] != frameTime)
          break;
        i--;
      }
    }
    for (; i < frameCount && time >= frames[i]; i++)
      firedEvents.push(this.events[i]);
  }
};
let EventTimeline = _EventTimeline;
EventTimeline.propertyIds = [`${Property.event}`];
const _DrawOrderTimeline = class extends Timeline {
  constructor(frameCount) {
    super(frameCount, _DrawOrderTimeline.propertyIds);
    this.drawOrders = new Array(frameCount);
  }
  getFrameCount() {
    return this.frames.length;
  }
  /** Sets the time in seconds and the draw order for the specified key frame.
   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose
   *           draw order. */
  setFrame(frame, time, drawOrder) {
    this.frames[frame] = time;
    this.drawOrders[frame] = drawOrder;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    if (time < this.frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
      return;
    }
    const idx = Timeline.search1(this.frames, time);
    const drawOrderToSetupIndex = this.drawOrders[idx];
    if (!drawOrderToSetupIndex)
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
    else {
      const drawOrder = skeleton.drawOrder;
      const slots = skeleton.slots;
      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)
        drawOrder[i] = slots[drawOrderToSetupIndex[i]];
    }
  }
};
let DrawOrderTimeline = _DrawOrderTimeline;
DrawOrderTimeline.propertyIds = [`${Property.drawOrder}`];
class IkConstraintTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, ikConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);
    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */
    this.ikConstraintIndex = 0;
    this.ikConstraintIndex = ikConstraintIndex;
  }
  getFrameEntries() {
    return 6;
  }
  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */
  setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {
    frame *= 6;
    this.frames[frame] = time;
    this.frames[
      frame + 1
      /* MIX*/
    ] = mix;
    this.frames[
      frame + 2
      /* SOFTNESS*/
    ] = softness;
    this.frames[
      frame + 3
      /* BEND_DIRECTION*/
    ] = bendDirection;
    this.frames[
      frame + 4
      /* COMPRESS*/
    ] = compress ? 1 : 0;
    this.frames[
      frame + 5
      /* STRETCH*/
    ] = stretch ? 1 : 0;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.mix = constraint.data.mix;
          constraint.softness = constraint.data.softness;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
          constraint.bendDirection = constraint.data.bendDirection;
          constraint.compress = constraint.data.compress;
          constraint.stretch = constraint.data.stretch;
      }
      return;
    }
    let mix = 0;
    let softness = 0;
    const i = Timeline.search(
      frames,
      time,
      6
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 6
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        const t = (time - before) / (frames[
          i + 6
          /* ENTRIES*/
        ] - before);
        mix += (frames[
          i + 6 + 1
          /* MIX*/
        ] - mix) * t;
        softness += (frames[
          i + 6 + 2
          /* SOFTNESS*/
        ] - softness) * t;
        break;
      case 1:
        mix = frames[
          i + 1
          /* MIX*/
        ];
        softness = frames[
          i + 2
          /* SOFTNESS*/
        ];
        break;
      default:
        mix = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        softness = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixOut) {
        constraint.bendDirection = constraint.data.bendDirection;
        constraint.compress = constraint.data.compress;
        constraint.stretch = constraint.data.stretch;
      } else {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    } else {
      constraint.mix += (mix - constraint.mix) * alpha;
      constraint.softness += (softness - constraint.softness) * alpha;
      if (direction == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection.mixIn) {
        constraint.bendDirection = frames[
          i + 3
          /* BEND_DIRECTION*/
        ];
        constraint.compress = frames[
          i + 4
          /* COMPRESS*/
        ] != 0;
        constraint.stretch = frames[
          i + 5
          /* STRETCH*/
        ] != 0;
      }
    }
  }
}
class TransformConstraintTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, transformConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);
    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */
    this.transformConstraintIndex = 0;
    this.transformConstraintIndex = transformConstraintIndex;
  }
  getFrameEntries() {
    return 7;
  }
  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */
  setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
    const frames = this.frames;
    frame *= 7;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
    frames[
      frame + 4
      /* SCALEX*/
    ] = mixScaleX;
    frames[
      frame + 5
      /* SCALEY*/
    ] = mixScaleY;
    frames[
      frame + 6
      /* SHEARY*/
    ] = mixShearY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      const data = constraint.data;
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.mixRotate = data.mixRotate;
          constraint.mixX = data.mixX;
          constraint.mixY = data.mixY;
          constraint.mixScaleX = data.mixScaleX;
          constraint.mixScaleY = data.mixScaleY;
          constraint.mixShearY = data.mixShearY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (data.mixY - constraint.mixY) * alpha;
          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;
          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;
          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    let scaleX;
    let scaleY;
    let shearY;
    const i = Timeline.search(
      frames,
      time,
      7
      /* ENTRIES*/
    );
    const curveType = this.curves[
      i / 7
      /* ENTRIES*/
    ];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        const t = (time - before) / (frames[
          i + 7
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 7 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 7 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 7 + 3
          /* Y*/
        ] - y) * t;
        scaleX += (frames[
          i + 7 + 4
          /* SCALEX*/
        ] - scaleX) * t;
        scaleY += (frames[
          i + 7 + 5
          /* SCALEY*/
        ] - scaleY) * t;
        shearY += (frames[
          i + 7 + 6
          /* SHEARY*/
        ] - shearY) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        scaleX = frames[
          i + 4
          /* SCALEX*/
        ];
        scaleY = frames[
          i + 5
          /* SCALEY*/
        ];
        shearY = frames[
          i + 6
          /* SHEARY*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
        scaleX = this.getBezierValue(
          time,
          i,
          4,
          curveType + 18 * 3 - 2
          /* BEZIER*/
        );
        scaleY = this.getBezierValue(
          time,
          i,
          5,
          curveType + 18 * 4 - 2
          /* BEZIER*/
        );
        shearY = this.getBezierValue(
          time,
          i,
          6,
          curveType + 18 * 5 - 2
          /* BEZIER*/
        );
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;
      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;
      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;
      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;
      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;
    }
  }
}
class PathConstraintPositionTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);
    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.position = constraint.data.position;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.position += (constraint.data.position - constraint.position) * alpha;
      }
      return;
    }
    const position = this.getCurveValue(time);
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
      constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
    else
      constraint.position += (position - constraint.position) * alpha;
  }
}
class PathConstraintSpacingTimeline extends CurveTimeline1 {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);
    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.spacing = constraint.data.spacing;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
      }
      return;
    }
    const spacing = this.getCurveValue(time);
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup)
      constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
    else
      constraint.spacing += (spacing - constraint.spacing) * alpha;
  }
}
class PathConstraintMixTimeline extends CurveTimeline {
  constructor(frameCount, bezierCount, pathConstraintIndex) {
    super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);
    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */
    this.pathConstraintIndex = 0;
    this.pathConstraintIndex = pathConstraintIndex;
  }
  getFrameEntries() {
    return 4;
  }
  setFrame(frame, time, mixRotate, mixX, mixY) {
    const frames = this.frames;
    frame <<= 2;
    frames[frame] = time;
    frames[
      frame + 1
      /* ROTATE*/
    ] = mixRotate;
    frames[
      frame + 2
      /* X*/
    ] = mixX;
    frames[
      frame + 3
      /* Y*/
    ] = mixY;
  }
  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];
    if (!constraint.active)
      return;
    const frames = this.frames;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup:
          constraint.mixRotate = constraint.data.mixRotate;
          constraint.mixX = constraint.data.mixX;
          constraint.mixY = constraint.data.mixY;
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first:
          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
      }
      return;
    }
    let rotate;
    let x;
    let y;
    const i = Timeline.search(
      frames,
      time,
      4
      /* ENTRIES*/
    );
    const curveType = this.curves[i >> 2];
    switch (curveType) {
      case 0:
        const before = frames[i];
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        const t = (time - before) / (frames[
          i + 4
          /* ENTRIES*/
        ] - before);
        rotate += (frames[
          i + 4 + 1
          /* ROTATE*/
        ] - rotate) * t;
        x += (frames[
          i + 4 + 2
          /* X*/
        ] - x) * t;
        y += (frames[
          i + 4 + 3
          /* Y*/
        ] - y) * t;
        break;
      case 1:
        rotate = frames[
          i + 1
          /* ROTATE*/
        ];
        x = frames[
          i + 2
          /* X*/
        ];
        y = frames[
          i + 3
          /* Y*/
        ];
        break;
      default:
        rotate = this.getBezierValue(
          time,
          i,
          1,
          curveType - 2
          /* BEZIER*/
        );
        x = this.getBezierValue(
          time,
          i,
          2,
          curveType + 18 - 2
          /* BEZIER*/
        );
        y = this.getBezierValue(
          time,
          i,
          3,
          curveType + 18 * 2 - 2
          /* BEZIER*/
        );
    }
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup) {
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
      constraint.mixX = data.mixX + (x - data.mixX) * alpha;
      constraint.mixY = data.mixY + (y - data.mixY) * alpha;
    } else {
      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
      constraint.mixX += (x - constraint.mixX) * alpha;
      constraint.mixY += (y - constraint.mixY) * alpha;
    }
  }
}
const _SequenceTimeline = class extends Timeline {
  constructor(frameCount, slotIndex, attachment) {
    super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);
    this.slotIndex = slotIndex;
    this.attachment = attachment;
  }
  getFrameEntries() {
    return _SequenceTimeline.ENTRIES;
  }
  getSlotIndex() {
    return this.slotIndex;
  }
  getAttachment() {
    return this.attachment;
  }
  /** Sets the time, mode, index, and frame time for the specified frame.
   * @param frame Between 0 and <code>frameCount</code>, inclusive.
   * @param time Seconds between frames. */
  setFrame(frame, time, mode, index, delay) {
    const frames = this.frames;
    frame *= _SequenceTimeline.ENTRIES;
    frames[frame] = time;
    frames[frame + _SequenceTimeline.MODE] = mode | index << 4;
    frames[frame + _SequenceTimeline.DELAY] = delay;
  }
  apply(skeleton, lastTime, time, events, alpha, blend, direction) {
    const slot = skeleton.slots[this.slotIndex];
    if (!slot.bone.active)
      return;
    const slotAttachment = slot.attachment;
    const attachment = this.attachment;
    if (slotAttachment != attachment) {
      if (!(slotAttachment instanceof _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment) || slotAttachment.timelineAttachment != attachment)
        return;
    }
    const frames = this.frames;
    if (time < frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend.first)
        slot.sequenceIndex = -1;
      return;
    }
    const i = Timeline.search(frames, time, _SequenceTimeline.ENTRIES);
    const before = frames[i];
    const modeAndIndex = frames[i + _SequenceTimeline.MODE];
    const delay = frames[i + _SequenceTimeline.DELAY];
    if (!this.attachment.sequence)
      return;
    let index = modeAndIndex >> 4;
    const count = this.attachment.sequence.regions.length;
    const mode = _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceModeValues[modeAndIndex & 15];
    if (mode != _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceMode.hold) {
      index += (time - before) / delay + 1e-5 | 0;
      switch (mode) {
        case _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceMode.once:
          index = Math.min(count - 1, index);
          break;
        case _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceMode.loop:
          index %= count;
          break;
        case _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceMode.pingpong: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : index % n;
          if (index >= count)
            index = n - index;
          break;
        }
        case _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceMode.onceReverse:
          index = Math.max(count - 1 - index, 0);
          break;
        case _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceMode.loopReverse:
          index = count - 1 - index % count;
          break;
        case _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_3__.SequenceMode.pingpongReverse: {
          const n = (count << 1) - 2;
          index = n == 0 ? 0 : (index + count - 1) % n;
          if (index >= count)
            index = n - index;
        }
      }
    }
    slot.sequenceIndex = index;
  }
};
let SequenceTimeline = _SequenceTimeline;
SequenceTimeline.ENTRIES = 3;
SequenceTimeline.MODE = 1;
SequenceTimeline.DELAY = 2;


//# sourceMappingURL=Animation.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationState.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationState.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationState": function() { return /* binding */ AnimationState; },
/* harmony export */   "AnimationStateAdapter": function() { return /* binding */ AnimationStateAdapter; },
/* harmony export */   "EventQueue": function() { return /* binding */ EventQueue; },
/* harmony export */   "EventType": function() { return /* binding */ EventType; },
/* harmony export */   "TrackEntry": function() { return /* binding */ TrackEntry; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs");



const _AnimationState = class {
  constructor(data) {
    /** The list of tracks that currently have animations, which may contain null entries. */
    this.tracks = new Array();
    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower
     * or faster. Defaults to 1.
     *
     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */
    this.timeScale = 1;
    this.unkeyedState = 0;
    this.events = new Array();
    this.listeners = new Array();
    this.queue = new EventQueue(this);
    this.propertyIDs = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.StringSet();
    this.animationsChanged = false;
    this.trackEntryPool = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Pool(() => new TrackEntry());
    this.data = data;
  }
  static emptyAnimation() {
    return _AnimationState._emptyAnimation;
  }
  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */
  update(delta) {
    delta *= this.timeScale;
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current)
        continue;
      current.animationLast = current.nextAnimationLast;
      current.trackLast = current.nextTrackLast;
      let currentDelta = delta * current.timeScale;
      if (current.delay > 0) {
        current.delay -= currentDelta;
        if (current.delay > 0)
          continue;
        currentDelta = -current.delay;
        current.delay = 0;
      }
      let next = current.next;
      if (next) {
        const nextTime = current.trackLast - next.delay;
        if (nextTime >= 0) {
          next.delay = 0;
          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
          current.trackTime += currentDelta;
          this.setCurrent(i, next, true);
          while (next.mixingFrom) {
            next.mixTime += delta;
            next = next.mixingFrom;
          }
          continue;
        }
      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {
        tracks[i] = null;
        this.queue.end(current);
        this.clearNext(current);
        continue;
      }
      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {
        let from = current.mixingFrom;
        current.mixingFrom = null;
        if (from)
          from.mixingTo = null;
        while (from) {
          this.queue.end(from);
          from = from.mixingFrom;
        }
      }
      current.trackTime += currentDelta;
    }
    this.queue.drain();
  }
  /** Returns true when all mixing from entries are complete. */
  updateMixingFrom(to, delta) {
    const from = to.mixingFrom;
    if (!from)
      return true;
    const finished = this.updateMixingFrom(from, delta);
    from.animationLast = from.nextAnimationLast;
    from.trackLast = from.nextTrackLast;
    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
      if (from.totalAlpha == 0 || to.mixDuration == 0) {
        to.mixingFrom = from.mixingFrom;
        if (from.mixingFrom)
          from.mixingFrom.mixingTo = to;
        to.interruptAlpha = from.interruptAlpha;
        this.queue.end(from);
      }
      return finished;
    }
    from.trackTime += delta * from.timeScale;
    to.mixTime += delta;
    return false;
  }
  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the
   * animation state can be applied to multiple skeletons to pose them identically.
   * @returns True if any animations were applied. */
  apply(skeleton) {
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    if (this.animationsChanged)
      this._animationsChanged();
    const events = this.events;
    const tracks = this.tracks;
    let applied = false;
    for (let i = 0, n = tracks.length; i < n; i++) {
      const current = tracks[i];
      if (!current || current.delay > 0)
        continue;
      applied = true;
      const blend = i == 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first : current.mixBlend;
      let mix = current.alpha;
      if (current.mixingFrom)
        mix *= this.applyMixingFrom(current, skeleton, blend);
      else if (current.trackTime >= current.trackEnd && !current.next)
        mix = 0;
      const animationLast = current.animationLast;
      const animationTime = current.getAnimationTime();
      let applyTime = animationTime;
      let applyEvents = events;
      if (current.reverse) {
        applyTime = current.animation.duration - applyTime;
        applyEvents = null;
      }
      const timelines = current.animation.timelines;
      const timelineCount = timelines.length;
      if (i == 0 && mix == 1 || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add) {
        for (let ii = 0; ii < timelineCount; ii++) {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(mix, blend);
          const timeline = timelines[ii];
          if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline)
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          else
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
        }
      } else {
        const timelineMode = current.timelineMode;
        const shortestRotation = current.shortestRotation;
        const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;
        if (firstFrame)
          current.timelinesRotation.length = timelineCount << 1;
        for (let ii = 0; ii < timelineCount; ii++) {
          const timeline = timelines[ii];
          const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
          if (!shortestRotation && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline) {
            this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);
          } else if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline) {
            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);
          } else {
            _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(mix, blend);
            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
          }
        }
      }
      this.queueEvents(current, animationTime);
      events.length = 0;
      current.nextAnimationLast = animationTime;
      current.nextTrackLast = current.trackTime;
    }
    const setupState = this.unkeyedState + SETUP;
    const slots = skeleton.slots;
    for (let i = 0, n = skeleton.slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.attachmentState == setupState) {
        const attachmentName = slot.data.attachmentName;
        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
      }
    }
    this.unkeyedState += 2;
    this.queue.drain();
    return applied;
  }
  applyMixingFrom(to, skeleton, blend) {
    const from = to.mixingFrom;
    if (from.mixingFrom)
      this.applyMixingFrom(from, skeleton, blend);
    let mix = 0;
    if (to.mixDuration == 0) {
      mix = 1;
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        blend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
    } else {
      mix = to.mixTime / to.mixDuration;
      if (mix > 1)
        mix = 1;
      if (blend != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        blend = from.mixBlend;
    }
    const attachments = mix < from.attachmentThreshold;
    const drawOrder = mix < from.drawOrderThreshold;
    const timelines = from.animation.timelines;
    const timelineCount = timelines.length;
    const alphaHold = from.alpha * to.interruptAlpha;
    const alphaMix = alphaHold * (1 - mix);
    const animationLast = from.animationLast;
    const animationTime = from.getAnimationTime();
    let applyTime = animationTime;
    let events = null;
    if (from.reverse)
      applyTime = from.animation.duration - applyTime;
    else if (mix < from.eventThreshold)
      events = this.events;
    if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add) {
      for (let i = 0; i < timelineCount; i++)
        timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut);
    } else {
      const timelineMode = from.timelineMode;
      const timelineHoldMix = from.timelineHoldMix;
      const shortestRotation = from.shortestRotation;
      const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;
      if (firstFrame)
        from.timelinesRotation.length = timelineCount << 1;
      from.totalAlpha = 0;
      for (let i = 0; i < timelineCount; i++) {
        const timeline = timelines[i];
        let direction = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixOut;
        let timelineBlend;
        let alpha = 0;
        switch (timelineMode[i]) {
          case SUBSEQUENT:
            if (!drawOrder && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline)
              continue;
            timelineBlend = blend;
            alpha = alphaMix;
            break;
          case FIRST:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            alpha = alphaMix;
            break;
          case HOLD_SUBSEQUENT:
            timelineBlend = blend;
            alpha = alphaHold;
            break;
          case HOLD_FIRST:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            alpha = alphaHold;
            break;
          default:
            timelineBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup;
            const holdMix = timelineHoldMix[i];
            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
            break;
        }
        from.totalAlpha += alpha;
        if (!shortestRotation && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.RotateTimeline)
          this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);
        else if (timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline)
          this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);
        else {
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.webkit602BugfixHelper(alpha, blend);
          if (drawOrder && timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline && timelineBlend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup)
            direction = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn;
          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
        }
      }
    }
    if (to.mixDuration > 0)
      this.queueEvents(from, animationTime);
    this.events.length = 0;
    from.nextAnimationLast = animationTime;
    from.nextTrackLast = from.trackTime;
    return mix;
  }
  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {
    const slot = skeleton.slots[timeline.slotIndex];
    if (!slot.bone.active)
      return;
    if (time < timeline.frames[0]) {
      if (blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup || blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first)
        this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);
    } else
      this.setAttachment(skeleton, slot, timeline.attachmentNames[_Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.Timeline.search1(timeline.frames, time)], attachments);
    if (slot.attachmentState <= this.unkeyedState)
      slot.attachmentState = this.unkeyedState + SETUP;
  }
  setAttachment(skeleton, slot, attachmentName, attachments) {
    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));
    if (attachments)
      slot.attachmentState = this.unkeyedState + CURRENT;
  }
  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
    if (firstFrame)
      timelinesRotation[i] = 0;
    if (alpha == 1) {
      timeline.apply(skeleton, 0, time, null, 1, blend, _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixDirection.mixIn);
      return;
    }
    const bone = skeleton.bones[timeline.boneIndex];
    if (!bone.active)
      return;
    const frames = timeline.frames;
    let r1 = 0;
    let r2 = 0;
    if (time < frames[0]) {
      switch (blend) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup:
          bone.rotation = bone.data.rotation;
        default:
          return;
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.first:
          r1 = bone.rotation;
          r2 = bone.data.rotation;
      }
    } else {
      r1 = blend == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.setup ? bone.data.rotation : bone.rotation;
      r2 = bone.data.rotation + timeline.getCurveValue(time);
    }
    let total = 0;
    let diff = r2 - r1;
    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;
    if (diff == 0) {
      total = timelinesRotation[i];
    } else {
      let lastTotal = 0;
      let lastDiff = 0;
      if (firstFrame) {
        lastTotal = 0;
        lastDiff = diff;
      } else {
        lastTotal = timelinesRotation[i];
        lastDiff = timelinesRotation[i + 1];
      }
      const current = diff > 0;
      let dir = lastTotal >= 0;
      if (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastDiff) != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
        if (Math.abs(lastTotal) > 180)
          lastTotal += 360 * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastTotal);
        dir = current;
      }
      total = diff + lastTotal - lastTotal % 360;
      if (dir != current)
        total += 360 * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.signum(lastTotal);
      timelinesRotation[i] = total;
    }
    timelinesRotation[i + 1] = diff;
    bone.rotation = r1 + total * alpha;
  }
  queueEvents(entry, animationTime) {
    const animationStart = entry.animationStart;
    const animationEnd = entry.animationEnd;
    const duration = animationEnd - animationStart;
    const trackLastWrapped = entry.trackLast % duration;
    const events = this.events;
    let i = 0;
    const n = events.length;
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < trackLastWrapped)
        break;
      if (event.time > animationEnd)
        continue;
      this.queue.event(entry, event);
    }
    let complete = false;
    if (entry.loop)
      complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;
    else
      complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
    if (complete)
      this.queue.complete(entry);
    for (; i < n; i++) {
      const event = events[i];
      if (event.time < animationStart)
        continue;
      this.queue.event(entry, event);
    }
  }
  /** Removes all animations from all tracks, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTracks() {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++)
      this.clearTrack(i);
    this.tracks.length = 0;
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  /** Removes all animations from the track, leaving skeletons in their current pose.
   *
   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,
   * rather than leaving them in their current pose. */
  clearTrack(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return;
    const current = this.tracks[trackIndex];
    if (!current)
      return;
    this.queue.end(current);
    this.clearNext(current);
    let entry = current;
    while (true) {
      const from = entry.mixingFrom;
      if (!from)
        break;
      this.queue.end(from);
      entry.mixingFrom = null;
      entry.mixingTo = null;
      entry = from;
    }
    this.tracks[current.trackIndex] = null;
    this.queue.drain();
  }
  setCurrent(index, current, interrupt) {
    const from = this.expandToIndex(index);
    this.tracks[index] = current;
    current.previous = null;
    if (from) {
      if (interrupt)
        this.queue.interrupt(from);
      current.mixingFrom = from;
      from.mixingTo = current;
      current.mixTime = 0;
      if (from.mixingFrom && from.mixDuration > 0)
        current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
      from.timelinesRotation.length = 0;
    }
    this.queue.start(current);
  }
  /** Sets an animation by name.
   *
   * See {@link #setAnimationWith()}. */
  setAnimation(trackIndex, animationName, loop = false) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.setAnimationWith(trackIndex, animation, loop);
  }
  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never
   * applied to a skeleton, it is replaced (not mixed from).
   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  setAnimationWith(trackIndex, animation, loop = false) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let interrupt = true;
    let current = this.expandToIndex(trackIndex);
    if (current) {
      if (current.nextTrackLast == -1) {
        this.tracks[trackIndex] = current.mixingFrom;
        this.queue.interrupt(current);
        this.queue.end(current);
        this.clearNext(current);
        current = current.mixingFrom;
        interrupt = false;
      } else
        this.clearNext(current);
    }
    const entry = this.trackEntry(trackIndex, animation, loop, current);
    this.setCurrent(trackIndex, entry, interrupt);
    this.queue.drain();
    return entry;
  }
  /** Queues an animation by name.
   *
   * See {@link #addAnimationWith()}. */
  addAnimation(trackIndex, animationName, loop = false, delay = 0) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    if (!animation)
      throw new Error(`Animation not found: ${animationName}`);
    return this.addAnimationWith(trackIndex, animation, loop, delay);
  }
  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is
   * equivalent to calling {@link #setAnimationWith()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix
   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the
   *           previous entry is looping, its next loop completion is used instead of its duration.
   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addAnimationWith(trackIndex, animation, loop = false, delay = 0) {
    if (!animation)
      throw new Error("animation cannot be null.");
    let last = this.expandToIndex(trackIndex);
    if (last) {
      while (last.next)
        last = last.next;
    }
    const entry = this.trackEntry(trackIndex, animation, loop, last);
    if (!last) {
      this.setCurrent(trackIndex, entry, true);
      this.queue.drain();
    } else {
      last.next = entry;
      entry.previous = last;
      if (delay <= 0)
        delay += last.getTrackComplete() - entry.mixDuration;
    }
    entry.delay = delay;
    return entry;
  }
  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's
   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.
   *
   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},
   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes
   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation
   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of
   * 0 still mixes out over one frame.
   *
   * Mixing in is done by first setting an empty animation, then adding an animation using
   * {@link #addAnimation()} and on the returned track entry, set the
   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and
   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the
   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */
  setEmptyAnimation(trackIndex, mixDuration = 0) {
    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false);
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's
   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling
   * {@link #setEmptyAnimation()}.
   *
   * See {@link #setEmptyAnimation()}.
   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry
   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or
   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next
   *           loop completion is used instead of its duration.
   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept
   *         after the {@link AnimationStateListener#dispose()} event occurs. */
  addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {
    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false, delay);
    if (delay <= 0)
      entry.delay += entry.mixDuration - mixDuration;
    entry.mixDuration = mixDuration;
    entry.trackEnd = mixDuration;
    return entry;
  }
  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix
   * duration. */
  setEmptyAnimations(mixDuration = 0) {
    const oldDrainDisabled = this.queue.drainDisabled;
    this.queue.drainDisabled = true;
    for (let i = 0, n = this.tracks.length; i < n; i++) {
      const current = this.tracks[i];
      if (current)
        this.setEmptyAnimation(current.trackIndex, mixDuration);
    }
    this.queue.drainDisabled = oldDrainDisabled;
    this.queue.drain();
  }
  expandToIndex(index) {
    if (index < this.tracks.length)
      return this.tracks[index];
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.ensureArrayCapacity(this.tracks, index + 1, null);
    this.tracks.length = index + 1;
    return null;
  }
  /** @param last May be null. */
  trackEntry(trackIndex, animation, loop, last) {
    const entry = this.trackEntryPool.obtain();
    entry.reset();
    entry.trackIndex = trackIndex;
    entry.animation = animation;
    entry.loop = loop;
    entry.holdPrevious = false;
    entry.reverse = false;
    entry.shortestRotation = false;
    entry.eventThreshold = 0;
    entry.attachmentThreshold = 0;
    entry.drawOrderThreshold = 0;
    entry.animationStart = 0;
    entry.animationEnd = animation.duration;
    entry.animationLast = -1;
    entry.nextAnimationLast = -1;
    entry.delay = 0;
    entry.trackTime = 0;
    entry.trackLast = -1;
    entry.nextTrackLast = -1;
    entry.trackEnd = Number.MAX_VALUE;
    entry.timeScale = 1;
    entry.alpha = 1;
    entry.mixTime = 0;
    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);
    entry.interruptAlpha = 1;
    entry.totalAlpha = 0;
    entry.mixBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.replace;
    return entry;
  }
  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */
  clearNext(entry) {
    let next = entry.next;
    while (next) {
      this.queue.dispose(next);
      next = next.next;
    }
    entry.next = null;
  }
  _animationsChanged() {
    this.animationsChanged = false;
    this.propertyIDs.clear();
    const tracks = this.tracks;
    for (let i = 0, n = tracks.length; i < n; i++) {
      let entry = tracks[i];
      if (!entry)
        continue;
      while (entry.mixingFrom)
        entry = entry.mixingFrom;
      do {
        if (!entry.mixingTo || entry.mixBlend != _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.add)
          this.computeHold(entry);
        entry = entry.mixingTo;
      } while (entry);
    }
  }
  computeHold(entry) {
    const to = entry.mixingTo;
    const timelines = entry.animation.timelines;
    const timelinesCount = entry.animation.timelines.length;
    const timelineMode = entry.timelineMode;
    timelineMode.length = timelinesCount;
    const timelineHoldMix = entry.timelineHoldMix;
    timelineHoldMix.length = 0;
    const propertyIDs = this.propertyIDs;
    if (to && to.holdPrevious) {
      for (let i = 0; i < timelinesCount; i++)
        timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;
      return;
    }
    outer:
      for (let i = 0; i < timelinesCount; i++) {
        const timeline = timelines[i];
        const ids = timeline.getPropertyIds();
        if (!propertyIDs.addAll(ids))
          timelineMode[i] = SUBSEQUENT;
        else if (!to || timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.AttachmentTimeline || timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.DrawOrderTimeline || timeline instanceof _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.EventTimeline || !to.animation.hasTimeline(ids)) {
          timelineMode[i] = FIRST;
        } else {
          for (let next = to.mixingTo; next; next = next.mixingTo) {
            if (next.animation.hasTimeline(ids))
              continue;
            if (entry.mixDuration > 0) {
              timelineMode[i] = HOLD_MIX;
              timelineHoldMix[i] = next;
              continue outer;
            }
            break;
          }
          timelineMode[i] = HOLD_FIRST;
        }
      }
  }
  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */
  getCurrent(trackIndex) {
    if (trackIndex >= this.tracks.length)
      return null;
    return this.tracks[trackIndex];
  }
  /** Adds a listener to receive events for all track entries. */
  addListener(listener) {
    if (!listener)
      throw new Error("listener cannot be null.");
    this.listeners.push(listener);
  }
  /** Removes the listener added with {@link #addListener()}. */
  removeListener(listener) {
    const index = this.listeners.indexOf(listener);
    if (index >= 0)
      this.listeners.splice(index, 1);
  }
  /** Removes all listeners added with {@link #addListener()}. */
  clearListeners() {
    this.listeners.length = 0;
  }
  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an
   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery
   * are not wanted because new animations are being set. */
  clearListenerNotifications() {
    this.queue.clear();
  }
  setAnimationByName(trackIndex, animationName, loop) {
    if (!_AnimationState.deprecatedWarning1) {
      _AnimationState.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.");
    }
    this.setAnimation(trackIndex, animationName, loop);
  }
  addAnimationByName(trackIndex, animationName, loop, delay) {
    if (!_AnimationState.deprecatedWarning2) {
      _AnimationState.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.");
    }
    this.addAnimation(trackIndex, animationName, loop, delay);
  }
  hasAnimation(animationName) {
    const animation = this.data.skeletonData.findAnimation(animationName);
    return animation !== null;
  }
  hasAnimationByName(animationName) {
    if (!_AnimationState.deprecatedWarning3) {
      _AnimationState.deprecatedWarning3 = true;
      console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.");
    }
    return this.hasAnimation(animationName);
  }
};
let AnimationState = _AnimationState;
AnimationState._emptyAnimation = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__.Animation("<empty>", [], 0);
AnimationState.deprecatedWarning1 = false;
AnimationState.deprecatedWarning2 = false;
AnimationState.deprecatedWarning3 = false;
const _TrackEntry = class {
  constructor() {
    /** The animation to apply for this track entry. */
    this.animation = null;
    this.previous = null;
    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */
    this.next = null;
    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no
     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */
    this.mixingFrom = null;
    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is
     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */
    this.mixingTo = null;
    /** The listener for events generated by this track entry, or null.
     *
     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation
     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */
    this.listener = null;
    /** The index of the track where this track entry is either current or queued.
     *
     * See {@link AnimationState#getCurrent()}. */
    this.trackIndex = 0;
    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its
     * duration. */
    this.loop = false;
    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead
     * of being mixed out.
     *
     * When mixing between animations that key the same property, if a lower track also keys that property then the value will
     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%
     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation
     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which
     * keys the property, only when a higher track also keys the property.
     *
     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the
     * previous animation. */
    this.holdPrevious = false;
    this.reverse = false;
    this.shortestRotation = false;
    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event
     * timelines are not applied while this animation is being mixed out. */
    this.eventThreshold = 0;
    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the
     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to
     * 0, so attachment timelines are not applied while this animation is being mixed out. */
    this.attachmentThreshold = 0;
    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the
     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,
     * so draw order timelines are not applied while this animation is being mixed out. */
    this.drawOrderThreshold = 0;
    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.
     *
     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same
     * value to prevent timeline keys before the start time from triggering. */
    this.animationStart = 0;
    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will
     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */
    this.animationEnd = 0;
    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this
     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and
     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation
     * is applied. */
    this.animationLast = 0;
    this.nextAnimationLast = 0;
    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`
     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from
     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous
     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).
     *
     * {@link #timeScale} affects the delay. */
    this.delay = 0;
    /** Current time in seconds this track entry has been the current track entry. The track time determines
     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting
     * looping. */
    this.trackTime = 0;
    this.trackLast = 0;
    this.nextTrackLast = 0;
    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float
     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time
     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the
     * properties keyed by the animation are set to the setup pose and the track is cleared.
     *
     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation
     * abruptly cease being applied. */
    this.trackEnd = 0;
    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or
     * faster. Defaults to 1.
     *
     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to
     * match the animation speed.
     *
     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If
     * the time scale is not 1, the delay may need to be adjusted.
     *
     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */
    this.timeScale = 0;
    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults
     * to 1, which overwrites the skeleton's current pose with this animation.
     *
     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to
     * use alpha on track 0 if the skeleton pose is from the last frame render. */
    this.alpha = 0;
    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be
     * slightly more than `mixDuration` when the mix is complete. */
    this.mixTime = 0;
    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData
     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).
     *
     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the
     * properties it was animating.
     *
     * The `mixDuration` can be set manually rather than use the value from
     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new
     * track entry only before {@link AnimationState#update(float)} is first called.
     *
     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the
     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set
     * afterward. */
    this.mixDuration = 0;
    this.interruptAlpha = 0;
    this.totalAlpha = 0;
    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which
     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to
     * the values from the lower tracks.
     *
     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first
     * called. */
    this.mixBlend = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MixBlend.replace;
    this.timelineMode = new Array();
    this.timelineHoldMix = new Array();
    this.timelinesRotation = new Array();
  }
  reset() {
    this.next = null;
    this.previous = null;
    this.mixingFrom = null;
    this.mixingTo = null;
    this.animation = null;
    this.listener = null;
    this.timelineMode.length = 0;
    this.timelineHoldMix.length = 0;
    this.timelinesRotation.length = 0;
  }
  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}
   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the
   * `animationStart` time. */
  getAnimationTime() {
    if (this.loop) {
      const duration = this.animationEnd - this.animationStart;
      if (duration == 0)
        return this.animationStart;
      return this.trackTime % duration + this.animationStart;
    }
    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
  }
  setAnimationLast(animationLast) {
    this.animationLast = animationLast;
    this.nextAnimationLast = animationLast;
  }
  /** Returns true if at least one loop has been completed.
   *
   * See {@link AnimationStateListener#complete()}. */
  isComplete() {
    return this.trackTime >= this.animationEnd - this.animationStart;
  }
  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the
   * long way around when using {@link #alpha} and starting animations on other tracks.
   *
   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:
   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long
   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the
   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */
  resetRotationDirections() {
    this.timelinesRotation.length = 0;
  }
  getTrackComplete() {
    const duration = this.animationEnd - this.animationStart;
    if (duration != 0) {
      if (this.loop)
        return duration * (1 + (this.trackTime / duration | 0));
      if (this.trackTime < duration)
        return duration;
    }
    return this.trackTime;
  }
  get time() {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    return this.trackTime;
  }
  set time(value) {
    if (!_TrackEntry.deprecatedWarning1) {
      _TrackEntry.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.");
    }
    this.trackTime = value;
  }
  get endTime() {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    return this.trackTime;
  }
  set endTime(value) {
    if (!_TrackEntry.deprecatedWarning2) {
      _TrackEntry.deprecatedWarning2 = true;
      console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.");
    }
    this.trackTime = value;
  }
  loopsCount() {
    return Math.floor(this.trackTime / this.trackEnd);
  }
};
let TrackEntry = _TrackEntry;
TrackEntry.deprecatedWarning1 = false;
TrackEntry.deprecatedWarning2 = false;
class EventQueue {
  constructor(animState) {
    this.objects = [];
    this.drainDisabled = false;
    this.animState = animState;
  }
  start(entry) {
    this.objects.push(EventType.start);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  interrupt(entry) {
    this.objects.push(EventType.interrupt);
    this.objects.push(entry);
  }
  end(entry) {
    this.objects.push(EventType.end);
    this.objects.push(entry);
    this.animState.animationsChanged = true;
  }
  dispose(entry) {
    this.objects.push(EventType.dispose);
    this.objects.push(entry);
  }
  complete(entry) {
    this.objects.push(EventType.complete);
    this.objects.push(entry);
  }
  event(entry, event) {
    this.objects.push(EventType.event);
    this.objects.push(entry);
    this.objects.push(event);
  }
  drain() {
    if (this.drainDisabled)
      return;
    this.drainDisabled = true;
    const objects = this.objects;
    const listeners = this.animState.listeners;
    for (let i = 0; i < objects.length; i += 2) {
      const type = objects[i];
      const entry = objects[i + 1];
      switch (type) {
        case EventType.start:
          if (entry.listener && entry.listener.start)
            entry.listener.start(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.start)
              listener.start(entry);
          }
          break;
        case EventType.interrupt:
          if (entry.listener && entry.listener.interrupt)
            entry.listener.interrupt(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.interrupt)
              listener.interrupt(entry);
          }
          break;
        case EventType.end:
          if (entry.listener && entry.listener.end)
            entry.listener.end(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.end)
              listener.end(entry);
          }
        case EventType.dispose:
          if (entry.listener && entry.listener.dispose)
            entry.listener.dispose(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.dispose)
              listener.dispose(entry);
          }
          this.animState.trackEntryPool.free(entry);
          break;
        case EventType.complete:
          if (entry.listener && entry.listener.complete)
            entry.listener.complete(entry);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.complete)
              listener.complete(entry);
          }
          break;
        case EventType.event:
          const event = objects[i++ + 2];
          if (entry.listener && entry.listener.event)
            entry.listener.event(entry, event);
          for (let ii = 0; ii < listeners.length; ii++) {
            const listener = listeners[ii];
            if (listener.event)
              listener.event(entry, event);
          }
          break;
      }
    }
    this.clear();
    this.drainDisabled = false;
  }
  clear() {
    this.objects.length = 0;
  }
}
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["start"] = 0] = "start";
  EventType2[EventType2["interrupt"] = 1] = "interrupt";
  EventType2[EventType2["end"] = 2] = "end";
  EventType2[EventType2["dispose"] = 3] = "dispose";
  EventType2[EventType2["complete"] = 4] = "complete";
  EventType2[EventType2["event"] = 5] = "event";
  return EventType2;
})(EventType || {});
class AnimationStateAdapter {
  start(entry) {
  }
  interrupt(entry) {
  }
  end(entry) {
  }
  dispose(entry) {
  }
  complete(entry) {
  }
  event(entry, event) {
  }
}
const SUBSEQUENT = 0;
const FIRST = 1;
const HOLD_SUBSEQUENT = 2;
const HOLD_FIRST = 3;
const HOLD_MIX = 4;
const SETUP = 1;
const CURRENT = 2;


//# sourceMappingURL=AnimationState.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationStateData.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationStateData.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationStateData": function() { return /* binding */ AnimationStateData; }
/* harmony export */ });
class AnimationStateData {
  constructor(skeletonData) {
    this.animationToMixTime = {};
    /** The mix duration to use when no mix duration has been defined between two animations. */
    this.defaultMix = 0;
    if (!skeletonData)
      throw new Error("skeletonData cannot be null.");
    this.skeletonData = skeletonData;
  }
  /** Sets a mix duration by animation name.
   *
   * See {@link #setMixWith()}. */
  setMix(fromName, toName, duration) {
    const from = this.skeletonData.findAnimation(fromName);
    if (!from)
      throw new Error(`Animation not found: ${fromName}`);
    const to = this.skeletonData.findAnimation(toName);
    if (!to)
      throw new Error(`Animation not found: ${toName}`);
    this.setMixWith(from, to, duration);
  }
  /** Sets the mix duration when changing from the specified animation to the other.
   *
   * See {@link TrackEntry#mixDuration}. */
  setMixWith(from, to, duration) {
    if (!from)
      throw new Error("from cannot be null.");
    if (!to)
      throw new Error("to cannot be null.");
    const key = `${from.name}.${to.name}`;
    this.animationToMixTime[key] = duration;
  }
  /** Returns the mix duration to use when changing from the specified animation to the other, or the {@link #defaultMix} if
   * no mix duration has been set. */
  getMix(from, to) {
    const key = `${from.name}.${to.name}`;
    const value = this.animationToMixTime[key];
    return value === void 0 ? this.defaultMix : value;
  }
}


//# sourceMappingURL=AnimationStateData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AtlasAttachmentLoader.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/AtlasAttachmentLoader.mjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AtlasAttachmentLoader": function() { return /* binding */ AtlasAttachmentLoader; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attachments/BoundingBoxAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/BoundingBoxAttachment.mjs");
/* harmony import */ var _attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/ClippingAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/ClippingAttachment.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./attachments/PointAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PointAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");









class AtlasAttachmentLoader {
  constructor(atlas) {
    this.atlas = atlas;
  }
  loadSequence(name, basePath, sequence) {
    const regions = sequence.regions;
    for (let i = 0, n = regions.length; i < n; i++) {
      const path = sequence.getPath(basePath, i);
      const region = this.atlas.findRegion(path);
      if (region == null)
        throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);
      regions[i] = region;
      regions[i].renderObject = regions[i];
    }
  }
  newRegionAttachment(skin, name, path, sequence) {
    const attachment = new _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__.RegionAttachment(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newMeshAttachment(skin, name, path, sequence) {
    const attachment = new _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.MeshAttachment(name, path);
    if (sequence != null) {
      this.loadSequence(name, path, sequence);
    } else {
      const region = this.atlas.findRegion(path);
      if (!region)
        throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);
      region.renderObject = region;
      attachment.region = region;
    }
    return attachment;
  }
  newBoundingBoxAttachment(skin, name) {
    return new _attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__.BoundingBoxAttachment(name);
  }
  newPathAttachment(skin, name) {
    return new _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.PathAttachment(name);
  }
  newPointAttachment(skin, name) {
    return new _attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__.PointAttachment(name);
  }
  newClippingAttachment(skin, name) {
    return new _attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.ClippingAttachment(name);
  }
}


//# sourceMappingURL=AtlasAttachmentLoader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Bone.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/Bone.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bone": function() { return /* binding */ Bone; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class Bone {
  /** @param parent May be null. */
  constructor(data, skeleton, parent) {
    // be careful! Spine b,c is c,b in pixi matrix
    this.matrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    /** The parent bone, or null if this is the root bone. */
    this.parent = null;
    /** The immediate children of this bone. */
    this.children = new Array();
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local rotation in degrees, counter clockwise. */
    this.rotation = 0;
    /** The local scaleX. */
    this.scaleX = 0;
    /** The local scaleY. */
    this.scaleY = 0;
    /** The local shearX. */
    this.shearX = 0;
    /** The local shearY. */
    this.shearY = 0;
    /** The applied local x translation. */
    this.ax = 0;
    /** The applied local y translation. */
    this.ay = 0;
    /** The applied local rotation in degrees, counter clockwise. */
    this.arotation = 0;
    /** The applied local scaleX. */
    this.ascaleX = 0;
    /** The applied local scaleY. */
    this.ascaleY = 0;
    /** The applied local shearX. */
    this.ashearX = 0;
    /** The applied local shearY. */
    this.ashearY = 0;
    this.sorted = false;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.skeleton = skeleton;
    this.parent = parent;
    this.setToSetupPose();
  }
  get worldX() {
    return this.matrix.tx;
  }
  get worldY() {
    return this.matrix.ty;
  }
  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the
   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */
  isActive() {
    return this.active;
  }
  /** Computes the world transform using the parent bone and this bone's local applied transform. */
  update() {
    this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
  }
  /** Computes the world transform using the parent bone and this bone's local transform.
   *
   * See {@link #updateWorldTransformWith()}. */
  updateWorldTransform() {
    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
  }
  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the
   * specified local transform. Child bones are not updated.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {
    this.ax = x;
    this.ay = y;
    this.arotation = rotation;
    this.ascaleX = scaleX;
    this.ascaleY = scaleY;
    this.ashearX = shearX;
    this.ashearY = shearY;
    const parent = this.parent;
    const m = this.matrix;
    const sx = this.skeleton.scaleX;
    const sy = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
    if (!parent) {
      const skeleton = this.skeleton;
      const rotationY = rotation + 90 + shearY;
      m.a = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
      m.c = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY * sx;
      m.b = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
      m.d = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY * sy;
      m.tx = x * sx + skeleton.x;
      m.ty = y * sy + skeleton.y;
      return;
    }
    let pa = parent.matrix.a;
    let pb = parent.matrix.c;
    let pc = parent.matrix.b;
    let pd = parent.matrix.d;
    m.tx = pa * x + pb * y + parent.matrix.tx;
    m.ty = pc * x + pd * y + parent.matrix.ty;
    switch (this.data.transformMode) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.Normal: {
        const rotationY = rotation + 90 + shearY;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY;
        m.a = pa * la + pb * lc;
        m.c = pa * lb + pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        return;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.OnlyTranslation: {
        const rotationY = rotation + 90 + shearY;
        m.a = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation + shearX) * scaleX;
        m.c = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * scaleY;
        m.b = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation + shearX) * scaleX;
        m.d = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * scaleY;
        break;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoRotationOrReflection: {
        let s = pa * pa + pc * pc;
        let prx = 0;
        if (s > 1e-4) {
          s = Math.abs(pa * pd - pb * pc) / s;
          pa /= sx;
          pc /= sy;
          pb = pc * s;
          pd = pa * s;
          prx = Math.atan2(pc, pa) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
        } else {
          pa = 0;
          pc = 0;
          prx = 90 - Math.atan2(pd, pb) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
        }
        const rx = rotation + shearX - prx;
        const ry = rotation + shearY - prx + 90;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rx) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(ry) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rx) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(ry) * scaleY;
        m.a = pa * la - pb * lc;
        m.c = pa * lb - pb * ld;
        m.b = pc * la + pd * lc;
        m.d = pc * lb + pd * ld;
        break;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScale:
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScaleOrReflection: {
        const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotation);
        const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotation);
        let za = (pa * cos + pb * sin) / sx;
        let zc = (pc * cos + pd * sin) / sy;
        let s = Math.sqrt(za * za + zc * zc);
        if (s > 1e-5)
          s = 1 / s;
        za *= s;
        zc *= s;
        s = Math.sqrt(za * za + zc * zc);
        if (this.data.transformMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0))
          s = -s;
        const r = Math.PI / 2 + Math.atan2(zc, za);
        const zb = Math.cos(r) * s;
        const zd = Math.sin(r) * s;
        const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(shearX) * scaleX;
        const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(90 + shearY) * scaleY;
        const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(shearX) * scaleX;
        const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(90 + shearY) * scaleY;
        m.a = za * la + zb * lc;
        m.c = za * lb + zb * ld;
        m.b = zc * la + zd * lc;
        m.d = zc * lb + zd * ld;
        break;
      }
    }
    m.a *= sx;
    m.c *= sx;
    m.b *= sy;
    m.d *= sy;
  }
  /** Sets this bone's local transform to the setup pose. */
  setToSetupPose() {
    const data = this.data;
    this.x = data.x;
    this.y = data.y;
    this.rotation = data.rotation;
    this.scaleX = data.scaleX;
    this.scaleY = data.scaleY;
    this.shearX = data.shearX;
    this.shearY = data.shearY;
  }
  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */
  getWorldRotationX() {
    return Math.atan2(this.matrix.b, this.matrix.a) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */
  getWorldRotationY() {
    return Math.atan2(this.matrix.d, this.matrix.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */
  getWorldScaleX() {
    const m = this.matrix;
    return Math.sqrt(m.a * m.a + m.b * m.b);
  }
  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */
  getWorldScaleY() {
    const m = this.matrix;
    return Math.sqrt(m.c * m.c + m.d * m.d);
  }
  /** Computes the applied transform values from the world transform.
   *
   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so
   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other
   * constraints).
   *
   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after
   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */
  updateAppliedTransform() {
    const parent = this.parent;
    const m = this.matrix;
    if (!parent) {
      this.ax = m.tx - this.skeleton.x;
      this.ay = m.ty - this.skeleton.y;
      this.arotation = Math.atan2(m.b, m.a) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);
      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);
      this.ashearX = 0;
      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      return;
    }
    const pm = parent.matrix;
    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);
    const dx = m.tx - pm.tx;
    const dy = m.ty - pm.ty;
    this.ax = dx * pm.d * pid - dy * pm.c * pid;
    this.ay = dy * pm.a * pid - dx * pm.b * pid;
    const ia = pid * pm.d;
    const id = pid * pm.a;
    const ib = pid * pm.c;
    const ic = pid * pm.b;
    const ra = ia * m.a - ib * m.b;
    const rb = ia * m.c - ib * m.d;
    const rc = id * m.b - ic * m.a;
    const rd = id * m.d - ic * m.c;
    this.ashearX = 0;
    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
    if (this.ascaleX > 1e-4) {
      const det = ra * rd - rb * rc;
      this.ascaleY = det / this.ascaleX;
      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
      this.arotation = Math.atan2(rc, ra) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
    } else {
      this.ascaleX = 0;
      this.ascaleY = Math.sqrt(rb * rb + rd * rd);
      this.ashearY = 0;
      this.arotation = 90 - Math.atan2(rd, rb) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
    }
  }
  /** Transforms a point from world coordinates to the bone's local coordinates. */
  worldToLocal(world) {
    const m = this.matrix;
    const a = m.a;
    const b = m.c;
    const c = m.b;
    const d = m.d;
    const invDet = 1 / (a * d - b * c);
    const x = world.x - m.tx;
    const y = world.y - m.ty;
    world.x = x * d * invDet - y * b * invDet;
    world.y = y * a * invDet - x * c * invDet;
    return world;
  }
  /** Transforms a point from the bone's local coordinates to world coordinates. */
  localToWorld(local) {
    const m = this.matrix;
    const x = local.x;
    const y = local.y;
    local.x = x * m.a + y * m.c + m.tx;
    local.y = x * m.b + y * m.d + m.ty;
    return local;
  }
  /** Transforms a world rotation to a local rotation. */
  worldToLocalRotation(worldRotation) {
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(worldRotation);
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(worldRotation);
    const mat = this.matrix;
    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  /** Transforms a local rotation to a world rotation. */
  localToWorldRotation(localRotation) {
    localRotation -= this.rotation - this.shearX;
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(localRotation);
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(localRotation);
    const mat = this.matrix;
    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  /** Rotates the world transform the specified amount.
   * <p>
   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will
   * need to be called on any child bones, recursively. */
  rotateWorld(degrees) {
    const mat = this.matrix;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(degrees);
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(degrees);
    mat.a = cos * a - sin * c;
    mat.c = cos * b - sin * d;
    mat.b = sin * a + cos * c;
    mat.d = sin * b + cos * d;
  }
}


//# sourceMappingURL=Bone.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/BoneData.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/BoneData.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoneData": function() { return /* binding */ BoneData; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class BoneData {
  constructor(index, name, parent) {
    /** The index of the bone in {@link Skeleton#getBones()}. */
    this.index = 0;
    /** @returns May be null. */
    this.parent = null;
    /** The bone's length. */
    this.length = 0;
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local rotation. */
    this.rotation = 0;
    /** The local scaleX. */
    this.scaleX = 1;
    /** The local scaleY. */
    this.scaleY = 1;
    /** The local shearX. */
    this.shearX = 0;
    /** The local shearX. */
    this.shearY = 0;
    /** The transform mode for how parent world transforms affect this bone. */
    this.transformMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.Normal;
    /** When true, {@link Skeleton#updateWorldTransform()} only updates this bone if the {@link Skeleton#skin} contains this
     * bone.
     * @see Skin#bones */
    this.skinRequired = false;
    /** The color of the bone as it was in Spine. Available only when nonessential data was exported. Bones are not usually
     * rendered at runtime. */
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    this.index = index;
    this.name = name;
    this.parent = parent;
  }
}


//# sourceMappingURL=BoneData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstraintData": function() { return /* binding */ ConstraintData; }
/* harmony export */ });
class ConstraintData {
  constructor(name, order, skinRequired) {
    this.name = name;
    this.order = order;
    this.skinRequired = skinRequired;
  }
}


//# sourceMappingURL=ConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Event.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/Event.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": function() { return /* binding */ Event; }
/* harmony export */ });
class Event {
  constructor(time, data) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.time = 0;
    this.volume = 0;
    this.balance = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.time = time;
    this.data = data;
  }
}


//# sourceMappingURL=Event.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/EventData.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/EventData.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventData": function() { return /* binding */ EventData; }
/* harmony export */ });
class EventData {
  constructor(name) {
    this.intValue = 0;
    this.floatValue = 0;
    this.stringValue = null;
    this.audioPath = null;
    this.volume = 0;
    this.balance = 0;
    this.name = name;
  }
}


//# sourceMappingURL=EventData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraint.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraint.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IkConstraint": function() { return /* binding */ IkConstraint; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class IkConstraint {
  constructor(data, skeleton) {
    /** Controls the bend direction of the IK bones, either 1 or -1. */
    this.bendDirection = 0;
    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
    this.compress = false;
    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
     * and the parent bone has local nonuniform scale, stretch is not applied. */
    this.stretch = false;
    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
    this.mix = 1;
    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
    this.softness = 0;
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mix = data.mix;
    this.softness = data.softness;
    this.bendDirection = data.bendDirection;
    this.compress = data.compress;
    this.stretch = data.stretch;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find bone ${data.target.name}`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mix == 0)
      return;
    const target = this.target;
    const bones = this.bones;
    switch (bones.length) {
      case 1:
        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
        break;
      case 2:
        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
        break;
    }
  }
  /** Applies 1 bone IK. The target is specified in the world coordinate system. */
  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {
    const p = bone.parent.matrix;
    if (!p)
      throw new Error("IK bone must have parent.");
    const pa = p.a;
    let pb = p.c;
    const pc = p.b;
    let pd = p.d;
    let rotationIK = -bone.ashearX - bone.arotation;
    let tx = 0;
    let ty = 0;
    const skelX = bone.skeleton.scaleX;
    const skelY = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;
    switch (bone.data.transformMode) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.OnlyTranslation:
        tx = targetX - bone.worldX;
        ty = targetY - bone.worldY;
        if (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.settings.yDown) {
          ty = -ty;
        }
        break;
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.NoRotationOrReflection:
        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);
        const sa = pa / skelX;
        const sc = pc / skelY;
        pb = -sc * s * skelX;
        pd = sa * s * skelY;
        rotationIK += Math.atan2(sc, sa) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg;
      default:
        const x = targetX - p.tx;
        const y = targetY - p.ty;
        const d = pa * pd - pb * pc;
        tx = (x * pd - y * pb) / d - bone.ax;
        ty = (y * pa - x * pc) / d - bone.ay;
    }
    rotationIK += Math.atan2(ty, tx) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg;
    if (bone.ascaleX < 0)
      rotationIK += 180;
    if (rotationIK > 180)
      rotationIK -= 360;
    else if (rotationIK < -180)
      rotationIK += 360;
    let sx = bone.ascaleX;
    let sy = bone.ascaleY;
    if (compress || stretch) {
      switch (bone.data.transformMode) {
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.NoScale:
        case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.TransformMode.NoScaleOrReflection:
          tx = targetX - bone.worldX;
          ty = targetY - bone.worldY;
      }
      const b = bone.data.length * sx;
      const dd = Math.sqrt(tx * tx + ty * ty);
      if (compress && dd < b || stretch && dd > b && b > 1e-4) {
        const s = (dd / b - 1) * alpha + 1;
        sx *= s;
        if (uniform)
          sy *= s;
      }
    }
    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
  }
  /** Applies 2 bone IK. The target is specified in the world coordinate system.
   * @param child A direct descendant of the parent bone. */
  apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
    const px = parent.ax;
    const py = parent.ay;
    let psx = parent.ascaleX;
    let psy = parent.ascaleY;
    let sx = psx;
    let sy = psy;
    let csx = child.ascaleX;
    const pmat = parent.matrix;
    let os1 = 0;
    let os2 = 0;
    let s2 = 0;
    if (psx < 0) {
      psx = -psx;
      os1 = 180;
      s2 = -1;
    } else {
      os1 = 0;
      s2 = 1;
    }
    if (psy < 0) {
      psy = -psy;
      s2 = -s2;
    }
    if (csx < 0) {
      csx = -csx;
      os2 = 180;
    } else
      os2 = 0;
    const cx = child.ax;
    let cy = 0;
    let cwx = 0;
    let cwy = 0;
    let a = pmat.a;
    let b = pmat.c;
    let c = pmat.b;
    let d = pmat.d;
    const u = Math.abs(psx - psy) <= 1e-4;
    if (!u || stretch) {
      cy = 0;
      cwx = a * cx + pmat.tx;
      cwy = c * cx + pmat.ty;
    } else {
      cy = child.ay;
      cwx = a * cx + b * cy + pmat.tx;
      cwy = c * cx + d * cy + pmat.ty;
    }
    const pp = parent.parent.matrix;
    if (!pp)
      throw new Error("IK parent must itself have a parent.");
    a = pp.a;
    b = pp.c;
    c = pp.b;
    d = pp.d;
    const id = 1 / (a * d - b * c);
    let x = cwx - pp.tx;
    let y = cwy - pp.ty;
    const dx = (x * d - y * b) * id - px;
    const dy = (y * a - x * c) * id - py;
    const l1 = Math.sqrt(dx * dx + dy * dy);
    let l2 = child.data.length * csx;
    let a1;
    let a2;
    if (l1 < 1e-4) {
      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
      return;
    }
    x = targetX - pp.tx;
    y = targetY - pp.ty;
    let tx = (x * d - y * b) * id - px;
    let ty = (y * a - x * c) * id - py;
    let dd = tx * tx + ty * ty;
    if (softness != 0) {
      softness *= psx * (csx + 1) * 0.5;
      const td = Math.sqrt(dd);
      const sd = td - l1 - l2 * psx + softness;
      if (sd > 0) {
        let p = Math.min(1, sd / (softness * 2)) - 1;
        p = (sd - softness * (1 - p * p)) / td;
        tx -= p * tx;
        ty -= p * ty;
        dd = tx * tx + ty * ty;
      }
    }
    outer:
      if (u) {
        l2 *= psx;
        let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
        if (cos < -1) {
          cos = -1;
          a2 = Math.PI * bendDir;
        } else if (cos > 1) {
          cos = 1;
          a2 = 0;
          if (stretch) {
            a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
            sx *= a;
            if (uniform)
              sy *= a;
          }
        } else
          a2 = Math.acos(cos) * bendDir;
        a = l1 + l2 * cos;
        b = l2 * Math.sin(a2);
        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
      } else {
        a = psx * l2;
        b = psy * l2;
        const aa = a * a;
        const bb = b * b;
        const ta = Math.atan2(ty, tx);
        c = bb * l1 * l1 + aa * dd - aa * bb;
        const c1 = -2 * bb * l1;
        const c2 = bb - aa;
        d = c1 * c1 - 4 * c2 * c;
        if (d >= 0) {
          let q = Math.sqrt(d);
          if (c1 < 0)
            q = -q;
          q = -(c1 + q) * 0.5;
          const r0 = q / c2;
          const r1 = c / q;
          const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
          if (r * r <= dd) {
            y = Math.sqrt(dd - r * r) * bendDir;
            a1 = ta - Math.atan2(y, r);
            a2 = Math.atan2(y / psy, (r - l1) / psx);
            break outer;
          }
        }
        let minAngle = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI;
        let minX = l1 - a;
        let minDist = minX * minX;
        let minY = 0;
        let maxAngle = 0;
        let maxX = l1 + a;
        let maxDist = maxX * maxX;
        let maxY = 0;
        c = -a * l1 / (aa - bb);
        if (c >= -1 && c <= 1) {
          c = Math.acos(c);
          x = a * Math.cos(c) + l1;
          y = b * Math.sin(c);
          d = x * x + y * y;
          if (d < minDist) {
            minAngle = c;
            minDist = d;
            minX = x;
            minY = y;
          }
          if (d > maxDist) {
            maxAngle = c;
            maxDist = d;
            maxX = x;
            maxY = y;
          }
        }
        if (dd <= (minDist + maxDist) * 0.5) {
          a1 = ta - Math.atan2(minY * bendDir, minX);
          a2 = minAngle * bendDir;
        } else {
          a1 = ta - Math.atan2(maxY * bendDir, maxX);
          a2 = maxAngle * bendDir;
        }
      }
    const os = Math.atan2(cy, cx) * s2;
    let rotation = parent.arotation;
    a1 = (a1 - os) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg + os1 - rotation;
    if (a1 > 180)
      a1 -= 360;
    else if (a1 < -180)
      a1 += 360;
    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);
    rotation = child.arotation;
    a2 = ((a2 + os) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
    if (a2 > 180)
      a2 -= 360;
    else if (a2 < -180)
      a2 += 360;
    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
  }
}


//# sourceMappingURL=IkConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraintData.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraintData.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IkConstraintData": function() { return /* binding */ IkConstraintData; }
/* harmony export */ });
/* harmony import */ var _ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs");


class IkConstraintData extends _ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_0__.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that are constrained by this IK constraint. */
    this.bones = new Array();
    /** The bone that is the IK target. */
    this._target = null;
    /** Controls the bend direction of the IK bones, either 1 or -1. */
    this.bendDirection = 1;
    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */
    this.compress = false;
    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained
     * and the parent bone has local nonuniform scale, stretch is not applied. */
    this.stretch = false;
    /** When true, only a single bone is being constrained, and {@link #getCompress()} or {@link #getStretch()} is used, the bone
     * is scaled on both the X and Y axes. */
    this.uniform = false;
    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */
    this.mix = 1;
    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */
    this.softness = 0;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
}


//# sourceMappingURL=IkConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraint.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraint.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathConstraint": function() { return /* binding */ PathConstraint; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs");







const _PathConstraint = class {
  constructor(data, skeleton) {
    /** The position along the path. */
    this.position = 0;
    /** The spacing between bones. */
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.spaces = new Array();
    this.positions = new Array();
    this.world = new Array();
    this.curves = new Array();
    this.lengths = new Array();
    this.segments = new Array();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0, n = data.bones.length; i < n; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findSlot(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}`);
    this.target = target;
    this.position = data.position;
    this.spacing = data.spacing;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
  }
  isActive() {
    return this.active;
  }
  update() {
    const attachment = this.target.getAttachment();
    if (!(attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.PathAttachment))
      return;
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    if (mixRotate == 0 && mixX == 0 && mixY == 0)
      return;
    const data = this.data;
    const tangents = data.rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.Tangent;
    const scale = data.rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.ChainScale;
    const bones = this.bones;
    const boneCount = bones.length;
    const spacesCount = tangents ? boneCount : boneCount + 1;
    const spaces = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.spaces, spacesCount);
    const lengths = scale ? this.lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.lengths, boneCount) : [];
    const spacing = this.spacing;
    switch (data.spacingMode) {
      case _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.SpacingMode.Percent:
        if (scale) {
          for (let i = 0, n = spacesCount - 1; i < n; i++) {
            const bone = bones[i];
            const setupLength = bone.data.length;
            if (setupLength < _PathConstraint.epsilon)
              lengths[i] = 0;
            else {
              const x = setupLength * bone.matrix.a;
              const y = setupLength * bone.matrix.b;
              lengths[i] = Math.sqrt(x * x + y * y);
            }
          }
        }
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayFill(spaces, 1, spacesCount, spacing);
        break;
      case _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.SpacingMode.Proportional:
        let sum = 0;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = length;
            sum += length;
          }
        }
        if (sum > 0) {
          sum = spacesCount / sum * spacing;
          for (let i = 1; i < spacesCount; i++)
            spaces[i] *= sum;
        }
        break;
      default:
        const lengthSpacing = data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.SpacingMode.Length;
        for (let i = 0, n = spacesCount - 1; i < n; ) {
          const bone = bones[i];
          const setupLength = bone.data.length;
          if (setupLength < _PathConstraint.epsilon) {
            if (scale)
              lengths[i] = 0;
            spaces[++i] = spacing;
          } else {
            const x = setupLength * bone.matrix.a;
            const y = setupLength * bone.matrix.b;
            const length = Math.sqrt(x * x + y * y);
            if (scale)
              lengths[i] = length;
            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;
          }
        }
    }
    const positions = this.computeWorldPositions(attachment, spacesCount, tangents);
    let boneX = positions[0];
    let boneY = positions[1];
    let offsetRotation = data.offsetRotation;
    let tip = false;
    if (offsetRotation == 0)
      tip = data.rotateMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.Chain;
    else {
      tip = false;
      const p = this.target.bone.matrix;
      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degRad;
    }
    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {
      const bone = bones[i];
      const mat = bone.matrix;
      mat.tx += (boneX - mat.tx) * mixX;
      mat.ty += (boneY - mat.ty) * mixY;
      const x = positions[p];
      const y = positions[p + 1];
      const dx = x - boneX;
      const dy = y - boneY;
      if (scale) {
        const length = lengths[i];
        if (length != 0) {
          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;
          mat.a *= s;
          mat.b *= s;
        }
      }
      boneX = x;
      boneY = y;
      if (mixRotate > 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = 0;
        let cos = 0;
        let sin = 0;
        if (tangents)
          r = positions[p - 1];
        else if (spaces[i + 1] == 0)
          r = positions[p + 2];
        else
          r = Math.atan2(dy, dx);
        r -= Math.atan2(c, a);
        if (tip) {
          cos = Math.cos(r);
          sin = Math.sin(r);
          const length = bone.data.length;
          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;
          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;
        } else {
          r += offsetRotation;
        }
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.PI2;
        r *= mixRotate;
        cos = Math.cos(r);
        sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      bone.updateAppliedTransform();
    }
  }
  computeWorldPositions(path, spacesCount, tangents) {
    const target = this.target;
    let position = this.position;
    const spaces = this.spaces;
    const out = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.positions, spacesCount * 3 + 2);
    let world = this.world;
    const closed = path.closed;
    let verticesLength = path.worldVerticesLength;
    let curveCount = verticesLength / 6;
    let prevCurve = _PathConstraint.NONE;
    if (!path.constantSpeed) {
      const lengths = path.lengths;
      curveCount -= closed ? 1 : 2;
      const pathLength2 = lengths[curveCount];
      if (this.data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.PositionMode.Percent)
        position *= pathLength2;
      let multiplier2;
      switch (this.data.spacingMode) {
        case _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.SpacingMode.Percent:
          multiplier2 = pathLength2;
          break;
        case _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.SpacingMode.Proportional:
          multiplier2 = pathLength2 / spacesCount;
          break;
        default:
          multiplier2 = 1;
      }
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, 8);
      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
        const space = spaces[i] * multiplier2;
        position += space;
        let p = position;
        if (closed) {
          p %= pathLength2;
          if (p < 0)
            p += pathLength2;
          curve = 0;
        } else if (p < 0) {
          if (prevCurve != _PathConstraint.BEFORE) {
            prevCurve = _PathConstraint.BEFORE;
            path.computeWorldVertices(target, 2, 4, world, 0, 2);
          }
          this.addBeforePosition(p, world, 0, out, o);
          continue;
        } else if (p > pathLength2) {
          if (prevCurve != _PathConstraint.AFTER) {
            prevCurve = _PathConstraint.AFTER;
            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
          }
          this.addAfterPosition(p - pathLength2, world, 0, out, o);
          continue;
        }
        for (; ; curve++) {
          const length = lengths[curve];
          if (p > length)
            continue;
          if (curve == 0)
            p /= length;
          else {
            const prev = lengths[curve - 1];
            p = (p - prev) / (length - prev);
          }
          break;
        }
        if (curve != prevCurve) {
          prevCurve = curve;
          if (closed && curve == curveCount) {
            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
            path.computeWorldVertices(target, 0, 4, world, 4, 2);
          } else
            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
        }
        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
      }
      return out;
    }
    if (closed) {
      verticesLength += 2;
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
      world[verticesLength - 2] = world[0];
      world[verticesLength - 1] = world[1];
    } else {
      curveCount--;
      verticesLength -= 4;
      world = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.world, verticesLength);
      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
    }
    const curves = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(this.curves, curveCount);
    let pathLength = 0;
    let x1 = world[0];
    let y1 = world[1];
    let cx1 = 0;
    let cy1 = 0;
    let cx2 = 0;
    let cy2 = 0;
    let x2 = 0;
    let y2 = 0;
    let tmpx = 0;
    let tmpy = 0;
    let dddfx = 0;
    let dddfy = 0;
    let ddfx = 0;
    let ddfy = 0;
    let dfx = 0;
    let dfy = 0;
    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {
      cx1 = world[w];
      cy1 = world[w + 1];
      cx2 = world[w + 2];
      cy2 = world[w + 3];
      x2 = world[w + 4];
      y2 = world[w + 5];
      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
      ddfx = tmpx * 2 + dddfx;
      ddfy = tmpy * 2 + dddfy;
      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx;
      dfy += ddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      dfx += ddfx + dddfx;
      dfy += ddfy + dddfy;
      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
      curves[i] = pathLength;
      x1 = x2;
      y1 = y2;
    }
    if (this.data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.PositionMode.Percent)
      position *= pathLength;
    let multiplier;
    switch (this.data.spacingMode) {
      case _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.SpacingMode.Percent:
        multiplier = pathLength;
        break;
      case _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.SpacingMode.Proportional:
        multiplier = pathLength / spacesCount;
        break;
      default:
        multiplier = 1;
    }
    const segments = this.segments;
    let curveLength = 0;
    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
      const space = spaces[i] * multiplier;
      position += space;
      let p = position;
      if (closed) {
        p %= pathLength;
        if (p < 0)
          p += pathLength;
        curve = 0;
      } else if (p < 0) {
        this.addBeforePosition(p, world, 0, out, o);
        continue;
      } else if (p > pathLength) {
        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
        continue;
      }
      for (; ; curve++) {
        const length = curves[curve];
        if (p > length)
          continue;
        if (curve == 0)
          p /= length;
        else {
          const prev = curves[curve - 1];
          p = (p - prev) / (length - prev);
        }
        break;
      }
      if (curve != prevCurve) {
        prevCurve = curve;
        let ii = curve * 6;
        x1 = world[ii];
        y1 = world[ii + 1];
        cx1 = world[ii + 2];
        cy1 = world[ii + 3];
        cx2 = world[ii + 4];
        cy2 = world[ii + 5];
        x2 = world[ii + 6];
        y2 = world[ii + 7];
        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;
        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;
        ddfx = tmpx * 2 + dddfx;
        ddfy = tmpy * 2 + dddfy;
        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
        segments[0] = curveLength;
        for (ii = 1; ii < 8; ii++) {
          dfx += ddfx;
          dfy += ddfy;
          ddfx += dddfx;
          ddfy += dddfy;
          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
          segments[ii] = curveLength;
        }
        dfx += ddfx;
        dfy += ddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[8] = curveLength;
        dfx += ddfx + dddfx;
        dfy += ddfy + dddfy;
        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
        segments[9] = curveLength;
        segment = 0;
      }
      p *= curveLength;
      for (; ; segment++) {
        const length = segments[segment];
        if (p > length)
          continue;
        if (segment == 0)
          p /= length;
        else {
          const prev = segments[segment - 1];
          p = segment + (p - prev) / (length - prev);
        }
        break;
      }
      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
    }
    return out;
  }
  addBeforePosition(p, temp, i, out, o) {
    const x1 = temp[i];
    const y1 = temp[i + 1];
    const dx = temp[i + 2] - x1;
    const dy = temp[i + 3] - y1;
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addAfterPosition(p, temp, i, out, o) {
    const x1 = temp[i + 2];
    const y1 = temp[i + 3];
    const dx = x1 - temp[i];
    const dy = y1 - temp[i + 1];
    const r = Math.atan2(dy, dx);
    out[o] = x1 + p * Math.cos(r);
    out[o + 1] = y1 + p * Math.sin(r);
    out[o + 2] = r;
  }
  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
    if (p == 0 || isNaN(p)) {
      out[o] = x1;
      out[o + 1] = y1;
      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      return;
    }
    const tt = p * p;
    const ttt = tt * p;
    const u = 1 - p;
    const uu = u * u;
    const uuu = uu * u;
    const ut = u * p;
    const ut3 = ut * 3;
    const uut3 = u * ut3;
    const utt3 = ut3 * p;
    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
    out[o] = x;
    out[o + 1] = y;
    if (tangents) {
      if (p < 1e-3)
        out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
      else
        out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
    }
  }
};
let PathConstraint = _PathConstraint;
PathConstraint.NONE = -1;
PathConstraint.BEFORE = -2;
PathConstraint.AFTER = -3;
PathConstraint.epsilon = 1e-5;


//# sourceMappingURL=PathConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathConstraintData": function() { return /* binding */ PathConstraintData; },
/* harmony export */   "SpacingMode": function() { return /* binding */ SpacingMode; }
/* harmony export */ });
/* harmony import */ var _ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class PathConstraintData extends _ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_0__.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that will be modified by this path constraint. */
    this.bones = new Array();
    /** The slot whose path attachment will be used to constrained the bones. */
    this._target = null;
    /** The mode for positioning the first bone on the path. */
    this.positionMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.PositionMode.Fixed;
    /** The mode for positioning the bones after the first bone on the path. */
    this.spacingMode = SpacingMode.Fixed;
    /** The mode for adjusting the rotation of the bones. */
    this.rotateMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode.Chain;
    /** An offset added to the constrained bone rotation. */
    this.offsetRotation = 0;
    /** The position along the path. */
    this.position = 0;
    /** The spacing between bones. */
    this.spacing = 0;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
  }
  set target(slotData) {
    this._target = slotData;
  }
  get target() {
    if (!this._target)
      throw new Error("SlotData not set.");
    else
      return this._target;
  }
}
var SpacingMode = /* @__PURE__ */ ((SpacingMode2) => {
  SpacingMode2[SpacingMode2["Length"] = 0] = "Length";
  SpacingMode2[SpacingMode2["Fixed"] = 1] = "Fixed";
  SpacingMode2[SpacingMode2["Percent"] = 2] = "Percent";
  SpacingMode2[SpacingMode2["Proportional"] = 3] = "Proportional";
  return SpacingMode2;
})(SpacingMode || {});


//# sourceMappingURL=PathConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Skeleton.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/Skeleton.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Skeleton": function() { return /* binding */ Skeleton; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");
/* harmony import */ var _Bone_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Bone.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Bone.mjs");
/* harmony import */ var _Slot_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Slot.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Slot.mjs");
/* harmony import */ var _IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./IkConstraint.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraint.mjs");
/* harmony import */ var _TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TransformConstraint.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraint.mjs");
/* harmony import */ var _PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PathConstraint.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraint.mjs");












const _Skeleton = class {
  constructor(data) {
    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */
    this._updateCache = new Array();
    /** The skeleton's current skin. May be null. */
    this.skin = null;
    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale
     * inheritance. */
    this.scaleX = 1;
    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale
     * inheritance. */
    this.scaleY = 1;
    /** Sets the skeleton X position, which is added to the root bone worldX position. */
    this.x = 0;
    /** Sets the skeleton Y position, which is added to the root bone worldY position. */
    this.y = 0;
    if (!data)
      throw new Error("data cannot be null.");
    this.data = data;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const boneData = data.bones[i];
      let bone;
      if (!boneData.parent)
        bone = new _Bone_mjs__WEBPACK_IMPORTED_MODULE_6__.Bone(boneData, this, null);
      else {
        const parent = this.bones[boneData.parent.index];
        bone = new _Bone_mjs__WEBPACK_IMPORTED_MODULE_6__.Bone(boneData, this, parent);
        parent.children.push(bone);
      }
      this.bones.push(bone);
    }
    this.slots = new Array();
    this.drawOrder = new Array();
    for (let i = 0; i < data.slots.length; i++) {
      const slotData = data.slots[i];
      const bone = this.bones[slotData.boneData.index];
      const slot = new _Slot_mjs__WEBPACK_IMPORTED_MODULE_7__.Slot(slotData, bone);
      this.slots.push(slot);
      this.drawOrder.push(slot);
    }
    this.ikConstraints = new Array();
    for (let i = 0; i < data.ikConstraints.length; i++) {
      const ikConstraintData = data.ikConstraints[i];
      this.ikConstraints.push(new _IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_8__.IkConstraint(ikConstraintData, this));
    }
    this.transformConstraints = new Array();
    for (let i = 0; i < data.transformConstraints.length; i++) {
      const transformConstraintData = data.transformConstraints[i];
      this.transformConstraints.push(new _TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_9__.TransformConstraint(transformConstraintData, this));
    }
    this.pathConstraints = new Array();
    for (let i = 0; i < data.pathConstraints.length; i++) {
      const pathConstraintData = data.pathConstraints[i];
      this.pathConstraints.push(new _PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_10__.PathConstraint(pathConstraintData, this));
    }
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.updateCache();
  }
  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,
   * constraints, or weighted path attachments are added or removed. */
  updateCache() {
    const updateCache = this._updateCache;
    updateCache.length = 0;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.sorted = bone.data.skinRequired;
      bone.active = !bone.sorted;
    }
    if (this.skin) {
      const skinBones = this.skin.bones;
      for (let i = 0, n = this.skin.bones.length; i < n; i++) {
        let bone = this.bones[skinBones[i].index];
        do {
          bone.sorted = false;
          bone.active = true;
          bone = bone.parent;
        } while (bone);
      }
    }
    const ikConstraints = this.ikConstraints;
    const transformConstraints = this.transformConstraints;
    const pathConstraints = this.pathConstraints;
    const ikCount = ikConstraints.length;
    const transformCount = transformConstraints.length;
    const pathCount = pathConstraints.length;
    const constraintCount = ikCount + transformCount + pathCount;
    outer:
      for (let i = 0; i < constraintCount; i++) {
        for (let ii = 0; ii < ikCount; ii++) {
          const constraint = ikConstraints[ii];
          if (constraint.data.order == i) {
            this.sortIkConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < transformCount; ii++) {
          const constraint = transformConstraints[ii];
          if (constraint.data.order == i) {
            this.sortTransformConstraint(constraint);
            continue outer;
          }
        }
        for (let ii = 0; ii < pathCount; ii++) {
          const constraint = pathConstraints[ii];
          if (constraint.data.order == i) {
            this.sortPathConstraint(constraint);
            continue outer;
          }
        }
      }
    for (let i = 0, n = bones.length; i < n; i++)
      this.sortBone(bones[i]);
  }
  sortIkConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const target = constraint.target;
    this.sortBone(target);
    const constrained = constraint.bones;
    const parent = constrained[0];
    this.sortBone(parent);
    if (constrained.length == 1) {
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
    } else {
      const child = constrained[constrained.length - 1];
      this.sortBone(child);
      this._updateCache.push(constraint);
      this.sortReset(parent.children);
      child.sorted = true;
    }
  }
  sortPathConstraint(constraint) {
    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    const slot = constraint.target;
    const slotIndex = slot.data.index;
    const slotBone = slot.bone;
    if (this.skin)
      this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
    if (this.data.defaultSkin && this.data.defaultSkin != this.skin)
      this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
    for (let i = 0, n = this.data.skins.length; i < n; i++)
      this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);
    const attachment = slot.getAttachment();
    if (attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.PathAttachment)
      this.sortPathConstraintAttachmentWith(attachment, slotBone);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    for (let i = 0; i < boneCount; i++)
      this.sortBone(constrained[i]);
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortTransformConstraint(constraint) {
    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.contains(this.skin.constraints, constraint.data, true));
    if (!constraint.active)
      return;
    this.sortBone(constraint.target);
    const constrained = constraint.bones;
    const boneCount = constrained.length;
    if (constraint.data.local) {
      for (let i = 0; i < boneCount; i++) {
        const child = constrained[i];
        this.sortBone(child.parent);
        this.sortBone(child);
      }
    } else {
      for (let i = 0; i < boneCount; i++) {
        this.sortBone(constrained[i]);
      }
    }
    this._updateCache.push(constraint);
    for (let i = 0; i < boneCount; i++)
      this.sortReset(constrained[i].children);
    for (let i = 0; i < boneCount; i++)
      constrained[i].sorted = true;
  }
  sortPathConstraintAttachment(skin, slotIndex, slotBone) {
    const attachments = skin.attachments[slotIndex];
    if (!attachments)
      return;
    for (const key in attachments) {
      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
    }
  }
  sortPathConstraintAttachmentWith(attachment, slotBone) {
    if (!(attachment instanceof _attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.PathAttachment))
      return;
    const pathBones = attachment.bones;
    if (!pathBones)
      this.sortBone(slotBone);
    else {
      const bones = this.bones;
      for (let i = 0, n = pathBones.length; i < n; ) {
        let nn = pathBones[i++];
        nn += i;
        while (i < nn)
          this.sortBone(bones[pathBones[i++]]);
      }
    }
  }
  sortBone(bone) {
    if (!bone)
      return;
    if (bone.sorted)
      return;
    const parent = bone.parent;
    if (parent)
      this.sortBone(parent);
    bone.sorted = true;
    this._updateCache.push(bone);
  }
  sortReset(bones) {
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (!bone.active)
        continue;
      if (bone.sorted)
        this.sortReset(bone.children);
      bone.sorted = false;
    }
  }
  /** Updates the world transform for each bone and applies all constraints.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide. */
  updateWorldTransform() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      bone.ax = bone.x;
      bone.ay = bone.y;
      bone.arotation = bone.rotation;
      bone.ascaleX = bone.scaleX;
      bone.ascaleY = bone.scaleY;
      bone.ashearX = bone.shearX;
      bone.ashearY = bone.shearY;
    }
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++)
      updateCache[i].update();
  }
  updateWorldTransformWith(parent) {
    const rootBone = this.getRootBone();
    const pa = parent.matrix.a;
    const pb = parent.matrix.c;
    const pc = parent.matrix.b;
    const pd = parent.matrix.d;
    rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;
    rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;
    const rotationY = rootBone.rotation + 90 + rootBone.shearY;
    const la = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const lb = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(rotationY) * rootBone.scaleY;
    const lc = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
    const ld = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(rotationY) * rootBone.scaleY;
    const sx = this.scaleX;
    const sy = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.settings.yDown ? -this.scaleY : this.scaleY;
    rootBone.matrix.a = (pa * la + pb * lc) * sx;
    rootBone.matrix.c = (pa * lb + pb * ld) * sx;
    rootBone.matrix.b = (pc * la + pd * lc) * sy;
    rootBone.matrix.d = (pc * lb + pd * ld) * sy;
    const updateCache = this._updateCache;
    for (let i = 0, n = updateCache.length; i < n; i++) {
      const updatable = updateCache[i];
      if (updatable != rootBone)
        updatable.update();
    }
  }
  /** Sets the bones, constraints, and slots to their setup pose values. */
  setToSetupPose() {
    this.setBonesToSetupPose();
    this.setSlotsToSetupPose();
  }
  /** Sets the bones and constraints to their setup pose values. */
  setBonesToSetupPose() {
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      bones[i].setToSetupPose();
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      constraint.mix = constraint.data.mix;
      constraint.softness = constraint.data.softness;
      constraint.bendDirection = constraint.data.bendDirection;
      constraint.compress = constraint.data.compress;
      constraint.stretch = constraint.data.stretch;
    }
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      const data = constraint.data;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
      constraint.mixScaleX = data.mixScaleX;
      constraint.mixScaleY = data.mixScaleY;
      constraint.mixShearY = data.mixShearY;
    }
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      const data = constraint.data;
      constraint.position = data.position;
      constraint.spacing = data.spacing;
      constraint.mixRotate = data.mixRotate;
      constraint.mixX = data.mixX;
      constraint.mixY = data.mixY;
    }
  }
  /** Sets the slots and draw order to their setup pose values. */
  setSlotsToSetupPose() {
    const slots = this.slots;
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
    for (let i = 0, n = slots.length; i < n; i++)
      slots[i].setToSetupPose();
  }
  /** @returns May return null. */
  getRootBone() {
    if (this.bones.length == 0)
      return null;
    return this.bones[0];
  }
  /** @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.data.name == boneName)
        return bone;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].data.name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * repeatedly.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName)
        return slot;
    }
    return null;
  }
  /** @returns -1 if the bone was not found. */
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].data.name == slotName)
        return i;
    return -1;
  }
  /** Sets a skin by name.
   *
   * See {@link #setSkin()}. */
  setSkinByName(skinName) {
    const skin = this.data.findSkin(skinName);
    if (!skin)
      throw new Error(`Skin not found: ${skinName}`);
    this.setSkin(skin);
  }
  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the
   * skin is changed, {@link #updateCache()} is called.
   *
   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no
   * old skin, each slot's setup mode attachment is attached from the new skin.
   *
   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling
   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the
   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.
   * @param newSkin May be null. */
  setSkin(newSkin) {
    if (newSkin == this.skin)
      return;
    if (newSkin) {
      if (this.skin)
        newSkin.attachAll(this, this.skin);
      else {
        const slots = this.slots;
        for (let i = 0, n = slots.length; i < n; i++) {
          const slot = slots[i];
          const name = slot.data.attachmentName;
          if (name) {
            const attachment = newSkin.getAttachment(i, name);
            if (attachment)
              slot.setAttachment(attachment);
          }
        }
      }
    }
    this.skin = newSkin;
    this.updateCache();
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment
   * name.
   *
   * See {@link #getAttachment()}.
   * @returns May be null. */
  getAttachmentByName(slotName, attachmentName) {
    const slot = this.data.findSlot(slotName);
    if (!slot)
      throw new Error(`Can't find slot with name ${slotName}`);
    return this.getAttachment(slot.index, attachmentName);
  }
  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and
   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.
   *
   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.
   * @returns May be null. */
  getAttachment(slotIndex, attachmentName) {
    if (!attachmentName)
      throw new Error("attachmentName cannot be null.");
    if (this.skin) {
      const attachment = this.skin.getAttachment(slotIndex, attachmentName);
      if (attachment)
        return attachment;
    }
    if (this.data.defaultSkin)
      return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
    return null;
  }
  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with
   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.
   * @param attachmentName May be null to clear the slot's attachment. */
  setAttachment(slotName, attachmentName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.data.name == slotName) {
        let attachment = null;
        if (attachmentName) {
          attachment = this.getAttachment(i, attachmentName);
          if (!attachment)
            throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);
        }
        slot.setAttachment(attachment);
        return;
      }
    }
    throw new Error(`Slot not found: ${slotName}`);
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const ikConstraint = ikConstraints[i];
      if (ikConstraint.data.name == constraintName)
        return ikConstraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it repeatedly.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it repeatedly.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.data.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.
   * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */
  getBoundsRect() {
    const offset = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Vector2();
    const size = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Vector2();
    this.getBounds(offset, size);
    return { x: offset.x, y: offset.y, width: size.x, height: size.y };
  }
  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.
   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.
   * @param size An output value, the width and height of the AABB.
   * @param temp Working memory to temporarily store attachments' computed world vertices. */
  getBounds(offset, size, temp = new Array(2)) {
    if (!offset)
      throw new Error("offset cannot be null.");
    if (!size)
      throw new Error("size cannot be null.");
    const drawOrder = this.drawOrder;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (let i = 0, n = drawOrder.length; i < n; i++) {
      const slot = drawOrder[i];
      if (!slot.bone.active)
        continue;
      let verticesLength = 0;
      let vertices = null;
      const attachment = slot.getAttachment();
      if (attachment instanceof _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.RegionAttachment) {
        verticesLength = 8;
        vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(temp, verticesLength, 0);
        attachment.computeWorldVertices(slot, vertices, 0, 2);
      } else if (attachment instanceof _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.MeshAttachment) {
        const mesh = attachment;
        verticesLength = mesh.worldVerticesLength;
        vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.setArraySize(temp, verticesLength, 0);
        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
      }
      if (vertices) {
        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {
          const x = vertices[ii];
          const y = vertices[ii + 1];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
      }
    }
    offset.set(minX, minY);
    size.set(maxX - minX, maxY - minY);
  }
  get flipX() {
    return this.scaleX == -1;
  }
  set flipX(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleX = value ? 1 : -1;
  }
  get flipY() {
    return this.scaleY == -1;
  }
  set flipY(value) {
    if (!_Skeleton.deprecatedWarning1) {
      _Skeleton.deprecatedWarning1 = true;
      console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY");
    }
    this.scaleY = value ? 1 : -1;
  }
};
let Skeleton = _Skeleton;
Skeleton.deprecatedWarning1 = false;


//# sourceMappingURL=Skeleton.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBinary.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBinary.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonBinary": function() { return /* binding */ SkeletonBinary; }
/* harmony export */ });
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs");
/* harmony import */ var _Event_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Event.mjs");
/* harmony import */ var _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonData.mjs");
/* harmony import */ var _SlotData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SlotData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SlotData.mjs");
/* harmony import */ var _BoneData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BoneData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/BoneData.mjs");
/* harmony import */ var _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraintData.mjs");
/* harmony import */ var _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs");
/* harmony import */ var _Skin_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Skin.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Skin.mjs");
/* harmony import */ var _EventData_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EventData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/EventData.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");
















class SkeletonBinary {
  constructor(attachmentLoader) {
    this.ver40 = false;
    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
     * runtime than were used in Spine.
     *
     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(binary) {
    const scale = this.scale;
    const skeletonData = new _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_2__.SkeletonData();
    skeletonData.name = "";
    const input = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.BinaryInput(binary);
    const lowHash = input.readInt32();
    const highHash = input.readInt32();
    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);
    skeletonData.version = input.readString();
    const verShort = skeletonData.version.substr(0, 3);
    if (verShort !== "4.0" && verShort !== "4.1") {
      const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;
      console.error(error);
    }
    this.ver40 = verShort === "4.0";
    skeletonData.x = input.readFloat();
    skeletonData.y = input.readFloat();
    skeletonData.width = input.readFloat();
    skeletonData.height = input.readFloat();
    const nonessential = input.readBoolean();
    if (nonessential) {
      skeletonData.fps = input.readFloat();
      skeletonData.imagesPath = input.readString();
      skeletonData.audioPath = input.readString();
    }
    let n = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const str = input.readString();
      if (!str)
        throw new Error("String in string table must not be null.");
      input.strings.push(str);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Bone name must not be null.");
      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];
      const data = new _BoneData_mjs__WEBPACK_IMPORTED_MODULE_4__.BoneData(i, name, parent);
      data.rotation = input.readFloat();
      data.x = input.readFloat() * scale;
      data.y = input.readFloat() * scale;
      data.scaleX = input.readFloat();
      data.scaleY = input.readFloat();
      data.shearX = input.readFloat();
      data.shearY = input.readFloat();
      data.length = input.readFloat() * scale;
      data.transformMode = input.readInt(true);
      data.skinRequired = input.readBoolean();
      if (nonessential)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(data.color, input.readInt32());
      skeletonData.bones.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const slotName = input.readString();
      if (!slotName)
        throw new Error("Slot name must not be null.");
      const boneData = skeletonData.bones[input.readInt(true)];
      const data = new _SlotData_mjs__WEBPACK_IMPORTED_MODULE_3__.SlotData(i, slotName, boneData);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(data.color, input.readInt32());
      const darkColor = input.readInt32();
      if (darkColor != -1)
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgb888ToColor(data.darkColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color(), darkColor);
      data.attachmentName = input.readStringRef();
      data.blendMode = input.readInt(true);
      skeletonData.slots.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("IK constraint data name must not be null.");
      const data = new _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.IkConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.mix = input.readFloat();
      data.softness = input.readFloat() * scale;
      data.bendDirection = input.readByte();
      data.compress = input.readBoolean();
      data.stretch = input.readBoolean();
      data.uniform = input.readBoolean();
      skeletonData.ikConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Transform constraint data name must not be null.");
      const data = new _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.TransformConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.bones[input.readInt(true)];
      data.local = input.readBoolean();
      data.relative = input.readBoolean();
      data.offsetRotation = input.readFloat();
      data.offsetX = input.readFloat() * scale;
      data.offsetY = input.readFloat() * scale;
      data.offsetScaleX = input.readFloat();
      data.offsetScaleY = input.readFloat();
      data.offsetShearY = input.readFloat();
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      data.mixScaleX = input.readFloat();
      data.mixScaleY = input.readFloat();
      data.mixShearY = input.readFloat();
      skeletonData.transformConstraints.push(data);
    }
    n = input.readInt(true);
    for (let i = 0, nn; i < n; i++) {
      const name = input.readString();
      if (!name)
        throw new Error("Path constraint data name must not be null.");
      const data = new _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.PathConstraintData(name);
      data.order = input.readInt(true);
      data.skinRequired = input.readBoolean();
      nn = input.readInt(true);
      for (let ii = 0; ii < nn; ii++)
        data.bones.push(skeletonData.bones[input.readInt(true)]);
      data.target = skeletonData.slots[input.readInt(true)];
      data.positionMode = input.readInt(true);
      data.spacingMode = input.readInt(true);
      data.rotateMode = input.readInt(true);
      data.offsetRotation = input.readFloat();
      data.position = input.readFloat();
      if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
        data.position *= scale;
      data.spacing = input.readFloat();
      if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Fixed)
        data.spacing *= scale;
      data.mixRotate = input.readFloat();
      data.mixX = input.readFloat();
      data.mixY = input.readFloat();
      skeletonData.pathConstraints.push(data);
    }
    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);
    if (defaultSkin) {
      skeletonData.defaultSkin = defaultSkin;
      skeletonData.skins.push(defaultSkin);
    }
    {
      let i = skeletonData.skins.length;
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));
      for (; i < n; i++) {
        const skin = this.readSkin(input, skeletonData, false, nonessential);
        if (!skin)
          throw new Error("readSkin() should not have returned null.");
        skeletonData.skins[i] = skin;
      }
    }
    n = this.linkedMeshes.length;
    for (let i = 0; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error("Not skin found for linked mesh.");
      if (!linkedMesh.parent)
        throw new Error("Linked mesh parent must not be null");
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const eventName = input.readStringRef();
      if (!eventName)
        throw new Error();
      const data = new _EventData_mjs__WEBPACK_IMPORTED_MODULE_9__.EventData(eventName);
      data.intValue = input.readInt(false);
      data.floatValue = input.readFloat();
      data.stringValue = input.readString();
      data.audioPath = input.readString();
      if (data.audioPath) {
        data.volume = input.readFloat();
        data.balance = input.readFloat();
      }
      skeletonData.events.push(data);
    }
    n = input.readInt(true);
    for (let i = 0; i < n; i++) {
      const animationName = input.readString();
      if (!animationName)
        throw new Error("Animatio name must not be null.");
      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));
    }
    return skeletonData;
  }
  readSkin(input, skeletonData, defaultSkin, nonessential) {
    let skin = null;
    let slotCount = 0;
    if (defaultSkin) {
      slotCount = input.readInt(true);
      if (slotCount == 0)
        return null;
      skin = new _Skin_mjs__WEBPACK_IMPORTED_MODULE_8__.Skin("default");
    } else {
      const skinName = input.readStringRef();
      if (!skinName)
        throw new Error("Skin name must not be null.");
      skin = new _Skin_mjs__WEBPACK_IMPORTED_MODULE_8__.Skin(skinName);
      skin.bones.length = input.readInt(true);
      for (let i = 0, n = skin.bones.length; i < n; i++)
        skin.bones[i] = skeletonData.bones[input.readInt(true)];
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);
      for (let i = 0, n = input.readInt(true); i < n; i++)
        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);
      slotCount = input.readInt(true);
    }
    for (let i = 0; i < slotCount; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const name = input.readStringRef();
        if (!name)
          throw new Error("Attachment name must not be null");
        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
        if (attachment)
          skin.setAttachment(slotIndex, name, attachment);
      }
    }
    return skin;
  }
  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
    const scale = this.scale;
    let name = input.readStringRef();
    if (!name)
      name = attachmentName;
    switch (input.readByte()) {
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Region: {
        let path = input.readStringRef();
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const scaleX = input.readFloat();
        const scaleY = input.readFloat();
        const width = input.readFloat();
        const height = input.readFloat();
        const color = input.readInt32();
        const sequence = this.readSequence(input);
        if (!path)
          path = name;
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = x * scale;
        region.y = y * scale;
        region.scaleX = scaleX;
        region.scaleY = scaleY;
        region.rotation = rotation;
        region.width = width * scale;
        region.height = height * scale;
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(region.color, color);
        region.sequence = sequence;
        if (sequence == null)
          region.updateRegion();
        return region;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.BoundingBox: {
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        box.worldVerticesLength = vertexCount << 1;
        box.vertices = vertices.vertices;
        box.bones = vertices.bones;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(box.color, color);
        return box;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Mesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const vertexCount = input.readInt(true);
        const uvs = this.readFloatArray(input, vertexCount << 1, 1);
        const triangles = this.readShortArray(input);
        const vertices = this.readVertices(input, vertexCount);
        const hullLength = input.readInt(true);
        const sequence = this.readSequence(input);
        let edges = [];
        let width = 0;
        let height = 0;
        if (nonessential) {
          edges = this.readShortArray(input);
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(mesh.color, color);
        mesh.bones = vertices.bones;
        mesh.vertices = vertices.vertices;
        mesh.worldVerticesLength = vertexCount << 1;
        mesh.triangles = triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.hullLength = hullLength << 1;
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.edges = edges;
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        return mesh;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.LinkedMesh: {
        let path = input.readStringRef();
        const color = input.readInt32();
        const skinName = input.readStringRef();
        const parent = input.readStringRef();
        const inheritTimelines = input.readBoolean();
        const sequence = this.readSequence(input);
        let width = 0;
        let height = 0;
        if (nonessential) {
          width = input.readFloat();
          height = input.readFloat();
        }
        if (!path)
          path = name;
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(mesh.color, color);
        mesh.sequence = sequence;
        if (nonessential) {
          mesh.width = width * scale;
          mesh.height = height * scale;
        }
        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));
        return mesh;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Path: {
        const closed = input.readBoolean();
        const constantSpeed = input.readBoolean();
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0, n = lengths.length; i < n; i++)
          lengths[i] = input.readFloat() * scale;
        const color = nonessential ? input.readInt32() : 0;
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = closed;
        path.constantSpeed = constantSpeed;
        path.worldVerticesLength = vertexCount << 1;
        path.vertices = vertices.vertices;
        path.bones = vertices.bones;
        path.lengths = lengths;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(path.color, color);
        return path;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Point: {
        const rotation = input.readFloat();
        const x = input.readFloat();
        const y = input.readFloat();
        const color = nonessential ? input.readInt32() : 0;
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = x * scale;
        point.y = y * scale;
        point.rotation = rotation;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(point.color, color);
        return point;
      }
      case _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.AttachmentType.Clipping: {
        const endSlotIndex = input.readInt(true);
        const vertexCount = input.readInt(true);
        const vertices = this.readVertices(input, vertexCount);
        const color = nonessential ? input.readInt32() : 0;
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        clip.endSlot = skeletonData.slots[endSlotIndex];
        clip.worldVerticesLength = vertexCount << 1;
        clip.vertices = vertices.vertices;
        clip.bones = vertices.bones;
        if (nonessential)
          _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.rgba8888ToColor(clip.color, color);
        return clip;
      }
    }
    return null;
  }
  readSequence(input) {
    if (this.ver40 || !input.readBoolean())
      return null;
    const sequence = new _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_14__.Sequence(input.readInt(true));
    sequence.start = input.readInt(true);
    sequence.digits = input.readInt(true);
    sequence.setupIndex = input.readInt(true);
    return sequence;
  }
  readDeformTimelineType(input) {
    if (this.ver40)
      return ATTACHMENT_DEFORM;
    return input.readByte();
  }
  readVertices(input, vertexCount) {
    const scale = this.scale;
    const verticesLength = vertexCount << 1;
    const vertices = new Vertices();
    if (!input.readBoolean()) {
      vertices.vertices = this.readFloatArray(input, verticesLength, scale);
      return vertices;
    }
    const weights = new Array();
    const bonesArray = new Array();
    for (let i = 0; i < vertexCount; i++) {
      const boneCount = input.readInt(true);
      bonesArray.push(boneCount);
      for (let ii = 0; ii < boneCount; ii++) {
        bonesArray.push(input.readInt(true));
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat() * scale);
        weights.push(input.readFloat());
      }
    }
    vertices.vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(weights);
    vertices.bones = bonesArray;
    return vertices;
  }
  readFloatArray(input, n, scale) {
    const array = new Array(n);
    if (scale == 1) {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat();
    } else {
      for (let i = 0; i < n; i++)
        array[i] = input.readFloat() * scale;
    }
    return array;
  }
  readShortArray(input) {
    const n = input.readInt(true);
    const array = new Array(n);
    for (let i = 0; i < n; i++)
      array[i] = input.readShort();
    return array;
  }
  readAnimation(input, name, skeletonData) {
    input.readInt(true);
    const timelines = new Array();
    const scale = this.scale;
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const slotIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const timelineType = input.readByte();
        const frameCount = input.readInt(true);
        const frameLast = frameCount - 1;
        switch (timelineType) {
          case SLOT_ATTACHMENT: {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentTimeline(frameCount, slotIndex);
            for (let frame = 0; frame < frameCount; frame++)
              timeline.setFrame(frame, input.readFloat(), input.readStringRef());
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA: {
            const bezierCount = input.readInt(true);
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGBATimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
              a = a2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB: {
            const bezierCount = input.readInt(true);
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGBTimeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const r2 = input.readUnsignedByte() / 255;
              const g2 = input.readUnsignedByte() / 255;
              const b2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);
              }
              time = time2;
              r = r2;
              g = g2;
              b = b2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGBA2: {
            const bezierCount = input.readInt(true);
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGBA2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let a = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const na = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              a = na;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_RGB2: {
            const bezierCount = input.readInt(true);
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGB2Timeline(frameCount, bezierCount, slotIndex);
            let time = input.readFloat();
            let r = input.readUnsignedByte() / 255;
            let g = input.readUnsignedByte() / 255;
            let b = input.readUnsignedByte() / 255;
            let r2 = input.readUnsignedByte() / 255;
            let g2 = input.readUnsignedByte() / 255;
            let b2 = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, r, g, b, r2, g2, b2);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const nr = input.readUnsignedByte() / 255;
              const ng = input.readUnsignedByte() / 255;
              const nb = input.readUnsignedByte() / 255;
              const nr2 = input.readUnsignedByte() / 255;
              const ng2 = input.readUnsignedByte() / 255;
              const nb2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);
                  setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);
                  setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);
                  setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);
              }
              time = time2;
              r = nr;
              g = ng;
              b = nb;
              r2 = nr2;
              g2 = ng2;
              b2 = nb2;
            }
            timelines.push(timeline);
            break;
          }
          case SLOT_ALPHA: {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.AlphaTimeline(frameCount, input.readInt(true), slotIndex);
            let time = input.readFloat();
            let a = input.readUnsignedByte() / 255;
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, a);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const a2 = input.readUnsignedByte() / 255;
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);
              }
              time = time2;
              a = a2;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const boneIndex = input.readInt(true);
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const type = input.readByte();
        const frameCount = input.readInt(true);
        const bezierCount = input.readInt(true);
        switch (type) {
          case BONE_ROTATE:
            timelines.push(readTimeline1(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RotateTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_TRANSLATE:
            timelines.push(readTimeline2(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TranslateTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEX:
            timelines.push(readTimeline1(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_TRANSLATEY:
            timelines.push(readTimeline1(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));
            break;
          case BONE_SCALE:
            timelines.push(readTimeline2(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ScaleTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEX:
            timelines.push(readTimeline1(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SCALEY:
            timelines.push(readTimeline1(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEAR:
            timelines.push(readTimeline2(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ShearTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARX:
            timelines.push(readTimeline1(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ShearXTimeline(frameCount, bezierCount, boneIndex), 1));
            break;
          case BONE_SHEARY:
            timelines.push(readTimeline1(input, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ShearYTimeline(frameCount, bezierCount, boneIndex), 1));
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.IkConstraintTimeline(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mix = input.readFloat();
      let softness = input.readFloat() * scale;
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mix2 = input.readFloat();
        const softness2 = input.readFloat() * scale;
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);
        }
        time = time2;
        mix = mix2;
        softness = softness2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const frameCount = input.readInt(true);
      const frameLast = frameCount - 1;
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TransformConstraintTimeline(frameCount, input.readInt(true), index);
      let time = input.readFloat();
      let mixRotate = input.readFloat();
      let mixX = input.readFloat();
      let mixY = input.readFloat();
      let mixScaleX = input.readFloat();
      let mixScaleY = input.readFloat();
      let mixShearY = input.readFloat();
      for (let frame = 0, bezier = 0; ; frame++) {
        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
        if (frame == frameLast)
          break;
        const time2 = input.readFloat();
        const mixRotate2 = input.readFloat();
        const mixX2 = input.readFloat();
        const mixY2 = input.readFloat();
        const mixScaleX2 = input.readFloat();
        const mixScaleY2 = input.readFloat();
        const mixShearY2 = input.readFloat();
        switch (input.readByte()) {
          case CURVE_STEPPED:
            timeline.setStepped(frame);
            break;
          case CURVE_BEZIER:
            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);
        }
        time = time2;
        mixRotate = mixRotate2;
        mixX = mixX2;
        mixY = mixY2;
        mixScaleX = mixScaleX2;
        mixScaleY = mixScaleY2;
        mixShearY = mixShearY2;
      }
      timelines.push(timeline);
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const index = input.readInt(true);
      const data = skeletonData.pathConstraints[index];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        switch (input.readByte()) {
          case PATH_POSITION:
            timelines.push(
              readTimeline1(
                input,
                new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),
                data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed ? scale : 1
              )
            );
            break;
          case PATH_SPACING:
            timelines.push(
              readTimeline1(
                input,
                new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),
                data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Fixed ? scale : 1
              )
            );
            break;
          case PATH_MIX:
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);
            let time = input.readFloat();
            let mixRotate = input.readFloat();
            let mixX = input.readFloat();
            let mixY = input.readFloat();
            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              if (frame == frameLast)
                break;
              const time2 = input.readFloat();
              const mixRotate2 = input.readFloat();
              const mixX2 = input.readFloat();
              const mixY2 = input.readFloat();
              switch (input.readByte()) {
                case CURVE_STEPPED:
                  timeline.setStepped(frame);
                  break;
                case CURVE_BEZIER:
                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);
                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
            }
            timelines.push(timeline);
        }
      }
    }
    for (let i = 0, n = input.readInt(true); i < n; i++) {
      const skin = skeletonData.skins[input.readInt(true)];
      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {
        const slotIndex = input.readInt(true);
        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
          const attachmentName = input.readStringRef();
          if (!attachmentName)
            throw new Error("attachmentName must not be null.");
          const attachment = skin.getAttachment(slotIndex, attachmentName);
          const timelineType = this.readDeformTimelineType(input);
          const frameCount = input.readInt(true);
          const frameLast = frameCount - 1;
          switch (timelineType) {
            case ATTACHMENT_DEFORM: {
              const vertexAttachment = attachment;
              const weighted = vertexAttachment.bones;
              const vertices = vertexAttachment.vertices;
              const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
              const bezierCount = input.readInt(true);
              const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);
              let time = input.readFloat();
              for (let frame = 0, bezier = 0; ; frame++) {
                let deform;
                let end = input.readInt(true);
                if (end == 0)
                  deform = weighted ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength) : vertices;
                else {
                  deform = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength);
                  const start = input.readInt(true);
                  end += start;
                  if (scale == 1) {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat();
                  } else {
                    for (let v = start; v < end; v++)
                      deform[v] = input.readFloat() * scale;
                  }
                  if (!weighted) {
                    for (let v = 0, vn = deform.length; v < vn; v++)
                      deform[v] += vertices[v];
                  }
                }
                timeline.setFrame(frame, time, deform);
                if (frame == frameLast)
                  break;
                const time2 = input.readFloat();
                switch (input.readByte()) {
                  case CURVE_STEPPED:
                    timeline.setStepped(frame);
                    break;
                  case CURVE_BEZIER:
                    setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);
                }
                time = time2;
              }
              timelines.push(timeline);
              break;
            }
            case ATTACHMENT_SEQUENCE: {
              const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.SequenceTimeline(frameCount, slotIndex, attachment);
              for (let frame = 0; frame < frameCount; frame++) {
                const time = input.readFloat();
                const modeAndIndex = input.readInt32();
                timeline.setFrame(frame, time, _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_14__.SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());
              }
              timelines.push(timeline);
              break;
            }
          }
        }
      }
    }
    const drawOrderCount = input.readInt(true);
    if (drawOrderCount > 0) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.DrawOrderTimeline(drawOrderCount);
      const slotCount = skeletonData.slots.length;
      for (let i = 0; i < drawOrderCount; i++) {
        const time = input.readFloat();
        const offsetCount = input.readInt(true);
        const drawOrder = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount, 0);
        for (let ii = slotCount - 1; ii >= 0; ii--)
          drawOrder[ii] = -1;
        const unchanged = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount - offsetCount, 0);
        let originalIndex = 0;
        let unchangedIndex = 0;
        for (let ii = 0; ii < offsetCount; ii++) {
          const slotIndex = input.readInt(true);
          while (originalIndex != slotIndex)
            unchanged[unchangedIndex++] = originalIndex++;
          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
        }
        while (originalIndex < slotCount)
          unchanged[unchangedIndex++] = originalIndex++;
        for (let ii = slotCount - 1; ii >= 0; ii--)
          if (drawOrder[ii] == -1)
            drawOrder[ii] = unchanged[--unchangedIndex];
        timeline.setFrame(i, time, drawOrder);
      }
      timelines.push(timeline);
    }
    const eventCount = input.readInt(true);
    if (eventCount > 0) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.EventTimeline(eventCount);
      for (let i = 0; i < eventCount; i++) {
        const time = input.readFloat();
        const eventData = skeletonData.events[input.readInt(true)];
        const event = new _Event_mjs__WEBPACK_IMPORTED_MODULE_1__.Event(time, eventData);
        event.intValue = input.readInt(false);
        event.floatValue = input.readFloat();
        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;
        if (event.data.audioPath) {
          event.volume = input.readFloat();
          event.balance = input.readFloat();
        }
        timeline.setFrame(i, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    return new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.Animation(name, timelines, duration);
  }
}
SkeletonBinary.BlendModeValues = [_pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.NORMAL, _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.ADD, _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.MULTIPLY, _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.SCREEN];
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
}
class Vertices {
  constructor(bones = null, vertices = null) {
    this.bones = bones;
    this.vertices = vertices;
  }
}
function readTimeline1(input, timeline, scale) {
  let time = input.readFloat();
  let value = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const value2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);
    }
    time = time2;
    value = value2;
  }
  return timeline;
}
function readTimeline2(input, timeline, scale) {
  let time = input.readFloat();
  let value1 = input.readFloat() * scale;
  let value2 = input.readFloat() * scale;
  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    if (frame == frameLast)
      break;
    const time2 = input.readFloat();
    const nvalue1 = input.readFloat() * scale;
    const nvalue2 = input.readFloat() * scale;
    switch (input.readByte()) {
      case CURVE_STEPPED:
        timeline.setStepped(frame);
        break;
      case CURVE_BEZIER:
        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);
        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
  }
  return timeline;
}
function setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);
}
const BONE_ROTATE = 0;
const BONE_TRANSLATE = 1;
const BONE_TRANSLATEX = 2;
const BONE_TRANSLATEY = 3;
const BONE_SCALE = 4;
const BONE_SCALEX = 5;
const BONE_SCALEY = 6;
const BONE_SHEAR = 7;
const BONE_SHEARX = 8;
const BONE_SHEARY = 9;
const SLOT_ATTACHMENT = 0;
const SLOT_RGBA = 1;
const SLOT_RGB = 2;
const SLOT_RGBA2 = 3;
const SLOT_RGB2 = 4;
const SLOT_ALPHA = 5;
const ATTACHMENT_DEFORM = 0;
const ATTACHMENT_SEQUENCE = 1;
const PATH_POSITION = 0;
const PATH_SPACING = 1;
const PATH_MIX = 2;
const CURVE_STEPPED = 1;
const CURVE_BEZIER = 2;


//# sourceMappingURL=SkeletonBinary.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBounds.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBounds.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonBounds": function() { return /* binding */ SkeletonBounds; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class SkeletonBounds extends _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.SkeletonBoundsBase {
}


//# sourceMappingURL=SkeletonBounds.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonData.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonData.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonData": function() { return /* binding */ SkeletonData; }
/* harmony export */ });
class SkeletonData {
  constructor() {
    /** The skeleton's name, which by default is the name of the skeleton data file, if possible. May be null. */
    this.name = null;
    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */
    this.bones = new Array();
    // Ordered parents first.
    /** The skeleton's slots. */
    this.slots = new Array();
    // Setup pose draw order.
    this.skins = new Array();
    /** The skeleton's default skin. By default this skin contains all attachments that were not in a skin in Spine.
     *
     * See {@link Skeleton#getAttachmentByName()}.
     * May be null. */
    this.defaultSkin = null;
    /** The skeleton's events. */
    this.events = new Array();
    /** The skeleton's animations. */
    this.animations = new Array();
    /** The skeleton's IK constraints. */
    this.ikConstraints = new Array();
    /** The skeleton's transform constraints. */
    this.transformConstraints = new Array();
    /** The skeleton's path constraints. */
    this.pathConstraints = new Array();
    /** The X coordinate of the skeleton's axis aligned bounding box in the setup pose. */
    this.x = 0;
    /** The Y coordinate of the skeleton's axis aligned bounding box in the setup pose. */
    this.y = 0;
    /** The width of the skeleton's axis aligned bounding box in the setup pose. */
    this.width = 0;
    /** The height of the skeleton's axis aligned bounding box in the setup pose. */
    this.height = 0;
    /** The Spine version used to export the skeleton data, or null. */
    this.version = null;
    /** The skeleton data hash. This value will change if any of the skeleton data has changed. May be null. */
    this.hash = null;
    // Nonessential
    /** The dopesheet FPS in Spine. Available only when nonessential data was exported. */
    this.fps = 0;
    /** The path to the images directory as defined in Spine. Available only when nonessential data was exported. May be null. */
    this.imagesPath = null;
    /** The path to the audio directory as defined in Spine. Available only when nonessential data was exported. May be null. */
    this.audioPath = null;
  }
  /** Finds a bone by comparing each bone's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findBone(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      if (bone.name == boneName)
        return bone;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findBoneIndex(boneName) {
    if (!boneName)
      throw new Error("boneName cannot be null.");
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++)
      if (bones[i].name == boneName)
        return i;
    return -1;
  }
  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSlot(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++) {
      const slot = slots[i];
      if (slot.name == slotName)
        return slot;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findSlotIndex(slotName) {
    if (!slotName)
      throw new Error("slotName cannot be null.");
    const slots = this.slots;
    for (let i = 0, n = slots.length; i < n; i++)
      if (slots[i].name == slotName)
        return i;
    return -1;
  }
  /** Finds a skin by comparing each skin's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findSkin(skinName) {
    if (!skinName)
      throw new Error("skinName cannot be null.");
    const skins = this.skins;
    for (let i = 0, n = skins.length; i < n; i++) {
      const skin = skins[i];
      if (skin.name == skinName)
        return skin;
    }
    return null;
  }
  /** Finds an event by comparing each events's name. It is more efficient to cache the results of this method than to call it
   * multiple times.
   * @returns May be null. */
  findEvent(eventDataName) {
    if (!eventDataName)
      throw new Error("eventDataName cannot be null.");
    const events = this.events;
    for (let i = 0, n = events.length; i < n; i++) {
      const event = events[i];
      if (event.name == eventDataName)
        return event;
    }
    return null;
  }
  /** Finds an animation by comparing each animation's name. It is more efficient to cache the results of this method than to
   * call it multiple times.
   * @returns May be null. */
  findAnimation(animationName) {
    if (!animationName)
      throw new Error("animationName cannot be null.");
    const animations = this.animations;
    for (let i = 0, n = animations.length; i < n; i++) {
      const animation = animations[i];
      if (animation.name == animationName)
        return animation;
    }
    return null;
  }
  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findIkConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const ikConstraints = this.ikConstraints;
    for (let i = 0, n = ikConstraints.length; i < n; i++) {
      const constraint = ikConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of
   * this method than to call it multiple times.
   * @return May be null. */
  findTransformConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const transformConstraints = this.transformConstraints;
    for (let i = 0, n = transformConstraints.length; i < n; i++) {
      const constraint = transformConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method
   * than to call it multiple times.
   * @return May be null. */
  findPathConstraint(constraintName) {
    if (!constraintName)
      throw new Error("constraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++) {
      const constraint = pathConstraints[i];
      if (constraint.name == constraintName)
        return constraint;
    }
    return null;
  }
  /** removed from spine-ts runtime **/
  findPathConstraintIndex(pathConstraintName) {
    if (pathConstraintName == null)
      throw new Error("pathConstraintName cannot be null.");
    const pathConstraints = this.pathConstraints;
    for (let i = 0, n = pathConstraints.length; i < n; i++)
      if (pathConstraints[i].name == pathConstraintName)
        return i;
    return -1;
  }
}


//# sourceMappingURL=SkeletonData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonJson.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonJson.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkeletonJson": function() { return /* binding */ SkeletonJson; }
/* harmony export */ });
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs");
/* harmony import */ var _Event_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Event.mjs");
/* harmony import */ var _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonData.mjs");
/* harmony import */ var _SlotData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SlotData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SlotData.mjs");
/* harmony import */ var _BoneData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BoneData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/BoneData.mjs");
/* harmony import */ var _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraintData.mjs");
/* harmony import */ var _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs");
/* harmony import */ var _Skin_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Skin.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Skin.mjs");
/* harmony import */ var _EventData_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EventData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/EventData.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");














class SkeletonJson {
  constructor(attachmentLoader) {
    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at
     * runtime than were used in Spine.
     *
     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */
    this.scale = 1;
    this.linkedMeshes = new Array();
    this.attachmentLoader = attachmentLoader;
  }
  readSkeletonData(json) {
    const scale = this.scale;
    const skeletonData = new _SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_2__.SkeletonData();
    const root = typeof json === "string" ? JSON.parse(json) : json;
    const skeletonMap = root.skeleton;
    if (skeletonMap) {
      skeletonData.hash = skeletonMap.hash;
      skeletonData.version = skeletonMap.spine;
      const verShort = skeletonData.version.substr(0, 3);
      if (verShort !== "4.0" && verShort !== "4.1") {
        const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;
        console.error(error);
      }
      skeletonData.x = skeletonMap.x;
      skeletonData.y = skeletonMap.y;
      skeletonData.width = skeletonMap.width;
      skeletonData.height = skeletonMap.height;
      skeletonData.fps = skeletonMap.fps;
      skeletonData.imagesPath = skeletonMap.images;
    }
    if (root.bones) {
      for (let i = 0; i < root.bones.length; i++) {
        const boneMap = root.bones[i];
        let parent = null;
        const parentName = getValue(boneMap, "parent", null);
        if (parentName != null) {
          parent = skeletonData.findBone(parentName);
          if (parent == null)
            throw new Error(`Parent bone not found: ${parentName}`);
        }
        const data = new _BoneData_mjs__WEBPACK_IMPORTED_MODULE_4__.BoneData(skeletonData.bones.length, boneMap.name, parent);
        data.length = getValue(boneMap, "length", 0) * scale;
        data.x = getValue(boneMap, "x", 0) * scale;
        data.y = getValue(boneMap, "y", 0) * scale;
        data.rotation = getValue(boneMap, "rotation", 0);
        data.scaleX = getValue(boneMap, "scaleX", 1);
        data.scaleY = getValue(boneMap, "scaleY", 1);
        data.shearX = getValue(boneMap, "shearX", 0);
        data.shearY = getValue(boneMap, "shearY", 0);
        data.transformMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.enumValue(_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.TransformMode, getValue(boneMap, "transform", "Normal"));
        data.skinRequired = getValue(boneMap, "skin", false);
        const color = getValue(boneMap, "color", null);
        if (color)
          data.color.setFromString(color);
        skeletonData.bones.push(data);
      }
    }
    if (root.slots) {
      for (let i = 0; i < root.slots.length; i++) {
        const slotMap = root.slots[i];
        const boneData = skeletonData.findBone(slotMap.bone);
        if (!boneData)
          throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);
        const data = new _SlotData_mjs__WEBPACK_IMPORTED_MODULE_3__.SlotData(skeletonData.slots.length, slotMap.name, boneData);
        const color = getValue(slotMap, "color", null);
        if (color)
          data.color.setFromString(color);
        const dark = getValue(slotMap, "dark", null);
        if (dark)
          data.darkColor = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(dark);
        data.attachmentName = getValue(slotMap, "attachment", null);
        data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, "blend", "normal"));
        skeletonData.slots.push(data);
      }
    }
    if (root.ik) {
      for (let i = 0; i < root.ik.length; i++) {
        const constraintMap = root.ik[i];
        const data = new _IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_5__.IkConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (bone == null)
            throw new Error(`IK bone not found: ${boneName}`);
          data.bones.push(bone);
        }
        data.target = skeletonData.findBone(constraintMap.target);
        data.mix = getValue(constraintMap, "mix", 1);
        data.softness = getValue(constraintMap, "softness", 0) * scale;
        data.bendDirection = getValue(constraintMap, "bendPositive", true) ? 1 : -1;
        data.compress = getValue(constraintMap, "compress", false);
        data.stretch = getValue(constraintMap, "stretch", false);
        data.uniform = getValue(constraintMap, "uniform", false);
        skeletonData.ikConstraints.push(data);
      }
    }
    if (root.transform) {
      for (let i = 0; i < root.transform.length; i++) {
        const constraintMap = root.transform[i];
        const data = new _TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_6__.TransformConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findBone(targetName);
        if (!target)
          throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);
        data.target = target;
        data.local = getValue(constraintMap, "local", false);
        data.relative = getValue(constraintMap, "relative", false);
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.offsetX = getValue(constraintMap, "x", 0) * scale;
        data.offsetY = getValue(constraintMap, "y", 0) * scale;
        data.offsetScaleX = getValue(constraintMap, "scaleX", 0);
        data.offsetScaleY = getValue(constraintMap, "scaleY", 0);
        data.offsetShearY = getValue(constraintMap, "shearY", 0);
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        data.mixScaleX = getValue(constraintMap, "mixScaleX", 1);
        data.mixScaleY = getValue(constraintMap, "mixScaleY", data.mixScaleX);
        data.mixShearY = getValue(constraintMap, "mixShearY", 1);
        skeletonData.transformConstraints.push(data);
      }
    }
    if (root.path) {
      for (let i = 0; i < root.path.length; i++) {
        const constraintMap = root.path[i];
        const data = new _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.PathConstraintData(constraintMap.name);
        data.order = getValue(constraintMap, "order", 0);
        data.skinRequired = getValue(constraintMap, "skin", false);
        for (let ii = 0; ii < constraintMap.bones.length; ii++) {
          const boneName = constraintMap.bones[ii];
          const bone = skeletonData.findBone(boneName);
          if (!bone)
            throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);
          data.bones.push(bone);
        }
        const targetName = constraintMap.target;
        const target = skeletonData.findSlot(targetName);
        if (!target)
          throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);
        data.target = target;
        data.positionMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.enumValue(_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode, getValue(constraintMap, "positionMode", "Percent"));
        data.spacingMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.enumValue(_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode, getValue(constraintMap, "spacingMode", "Length"));
        data.rotateMode = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.enumValue(_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.RotateMode, getValue(constraintMap, "rotateMode", "Tangent"));
        data.offsetRotation = getValue(constraintMap, "rotation", 0);
        data.position = getValue(constraintMap, "position", 0);
        if (data.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed)
          data.position *= scale;
        data.spacing = getValue(constraintMap, "spacing", 0);
        if (data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Length || data.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Fixed)
          data.spacing *= scale;
        data.mixRotate = getValue(constraintMap, "mixRotate", 1);
        data.mixX = getValue(constraintMap, "mixX", 1);
        data.mixY = getValue(constraintMap, "mixY", data.mixX);
        skeletonData.pathConstraints.push(data);
      }
    }
    if (root.skins) {
      for (let i = 0; i < root.skins.length; i++) {
        const skinMap = root.skins[i];
        const skin = new _Skin_mjs__WEBPACK_IMPORTED_MODULE_8__.Skin(skinMap.name);
        if (skinMap.bones) {
          for (let ii = 0; ii < skinMap.bones.length; ii++) {
            const boneName = skinMap.bones[ii];
            const bone = skeletonData.findBone(boneName);
            if (!bone)
              throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);
            skin.bones.push(bone);
          }
        }
        if (skinMap.ik) {
          for (let ii = 0; ii < skinMap.ik.length; ii++) {
            const constraintName = skinMap.ik[ii];
            const constraint = skeletonData.findIkConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.transform) {
          for (let ii = 0; ii < skinMap.transform.length; ii++) {
            const constraintName = skinMap.transform[ii];
            const constraint = skeletonData.findTransformConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        if (skinMap.path) {
          for (let ii = 0; ii < skinMap.path.length; ii++) {
            const constraintName = skinMap.path[ii];
            const constraint = skeletonData.findPathConstraint(constraintName);
            if (!constraint)
              throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);
            skin.constraints.push(constraint);
          }
        }
        for (const slotName in skinMap.attachments) {
          const slot = skeletonData.findSlot(slotName);
          if (!slot)
            throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);
          const slotMap = skinMap.attachments[slotName];
          for (const entryName in slotMap) {
            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
            if (attachment)
              skin.setAttachment(slot.index, entryName, attachment);
          }
        }
        skeletonData.skins.push(skin);
        if (skin.name == "default")
          skeletonData.defaultSkin = skin;
      }
    }
    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {
      const linkedMesh = this.linkedMeshes[i];
      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
      if (!skin)
        throw new Error(`Skin not found: ${linkedMesh.skin}`);
      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
      if (!parent)
        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);
      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;
      linkedMesh.mesh.setParentMesh(parent);
    }
    this.linkedMeshes.length = 0;
    if (root.events) {
      for (const eventName in root.events) {
        const eventMap = root.events[eventName];
        const data = new _EventData_mjs__WEBPACK_IMPORTED_MODULE_9__.EventData(eventName);
        data.intValue = getValue(eventMap, "int", 0);
        data.floatValue = getValue(eventMap, "float", 0);
        data.stringValue = getValue(eventMap, "string", "");
        data.audioPath = getValue(eventMap, "audio", null);
        if (data.audioPath) {
          data.volume = getValue(eventMap, "volume", 1);
          data.balance = getValue(eventMap, "balance", 0);
        }
        skeletonData.events.push(data);
      }
    }
    if (root.animations) {
      for (const animationName in root.animations) {
        const animationMap = root.animations[animationName];
        this.readAnimation(animationMap, animationName, skeletonData);
      }
    }
    return skeletonData;
  }
  readAttachment(map, skin, slotIndex, name, skeletonData) {
    const scale = this.scale;
    name = getValue(map, "name", name);
    switch (getValue(map, "type", "region")) {
      case "region": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);
        if (!region)
          return null;
        region.path = path;
        region.x = getValue(map, "x", 0) * scale;
        region.y = getValue(map, "y", 0) * scale;
        region.scaleX = getValue(map, "scaleX", 1);
        region.scaleY = getValue(map, "scaleY", 1);
        region.rotation = getValue(map, "rotation", 0);
        region.width = map.width * scale;
        region.height = map.height * scale;
        region.sequence = sequence;
        const color = getValue(map, "color", null);
        if (color)
          region.color.setFromString(color);
        return region;
      }
      case "boundingbox": {
        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
        if (!box)
          return null;
        this.readVertices(map, box, map.vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          box.color.setFromString(color);
        return box;
      }
      case "mesh":
      case "linkedmesh": {
        const path = getValue(map, "path", name);
        const sequence = this.readSequence(getValue(map, "sequence", null));
        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);
        if (!mesh)
          return null;
        mesh.path = path;
        const color = getValue(map, "color", null);
        if (color)
          mesh.color.setFromString(color);
        mesh.width = getValue(map, "width", 0) * scale;
        mesh.height = getValue(map, "height", 0) * scale;
        mesh.sequence = sequence;
        const parent = getValue(map, "parent", null);
        if (parent) {
          this.linkedMeshes.push(new LinkedMesh(mesh, getValue(map, "skin", null), slotIndex, parent, getValue(map, "timelines", true)));
          return mesh;
        }
        const uvs = map.uvs;
        this.readVertices(map, mesh, uvs.length);
        mesh.triangles = map.triangles;
        mesh.regionUVs = new Float32Array(uvs);
        mesh.edges = getValue(map, "edges", null);
        mesh.hullLength = getValue(map, "hull", 0) * 2;
        return mesh;
      }
      case "path": {
        const path = this.attachmentLoader.newPathAttachment(skin, name);
        if (!path)
          return null;
        path.closed = getValue(map, "closed", false);
        path.constantSpeed = getValue(map, "constantSpeed", true);
        const vertexCount = map.vertexCount;
        this.readVertices(map, path, vertexCount << 1);
        const lengths = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(vertexCount / 3, 0);
        for (let i = 0; i < map.lengths.length; i++)
          lengths[i] = map.lengths[i] * scale;
        path.lengths = lengths;
        const color = getValue(map, "color", null);
        if (color)
          path.color.setFromString(color);
        return path;
      }
      case "point": {
        const point = this.attachmentLoader.newPointAttachment(skin, name);
        if (!point)
          return null;
        point.x = getValue(map, "x", 0) * scale;
        point.y = getValue(map, "y", 0) * scale;
        point.rotation = getValue(map, "rotation", 0);
        const color = getValue(map, "color", null);
        if (color)
          point.color.setFromString(color);
        return point;
      }
      case "clipping": {
        const clip = this.attachmentLoader.newClippingAttachment(skin, name);
        if (!clip)
          return null;
        const end = getValue(map, "end", null);
        if (end != null) {
          const slot = skeletonData.findSlot(end);
          if (slot == null)
            throw new Error(`Clipping end slot not found: ${end}`);
          clip.endSlot = slot;
        }
        const vertexCount = map.vertexCount;
        this.readVertices(map, clip, vertexCount << 1);
        const color = getValue(map, "color", null);
        if (color)
          clip.color.setFromString(color);
        return clip;
      }
    }
    return null;
  }
  readSequence(map) {
    if (map == null)
      return null;
    const sequence = new _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_12__.Sequence(getValue(map, "count", 0));
    sequence.start = getValue(map, "start", 1);
    sequence.digits = getValue(map, "digits", 0);
    sequence.setupIndex = getValue(map, "setup", 0);
    return sequence;
  }
  readVertices(map, attachment, verticesLength) {
    const scale = this.scale;
    attachment.worldVerticesLength = verticesLength;
    const vertices = map.vertices;
    if (verticesLength == vertices.length) {
      const scaledVertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(vertices);
      if (scale != 1) {
        for (let i = 0, n = vertices.length; i < n; i++)
          scaledVertices[i] *= scale;
      }
      attachment.vertices = scaledVertices;
      return;
    }
    const weights = new Array();
    const bones = new Array();
    for (let i = 0, n = vertices.length; i < n; ) {
      const boneCount = vertices[i++];
      bones.push(boneCount);
      for (let nn = i + boneCount * 4; i < nn; i += 4) {
        bones.push(vertices[i]);
        weights.push(vertices[i + 1] * scale);
        weights.push(vertices[i + 2] * scale);
        weights.push(vertices[i + 3]);
      }
    }
    attachment.bones = bones;
    attachment.vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toFloatArray(weights);
  }
  readAnimation(map, name, skeletonData) {
    const scale = this.scale;
    const timelines = new Array();
    if (map.slots) {
      for (const slotName in map.slots) {
        const slotMap = map.slots[slotName];
        const slot = skeletonData.findSlot(slotName);
        if (!slot)
          throw new Error(`Slot not found: ${slotName}`);
        const slotIndex = slot.index;
        for (const timelineName in slotMap) {
          const timelineMap = slotMap[timelineName];
          if (!timelineMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName == "attachment") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.AttachmentTimeline(frames, slotIndex);
            for (let frame = 0; frame < frames; frame++) {
              const keyMap = timelineMap[frame];
              timeline.setFrame(frame, getValue(keyMap, "time", 0), getValue(keyMap, "name", null));
            }
            timelines.push(timeline);
          } else if (timelineName == "rgba") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGBATimeline(frames, frames << 2, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGBTimeline(frames, frames * 3, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(keyMap.color);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(nextMap.color);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
              }
              time = time2;
              color = newColor;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "alpha") {
            timelines.push(readTimeline1(timelineMap, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.AlphaTimeline(frames, frames, slotIndex), 0, 1));
          } else if (timelineName == "rgba2") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGBA2Timeline(frames, frames * 7, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(keyMap.light);
            let color2 = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(nextMap.light);
              const newColor2 = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          } else if (timelineName == "rgb2") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RGB2Timeline(frames, frames * 6, slotIndex);
            let keyMap = timelineMap[0];
            let time = getValue(keyMap, "time", 0);
            let color = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(keyMap.light);
            let color2 = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(keyMap.dark);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const newColor = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(nextMap.light);
              const newColor2 = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Color.fromString(nextMap.dark);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);
              }
              time = time2;
              color = newColor;
              color2 = newColor2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.bones) {
      for (const boneName in map.bones) {
        const boneMap = map.bones[boneName];
        const bone = skeletonData.findBone(boneName);
        if (!bone)
          throw new Error(`Bone not found: ${boneName}`);
        const boneIndex = bone.index;
        for (const timelineName in boneMap) {
          const timelineMap = boneMap[timelineName];
          const frames = timelineMap.length;
          if (frames == 0)
            continue;
          if (timelineName === "rotate") {
            timelines.push(readTimeline1(timelineMap, new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.RotateTimeline(frames, frames, boneIndex), 0, 1));
          } else if (timelineName === "translate") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TranslateTimeline(frames, frames << 1, boneIndex);
            timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, scale));
          } else if (timelineName === "translatex") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TranslateXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
          } else if (timelineName === "translatey") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TranslateYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));
          } else if (timelineName === "scale") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ScaleTimeline(frames, frames << 1, boneIndex);
            timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 1, 1));
          } else if (timelineName === "scalex") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ScaleXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
          } else if (timelineName === "scaley") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ScaleYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));
          } else if (timelineName === "shear") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ShearTimeline(frames, frames << 1, boneIndex);
            timelines.push(readTimeline2(timelineMap, timeline, "x", "y", 0, 1));
          } else if (timelineName === "shearx") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ShearXTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
          } else if (timelineName === "sheary") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.ShearYTimeline(frames, frames, boneIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));
          }
        }
      }
    }
    if (map.ik) {
      for (const constraintName in map.ik) {
        const constraintMap = map.ik[constraintName];
        let keyMap = constraintMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findIkConstraint(constraintName);
        if (!constraint)
          throw new Error(`IK Constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);
        const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mix = getValue(keyMap, "mix", 1);
        let softness = getValue(keyMap, "softness", 0) * scale;
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(
            frame,
            time,
            mix,
            softness,
            getValue(keyMap, "bendPositive", true) ? 1 : -1,
            getValue(keyMap, "compress", false),
            getValue(keyMap, "stretch", false)
          );
          const nextMap = constraintMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mix2 = getValue(nextMap, "mix", 1);
          const softness2 = getValue(nextMap, "softness", 0) * scale;
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);
          }
          time = time2;
          mix = mix2;
          softness = softness2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.transform) {
      for (const constraintName in map.transform) {
        const timelineMap = map.transform[constraintName];
        let keyMap = timelineMap[0];
        if (!keyMap)
          continue;
        const constraint = skeletonData.findTransformConstraint(constraintName);
        if (!constraint)
          throw new Error(`Transform constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);
        const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);
        let time = getValue(keyMap, "time", 0);
        let mixRotate = getValue(keyMap, "mixRotate", 1);
        let mixX = getValue(keyMap, "mixX", 1);
        let mixY = getValue(keyMap, "mixY", mixX);
        let mixScaleX = getValue(keyMap, "mixScaleX", 1);
        let mixScaleY = getValue(keyMap, "mixScaleY", mixScaleX);
        const mixShearY = getValue(keyMap, "mixShearY", 1);
        for (let frame = 0, bezier = 0; ; frame++) {
          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
          const nextMap = timelineMap[frame + 1];
          if (!nextMap) {
            timeline.shrink(bezier);
            break;
          }
          const time2 = getValue(nextMap, "time", 0);
          const mixRotate2 = getValue(nextMap, "mixRotate", 1);
          const mixX2 = getValue(nextMap, "mixX", 1);
          const mixY2 = getValue(nextMap, "mixY", mixX2);
          const mixScaleX2 = getValue(nextMap, "mixScaleX", 1);
          const mixScaleY2 = getValue(nextMap, "mixScaleY", mixScaleX2);
          const mixShearY2 = getValue(nextMap, "mixShearY", 1);
          const curve = keyMap.curve;
          if (curve) {
            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);
            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);
          }
          time = time2;
          mixRotate = mixRotate2;
          mixX = mixX2;
          mixY = mixY2;
          mixScaleX = mixScaleX2;
          mixScaleY = mixScaleY2;
          mixScaleX = mixScaleX2;
          keyMap = nextMap;
        }
        timelines.push(timeline);
      }
    }
    if (map.path) {
      for (const constraintName in map.path) {
        const constraintMap = map.path[constraintName];
        const constraint = skeletonData.findPathConstraint(constraintName);
        if (!constraint)
          throw new Error(`Path constraint not found: ${constraintName}`);
        const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);
        for (const timelineName in constraintMap) {
          const timelineMap = constraintMap[timelineName];
          let keyMap = timelineMap[0];
          if (!keyMap)
            continue;
          const frames = timelineMap.length;
          if (timelineName === "position") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.PathConstraintPositionTimeline(frames, frames, constraintIndex);
            timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.PositionMode.Fixed ? scale : 1));
          } else if (timelineName === "spacing") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.PathConstraintSpacingTimeline(frames, frames, constraintIndex);
            timelines.push(
              readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Length || constraint.spacingMode == _PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_7__.SpacingMode.Fixed ? scale : 1)
            );
          } else if (timelineName === "mix") {
            const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.PathConstraintMixTimeline(frames, frames * 3, constraintIndex);
            let time = getValue(keyMap, "time", 0);
            let mixRotate = getValue(keyMap, "mixRotate", 1);
            let mixX = getValue(keyMap, "mixX", 1);
            let mixY = getValue(keyMap, "mixY", mixX);
            for (let frame = 0, bezier = 0; ; frame++) {
              timeline.setFrame(frame, time, mixRotate, mixX, mixY);
              const nextMap = timelineMap[frame + 1];
              if (!nextMap) {
                timeline.shrink(bezier);
                break;
              }
              const time2 = getValue(nextMap, "time", 0);
              const mixRotate2 = getValue(nextMap, "mixRotate", 1);
              const mixX2 = getValue(nextMap, "mixX", 1);
              const mixY2 = getValue(nextMap, "mixY", mixX2);
              const curve = keyMap.curve;
              if (curve) {
                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);
                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);
              }
              time = time2;
              mixRotate = mixRotate2;
              mixX = mixX2;
              mixY = mixY2;
              keyMap = nextMap;
            }
            timelines.push(timeline);
          }
        }
      }
    }
    if (map.deform) {
      map.attachments = {};
      for (const deformName in map.deform) {
        const deformMap = map.deform[deformName];
        const outMap = map.attachments[deformName] = {};
        for (const slotName in deformMap) {
          const slotMap = deformMap[slotName];
          const outMap2 = outMap[slotName] = {};
          for (const innerMapName in slotMap) {
            outMap2[innerMapName] = {
              deform: slotMap[innerMapName]
            };
          }
        }
      }
    }
    if (map.attachments) {
      for (const attachmentsName in map.attachments) {
        const attachmentsMap = map.attachments[attachmentsName];
        const skin = skeletonData.findSkin(attachmentsName);
        if (skin == null) {
          if (_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.settings.FAIL_ON_NON_EXISTING_SKIN) {
            throw new Error(`Skin not found: ${attachmentsName}`);
          } else {
            continue;
          }
        }
        for (const slotMapName in attachmentsMap) {
          const slotMap = attachmentsMap[slotMapName];
          const slot = skeletonData.findSlot(slotMapName);
          if (!slot)
            throw new Error(`Slot not found: ${slotMapName}`);
          const slotIndex = slot.index;
          for (const attachmentMapName in slotMap) {
            const attachmentMap = slotMap[attachmentMapName];
            const attachment = skin.getAttachment(slotIndex, attachmentMapName);
            for (const timelineMapName in attachmentMap) {
              const timelineMap = attachmentMap[timelineMapName];
              let keyMap = timelineMap[0];
              if (!keyMap)
                continue;
              if (timelineMapName == "deform") {
                const weighted = attachment.bones;
                const vertices = attachment.vertices;
                const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);
                let time = getValue(keyMap, "time", 0);
                for (let frame = 0, bezier = 0; ; frame++) {
                  let deform;
                  const verticesValue = getValue(keyMap, "vertices", null);
                  if (!verticesValue)
                    deform = weighted ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength) : vertices;
                  else {
                    deform = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newFloatArray(deformLength);
                    const start = getValue(keyMap, "offset", 0);
                    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                    if (scale != 1) {
                      for (let i = start, n = i + verticesValue.length; i < n; i++)
                        deform[i] *= scale;
                    }
                    if (!weighted) {
                      for (let i = 0; i < deformLength; i++)
                        deform[i] += vertices[i];
                    }
                  }
                  timeline.setFrame(frame, time, deform);
                  const nextMap = timelineMap[frame + 1];
                  if (!nextMap) {
                    timeline.shrink(bezier);
                    break;
                  }
                  const time2 = getValue(nextMap, "time", 0);
                  const curve = keyMap.curve;
                  if (curve)
                    bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);
                  time = time2;
                  keyMap = nextMap;
                }
                timelines.push(timeline);
              } else if (timelineMapName == "sequence") {
                const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.SequenceTimeline(timelineMap.length, slotIndex, attachment);
                let lastDelay = 0;
                for (let frame = 0; frame < timelineMap.length; frame++) {
                  const delay = getValue(keyMap, "delay", lastDelay);
                  const time = getValue(keyMap, "time", 0);
                  const mode = _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_12__.SequenceMode[getValue(keyMap, "mode", "hold")];
                  const index = getValue(keyMap, "index", 0);
                  timeline.setFrame(frame, time, mode, index, delay);
                  lastDelay = delay;
                  keyMap = timelineMap[frame + 1];
                }
                timelines.push(timeline);
              }
            }
          }
        }
      }
    }
    if (map.drawOrder) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.DrawOrderTimeline(map.drawOrder.length);
      const slotCount = skeletonData.slots.length;
      let frame = 0;
      for (let i = 0; i < map.drawOrder.length; i++, frame++) {
        const drawOrderMap = map.drawOrder[i];
        let drawOrder = null;
        const offsets = getValue(drawOrderMap, "offsets", null);
        if (offsets) {
          drawOrder = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount, -1);
          const unchanged = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.newArray(slotCount - offsets.length, 0);
          let originalIndex = 0;
          let unchangedIndex = 0;
          for (let ii = 0; ii < offsets.length; ii++) {
            const offsetMap = offsets[ii];
            const slot = skeletonData.findSlot(offsetMap.slot);
            if (!slot)
              throw new Error(`Slot not found: ${slot}`);
            const slotIndex = slot.index;
            while (originalIndex != slotIndex)
              unchanged[unchangedIndex++] = originalIndex++;
            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
          }
          while (originalIndex < slotCount)
            unchanged[unchangedIndex++] = originalIndex++;
          for (let ii = slotCount - 1; ii >= 0; ii--)
            if (drawOrder[ii] == -1)
              drawOrder[ii] = unchanged[--unchangedIndex];
        }
        timeline.setFrame(frame, getValue(drawOrderMap, "time", 0), drawOrder);
      }
      timelines.push(timeline);
    }
    if (map.events) {
      const timeline = new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.EventTimeline(map.events.length);
      let frame = 0;
      for (let i = 0; i < map.events.length; i++, frame++) {
        const eventMap = map.events[i];
        const eventData = skeletonData.findEvent(eventMap.name);
        if (!eventData)
          throw new Error(`Event not found: ${eventMap.name}`);
        const event = new _Event_mjs__WEBPACK_IMPORTED_MODULE_1__.Event(_pixi_spine_base__WEBPACK_IMPORTED_MODULE_10__.Utils.toSinglePrecision(getValue(eventMap, "time", 0)), eventData);
        event.intValue = getValue(eventMap, "int", eventData.intValue);
        event.floatValue = getValue(eventMap, "float", eventData.floatValue);
        event.stringValue = getValue(eventMap, "string", eventData.stringValue);
        if (event.data.audioPath) {
          event.volume = getValue(eventMap, "volume", 1);
          event.balance = getValue(eventMap, "balance", 0);
        }
        timeline.setFrame(frame, event);
      }
      timelines.push(timeline);
    }
    let duration = 0;
    for (let i = 0, n = timelines.length; i < n; i++)
      duration = Math.max(duration, timelines[i].getDuration());
    if (isNaN(duration)) {
      throw new Error("Error while parsing animation, duration is NaN");
    }
    skeletonData.animations.push(new _Animation_mjs__WEBPACK_IMPORTED_MODULE_0__.Animation(name, timelines, duration));
  }
  static blendModeFromString(str) {
    str = str.toLowerCase();
    if (str == "normal")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.NORMAL;
    if (str == "additive")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.ADD;
    if (str == "multiply")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.MULTIPLY;
    if (str == "screen")
      return _pixi_core__WEBPACK_IMPORTED_MODULE_11__.BLEND_MODES.SCREEN;
    throw new Error(`Unknown blend mode: ${str}`);
  }
}
class LinkedMesh {
  constructor(mesh, skin, slotIndex, parent, inheritDeform) {
    this.mesh = mesh;
    this.skin = skin;
    this.slotIndex = slotIndex;
    this.parent = parent;
    this.inheritTimeline = inheritDeform;
  }
}
function readTimeline1(keys, timeline, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value = getValue(keyMap, "value", defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const value2 = getValue(nextMap, "value", defaultValue) * scale;
    if (keyMap.curve)
      bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);
    time = time2;
    value = value2;
    keyMap = nextMap;
  }
}
function readTimeline2(keys, timeline, name1, name2, defaultValue, scale) {
  let keyMap = keys[0];
  let time = getValue(keyMap, "time", 0);
  let value1 = getValue(keyMap, name1, defaultValue) * scale;
  let value2 = getValue(keyMap, name2, defaultValue) * scale;
  let bezier = 0;
  for (let frame = 0; ; frame++) {
    timeline.setFrame(frame, time, value1, value2);
    const nextMap = keys[frame + 1];
    if (!nextMap) {
      timeline.shrink(bezier);
      return timeline;
    }
    const time2 = getValue(nextMap, "time", 0);
    const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;
    const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;
    const curve = keyMap.curve;
    if (curve) {
      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);
      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);
    }
    time = time2;
    value1 = nvalue1;
    value2 = nvalue2;
    keyMap = nextMap;
  }
}
function readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
  if (curve == "stepped") {
    timeline.setStepped(frame);
    return bezier;
  }
  const i = value << 2;
  const cx1 = curve[i];
  const cy1 = curve[i + 1] * scale;
  const cx2 = curve[i + 2];
  const cy2 = curve[i + 3] * scale;
  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
  return bezier + 1;
}
function getValue(map, property, defaultValue) {
  return map[property] !== void 0 ? map[property] : defaultValue;
}


//# sourceMappingURL=SkeletonJson.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Skin.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/Skin.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Skin": function() { return /* binding */ Skin; },
/* harmony export */   "SkinEntry": function() { return /* binding */ SkinEntry; }
/* harmony export */ });
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");






class SkinEntry {
  constructor(slotIndex, name, attachment) {
    this.slotIndex = slotIndex;
    this.name = name;
    this.attachment = attachment;
  }
}
class Skin {
  constructor(name) {
    this.attachments = new Array();
    this.bones = Array();
    this.constraints = new Array();
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
  /** Adds an attachment to the skin for the specified slot index and name. */
  setAttachment(slotIndex, name, attachment) {
    if (!attachment)
      throw new Error("attachment cannot be null.");
    const attachments = this.attachments;
    if (slotIndex >= attachments.length)
      attachments.length = slotIndex + 1;
    if (!attachments[slotIndex])
      attachments[slotIndex] = {};
    attachments[slotIndex][name] = attachment;
  }
  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */
  addSkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
    }
  }
  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not
   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */
  copySkin(skin) {
    for (let i = 0; i < skin.bones.length; i++) {
      const bone = skin.bones[i];
      let contained = false;
      for (let ii = 0; ii < this.bones.length; ii++) {
        if (this.bones[ii] == bone) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.bones.push(bone);
    }
    for (let i = 0; i < skin.constraints.length; i++) {
      const constraint = skin.constraints[i];
      let contained = false;
      for (let ii = 0; ii < this.constraints.length; ii++) {
        if (this.constraints[ii] == constraint) {
          contained = true;
          break;
        }
      }
      if (!contained)
        this.constraints.push(constraint);
    }
    const attachments = skin.getAttachments();
    for (let i = 0; i < attachments.length; i++) {
      const attachment = attachments[i];
      if (!attachment.attachment)
        continue;
      if (attachment.attachment instanceof _attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.MeshAttachment) {
        attachment.attachment = attachment.attachment.newLinkedMesh();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      } else {
        attachment.attachment = attachment.attachment.copy();
        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
      }
    }
  }
  /** Returns the attachment for the specified slot index and name, or null. */
  getAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    return dictionary ? dictionary[name] : null;
  }
  /** Removes the attachment in the skin for the specified slot index and name, if any. */
  removeAttachment(slotIndex, name) {
    const dictionary = this.attachments[slotIndex];
    if (dictionary)
      delete dictionary[name];
  }
  /** Returns all attachments in this skin. */
  getAttachments() {
    const entries = new Array();
    for (let i = 0; i < this.attachments.length; i++) {
      const slotAttachments = this.attachments[i];
      if (slotAttachments) {
        for (const name in slotAttachments) {
          const attachment = slotAttachments[name];
          if (attachment)
            entries.push(new SkinEntry(i, name, attachment));
        }
      }
    }
    return entries;
  }
  /** Returns all attachments in this skin for the specified slot index. */
  getAttachmentsForSlot(slotIndex, attachments) {
    const slotAttachments = this.attachments[slotIndex];
    if (slotAttachments) {
      for (const name in slotAttachments) {
        const attachment = slotAttachments[name];
        if (attachment)
          attachments.push(new SkinEntry(slotIndex, name, attachment));
      }
    }
  }
  /** Clears all attachments, bones, and constraints. */
  clear() {
    this.attachments.length = 0;
    this.bones.length = 0;
    this.constraints.length = 0;
  }
  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */
  attachAll(skeleton, oldSkin) {
    let slotIndex = 0;
    for (let i = 0; i < skeleton.slots.length; i++) {
      const slot = skeleton.slots[i];
      const slotAttachment = slot.getAttachment();
      if (slotAttachment && slotIndex < oldSkin.attachments.length) {
        const dictionary = oldSkin.attachments[slotIndex];
        for (const key in dictionary) {
          const skinAttachment = dictionary[key];
          if (slotAttachment == skinAttachment) {
            const attachment = this.getAttachment(slotIndex, key);
            if (attachment)
              slot.setAttachment(attachment);
            break;
          }
        }
      }
      slotIndex++;
    }
  }
}


//# sourceMappingURL=Skin.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Slot.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/Slot.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Slot": function() { return /* binding */ Slot; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");



class Slot {
  constructor(data, bone) {
    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
     * color's alpha is not used. */
    this.darkColor = null;
    this.attachment = null;
    this.attachmentState = 0;
    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the
     * {@link Sequence#getSetupIndex()}. */
    this.sequenceIndex = -1;
    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a
     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.
     *
     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */
    this.deform = new Array();
    if (!data)
      throw new Error("data cannot be null.");
    if (!bone)
      throw new Error("bone cannot be null.");
    this.data = data;
    this.bone = bone;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    this.darkColor = !data.darkColor ? null : new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color();
    this.setToSetupPose();
    this.blendMode = this.data.blendMode;
  }
  /** The skeleton this slot belongs to. */
  getSkeleton() {
    return this.bone.skeleton;
  }
  /** The current attachment for the slot, or null if the slot has no attachment. */
  getAttachment() {
    return this.attachment;
  }
  /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.
   * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the
   * specified attachment. */
  setAttachment(attachment) {
    if (this.attachment == attachment)
      return;
    if (!(attachment instanceof _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_1__.VertexAttachment) || !(this.attachment instanceof _attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_1__.VertexAttachment) || attachment.timelineAttachment != this.attachment.timelineAttachment) {
      this.deform.length = 0;
    }
    this.attachment = attachment;
    this.sequenceIndex = -1;
  }
  /** Sets this slot to the setup pose. */
  setToSetupPose() {
    this.color.setFromColor(this.data.color);
    if (this.darkColor)
      this.darkColor.setFromColor(this.data.darkColor);
    if (!this.data.attachmentName)
      this.attachment = null;
    else {
      this.attachment = null;
      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
    }
  }
}


//# sourceMappingURL=Slot.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SlotData.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/SlotData.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SlotData": function() { return /* binding */ SlotData; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");



class SlotData {
  constructor(index, name, boneData) {
    /** The index of the slot in {@link Skeleton#getSlots()}. */
    this.index = 0;
    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two
     * color tinting. */
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark
     * color's alpha is not used. */
    this.darkColor = null;
    /** The name of the attachment that is visible for this slot in the setup pose, or null if no attachment is visible. */
    this.attachmentName = null;
    /** The blend mode for drawing the slot's attachment. */
    this.blendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.NORMAL;
    if (index < 0)
      throw new Error("index must be >= 0.");
    if (!name)
      throw new Error("name cannot be null.");
    if (!boneData)
      throw new Error("boneData cannot be null.");
    this.index = index;
    this.name = name;
    this.boneData = boneData;
  }
}


//# sourceMappingURL=SlotData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraint.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraint.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformConstraint": function() { return /* binding */ TransformConstraint; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class TransformConstraint {
  constructor(data, skeleton) {
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    this.temp = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Vector2();
    this.active = false;
    if (!data)
      throw new Error("data cannot be null.");
    if (!skeleton)
      throw new Error("skeleton cannot be null.");
    this.data = data;
    this.mixRotate = data.mixRotate;
    this.mixX = data.mixX;
    this.mixY = data.mixY;
    this.mixScaleX = data.mixScaleX;
    this.mixScaleY = data.mixScaleY;
    this.mixShearY = data.mixShearY;
    this.bones = new Array();
    for (let i = 0; i < data.bones.length; i++) {
      const bone = skeleton.findBone(data.bones[i].name);
      if (!bone)
        throw new Error(`Couldn't find bone ${data.bones[i].name}.`);
      this.bones.push(bone);
    }
    const target = skeleton.findBone(data.target.name);
    if (!target)
      throw new Error(`Couldn't find target bone ${data.target.name}.`);
    this.target = target;
  }
  isActive() {
    return this.active;
  }
  update() {
    if (this.mixRotate == 0 && this.mixX == 0 && this.mixY == 0 && this.mixScaleX == 0 && this.mixScaleX == 0 && this.mixShearY == 0)
      return;
    if (this.data.local) {
      if (this.data.relative)
        this.applyRelativeLocal();
      else
        this.applyAbsoluteLocal();
    } else if (this.data.relative)
      this.applyRelativeWorld();
    else
      this.applyAbsoluteWorld();
  }
  applyAbsoluteWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += (temp.x - mat.tx) * mixX;
        mat.ty += (temp.y - mat.ty) * mixY;
      }
      if (mixScaleX != 0) {
        let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);
        if (s != 0)
          s = (s + (Math.sqrt(ta * ta + tc * tc) - s + this.data.offsetScaleX) * mixScaleX) / s;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        let s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);
        if (s != 0)
          s = (s + (Math.sqrt(tb * tb + td * td) - s + this.data.offsetScaleY) * mixScaleY) / s;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        const b = mat.c;
        const d = mat.d;
        const by = Math.atan2(d, b);
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r = by + (r + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyRelativeWorld() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const translate = mixX != 0 || mixY != 0;
    const target = this.target;
    const targetMat = target.matrix;
    const ta = targetMat.a;
    const tb = targetMat.c;
    const tc = targetMat.b;
    const td = targetMat.d;
    const degRadReflect = ta * td - tb * tc > 0 ? _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad : -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degRad;
    const offsetRotation = this.data.offsetRotation * degRadReflect;
    const offsetShearY = this.data.offsetShearY * degRadReflect;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const mat = bone.matrix;
      if (mixRotate != 0) {
        const a = mat.a;
        const b = mat.c;
        const c = mat.b;
        const d = mat.d;
        let r = Math.atan2(tc, ta) + offsetRotation;
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        r *= mixRotate;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        mat.a = cos * a - sin * c;
        mat.c = cos * b - sin * d;
        mat.b = sin * a + cos * c;
        mat.d = sin * b + cos * d;
      }
      if (translate) {
        const temp = this.temp;
        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
        mat.tx += temp.x * mixX;
        mat.ty += temp.y * mixY;
      }
      if (mixScaleX != 0) {
        const s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * mixScaleX + 1;
        mat.a *= s;
        mat.b *= s;
      }
      if (mixScaleY != 0) {
        const s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * mixScaleY + 1;
        mat.c *= s;
        mat.d *= s;
      }
      if (mixShearY > 0) {
        let r = Math.atan2(td, tb) - Math.atan2(tc, ta);
        if (r > _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r -= _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        else if (r < -_pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI)
          r += _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI2;
        const b = mat.c;
        const d = mat.d;
        r = Math.atan2(d, b) + (r - _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.MathUtils.PI / 2 + offsetShearY) * mixShearY;
        const s = Math.sqrt(b * b + d * d);
        mat.c = Math.cos(r) * s;
        mat.d = Math.sin(r) * s;
      }
      bone.updateAppliedTransform();
    }
  }
  applyAbsoluteLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      let rotation = bone.arotation;
      if (mixRotate != 0) {
        let r = target.arotation - rotation + this.data.offsetRotation;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        rotation += r * mixRotate;
      }
      let x = bone.ax;
      let y = bone.ay;
      x += (target.ax - x + this.data.offsetX) * mixX;
      y += (target.ay - y + this.data.offsetY) * mixY;
      let scaleX = bone.ascaleX;
      let scaleY = bone.ascaleY;
      if (mixScaleX != 0 && scaleX != 0)
        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
      if (mixScaleY != 0 && scaleY != 0)
        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
      let shearY = bone.ashearY;
      if (mixShearY != 0) {
        let r = target.ashearY - shearY + this.data.offsetShearY;
        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
        shearY += r * mixShearY;
      }
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
  applyRelativeLocal() {
    const mixRotate = this.mixRotate;
    const mixX = this.mixX;
    const mixY = this.mixY;
    const mixScaleX = this.mixScaleX;
    const mixScaleY = this.mixScaleY;
    const mixShearY = this.mixShearY;
    const target = this.target;
    const bones = this.bones;
    for (let i = 0, n = bones.length; i < n; i++) {
      const bone = bones[i];
      const rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
      const x = bone.ax + (target.ax + this.data.offsetX) * mixX;
      const y = bone.ay + (target.ay + this.data.offsetY) * mixY;
      const scaleX = bone.ascaleX * ((target.ascaleX - 1 + this.data.offsetScaleX) * mixScaleX + 1);
      const scaleY = bone.ascaleY * ((target.ascaleY - 1 + this.data.offsetScaleY) * mixScaleY + 1);
      const shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
      bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
    }
  }
}


//# sourceMappingURL=TransformConstraint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraintData.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraintData.mjs ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformConstraintData": function() { return /* binding */ TransformConstraintData; }
/* harmony export */ });
/* harmony import */ var _ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs");


class TransformConstraintData extends _ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_0__.ConstraintData {
  constructor(name) {
    super(name, 0, false);
    /** The bones that will be modified by this transform constraint. */
    this.bones = new Array();
    /** The target bone whose world transform will be copied to the constrained bones. */
    this._target = null;
    this.mixRotate = 0;
    this.mixX = 0;
    this.mixY = 0;
    this.mixScaleX = 0;
    this.mixScaleY = 0;
    this.mixShearY = 0;
    /** An offset added to the constrained bone rotation. */
    this.offsetRotation = 0;
    /** An offset added to the constrained bone X translation. */
    this.offsetX = 0;
    /** An offset added to the constrained bone Y translation. */
    this.offsetY = 0;
    /** An offset added to the constrained bone scaleX. */
    this.offsetScaleX = 0;
    /** An offset added to the constrained bone scaleY. */
    this.offsetScaleY = 0;
    /** An offset added to the constrained bone shearY. */
    this.offsetShearY = 0;
    this.relative = false;
    this.local = false;
  }
  set target(boneData) {
    this._target = boneData;
  }
  get target() {
    if (!this._target)
      throw new Error("BoneData not set.");
    else
      return this._target;
  }
}


//# sourceMappingURL=TransformConstraintData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attachment": function() { return /* binding */ Attachment; },
/* harmony export */   "VertexAttachment": function() { return /* binding */ VertexAttachment; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


class Attachment {
  constructor(name) {
    if (!name)
      throw new Error("name cannot be null.");
    this.name = name;
  }
}
const _VertexAttachment = class extends Attachment {
  constructor(name) {
    super(name);
    /** The unique ID for this attachment. */
    this.id = _VertexAttachment.nextID++;
    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting
     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null
     * if this attachment has no weights. */
    this.bones = null;
    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`
     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting
     * each vertex. */
    this.vertices = [];
    /** The maximum number of world vertex values that can be output by
     * {@link #computeWorldVertices()} using the `count` parameter. */
    this.worldVerticesLength = 0;
    /** Timelines for the timeline attachment are also applied to this attachment.
     * May be null if no attachment-specific timelines should be applied. */
    this.timelineAttachment = this;
  }
  computeWorldVerticesOld(slot, worldVertices) {
    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);
  }
  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is
   * not empty, it is used to deform the vertices.
   *
   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine
   * Runtimes Guide.
   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.
   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.
   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *
   *           `stride` / 2.
   * @param offset The `worldVertices` index to begin writing values.
   * @param stride The number of `worldVertices` entries between the value pairs written. */
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    count = offset + (count >> 1) * stride;
    const skeleton = slot.bone.skeleton;
    const deformArray = slot.deform;
    let vertices = this.vertices;
    const bones = this.bones;
    if (!bones) {
      if (deformArray.length > 0)
        vertices = deformArray;
      const mat = slot.bone.matrix;
      const x = mat.tx;
      const y = mat.ty;
      const a = mat.a;
      const b = mat.c;
      const c = mat.b;
      const d = mat.d;
      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {
        const vx = vertices[v2];
        const vy = vertices[v2 + 1];
        worldVertices[w] = vx * a + vy * b + x;
        worldVertices[w + 1] = vx * c + vy * d + y;
      }
      return;
    }
    let v = 0;
    let skip = 0;
    for (let i = 0; i < start; i += 2) {
      const n = bones[v];
      v += n + 1;
      skip += n;
    }
    const skeletonBones = skeleton.bones;
    if (deformArray.length == 0) {
      for (let w = offset, b = skip * 3; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b];
          const vy = vertices[b + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    } else {
      const deform = deformArray;
      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
        let wx = 0;
        let wy = 0;
        let n = bones[v++];
        n += v;
        for (; v < n; v++, b += 3, f += 2) {
          const mat = skeletonBones[bones[v]].matrix;
          const vx = vertices[b] + deform[f];
          const vy = vertices[b + 1] + deform[f + 1];
          const weight = vertices[b + 2];
          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;
          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;
        }
        worldVertices[w] = wx;
        worldVertices[w + 1] = wy;
      }
    }
  }
  /** Does not copy id (generated) or name (set on construction). **/
  copyTo(attachment) {
    if (this.bones) {
      attachment.bones = new Array(this.bones.length);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
    } else
      attachment.bones = null;
    if (this.vertices) {
      attachment.vertices = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.newFloatArray(this.vertices.length);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
    }
    attachment.worldVerticesLength = this.worldVerticesLength;
    attachment.timelineAttachment = this.timelineAttachment;
  }
};
let VertexAttachment = _VertexAttachment;
VertexAttachment.nextID = 0;


//# sourceMappingURL=Attachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/BoundingBoxAttachment.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/BoundingBoxAttachment.mjs ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoundingBoxAttachment": function() { return /* binding */ BoundingBoxAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class BoundingBoxAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.BoundingBox;
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new BoundingBoxAttachment(this.name);
    this.copyTo(copy);
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=BoundingBoxAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/ClippingAttachment.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/ClippingAttachment.mjs ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClippingAttachment": function() { return /* binding */ ClippingAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class ClippingAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  // ce3a3aff
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Clipping;
    /** Clipping is performed between the clipping polygon's slot and the end slot. Returns null if clipping is done until the end of
     * the skeleton's rendering. */
    this.endSlot = null;
    // Nonessential.
    /** The color of the clipping polygon as it was in Spine. Available only when nonessential data was exported. Clipping polygons
     * are not usually rendered at runtime. */
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0.2275, 0.2275, 0.8078, 1);
  }
  copy() {
    const copy = new ClippingAttachment(this.name);
    this.copyTo(copy);
    copy.endSlot = this.endSlot;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=ClippingAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshAttachment": function() { return /* binding */ MeshAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class MeshAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name, path) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Mesh;
    this.region = null;
    /** Triplets of vertex indices which describe the mesh's triangulation. */
    this.triangles = [];
    /** The color to tint the mesh. */
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    /** The width of the mesh's image. Available only when nonessential data was exported. */
    this.width = 0;
    /** The height of the mesh's image. Available only when nonessential data was exported. */
    this.height = 0;
    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */
    this.hullLength = 0;
    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if
     * nonessential data was exported. Triangulation is not performed at runtime. */
    this.edges = [];
    this.parentMesh = null;
    this.sequence = null;
    this.tempColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0, 0, 0, 0);
    this.path = path;
  }
  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},
   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the
   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */
  getParentMesh() {
    return this.parentMesh;
  }
  /** @param parentMesh May be null. */
  setParentMesh(parentMesh) {
    this.parentMesh = parentMesh;
    if (parentMesh) {
      this.bones = parentMesh.bones;
      this.vertices = parentMesh.vertices;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
      this.regionUVs = parentMesh.regionUVs;
      this.triangles = parentMesh.triangles;
      this.hullLength = parentMesh.hullLength;
      this.worldVerticesLength = parentMesh.worldVerticesLength;
    }
  }
  copy() {
    if (this.parentMesh)
      return this.newLinkedMesh();
    const copy = new MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    this.copyTo(copy);
    copy.regionUVs = new Float32Array(this.regionUVs.length);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
    copy.triangles = new Array(this.triangles.length);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
    copy.hullLength = this.hullLength;
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    if (this.edges) {
      copy.edges = new Array(this.edges.length);
      _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
    }
    copy.width = this.width;
    copy.height = this.height;
    return copy;
  }
  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);
  }
  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/
  newLinkedMesh() {
    const copy = new MeshAttachment(this.name, this.path);
    copy.region = this.region;
    copy.color.setFromColor(this.color);
    copy.timelineAttachment = this.timelineAttachment;
    copy.setParentMesh(this.parentMesh ? this.parentMesh : this);
    return copy;
  }
}


//# sourceMappingURL=MeshAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathAttachment": function() { return /* binding */ PathAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class PathAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Path;
    /** The lengths along the path in the setup pose from the start of the path to the end of each Bezier curve. */
    this.lengths = [];
    /** If true, the start and end knots are connected. */
    this.closed = false;
    /** If true, additional calculations are performed to make calculating positions along the path more accurate. If false, fewer
     * calculations are performed but calculating positions along the path is less accurate. */
    this.constantSpeed = false;
    /** The color of the path as it was in Spine. Available only when nonessential data was exported. Paths are not usually
     * rendered at runtime. */
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
  }
  copy() {
    const copy = new PathAttachment(this.name);
    this.copyTo(copy);
    copy.lengths = new Array(this.lengths.length);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
    copy.closed = closed;
    copy.constantSpeed = this.constantSpeed;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=PathAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PointAttachment.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PointAttachment.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointAttachment": function() { return /* binding */ PointAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



class PointAttachment extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment {
  constructor(name) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Point;
    this.x = 0;
    this.y = 0;
    this.rotation = 0;
    /** The color of the point attachment as it was in Spine. Available only when nonessential data was exported. Point attachments
     * are not usually rendered at runtime. */
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(0.38, 0.94, 0, 1);
  }
  computeWorldPosition(bone, point) {
    const mat = bone.matrix;
    point.x = this.x * mat.a + this.y * mat.c + bone.worldX;
    point.y = this.x * mat.b + this.y * mat.d + bone.worldY;
    return point;
  }
  computeWorldRotation(bone) {
    const mat = bone.matrix;
    const cos = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.cosDeg(this.rotation);
    const sin = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.sinDeg(this.rotation);
    const x = cos * mat.a + sin * mat.c;
    const y = cos * mat.b + sin * mat.d;
    return Math.atan2(y, x) * _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radDeg;
  }
  copy() {
    const copy = new PointAttachment(this.name);
    copy.x = this.x;
    copy.y = this.y;
    copy.rotation = this.rotation;
    copy.color.setFromColor(this.color);
    return copy;
  }
}


//# sourceMappingURL=PointAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RegionAttachment": function() { return /* binding */ RegionAttachment; }
/* harmony export */ });
/* harmony import */ var _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");



const _RegionAttachment = class extends _Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.Attachment {
  constructor(name, path) {
    super(name);
    this.type = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType.Region;
    /** The local x translation. */
    this.x = 0;
    /** The local y translation. */
    this.y = 0;
    /** The local scaleX. */
    this.scaleX = 1;
    /** The local scaleY. */
    this.scaleY = 1;
    /** The local rotation. */
    this.rotation = 0;
    /** The width of the region attachment in Spine. */
    this.width = 0;
    /** The height of the region attachment in Spine. */
    this.height = 0;
    /** The color to tint the region attachment. */
    this.color = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.rendererObject = null;
    this.region = null;
    this.sequence = null;
    /** For each of the 4 vertices, a pair of <code>x,y</code> values that is the local position of the vertex.
     *
     * See {@link #updateOffset()}. */
    this.offset = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(8);
    this.uvs = _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.newFloatArray(8);
    this.tempColor = new _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1, 1);
    this.path = path;
  }
  /** Calculates the {@link #offset} using the region settings. Must be called after changing region settings. */
  updateRegion() {
    if (!this.region)
      throw new Error("Region not set.");
    const region = this.region;
    const regionScaleX = this.width / this.region.originalWidth * this.scaleX;
    const regionScaleY = this.height / this.region.originalHeight * this.scaleY;
    const localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
    const localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
    const localX2 = localX + this.region.width * regionScaleX;
    const localY2 = localY + this.region.height * regionScaleY;
    const radians = this.rotation * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const x = this.x;
    const y = this.y;
    const localXCos = localX * cos + x;
    const localXSin = localX * sin;
    const localYCos = localY * cos + y;
    const localYSin = localY * sin;
    const localX2Cos = localX2 * cos + x;
    const localX2Sin = localX2 * sin;
    const localY2Cos = localY2 * cos + y;
    const localY2Sin = localY2 * sin;
    const offset = this.offset;
    offset[0] = localXCos - localYSin;
    offset[1] = localYCos + localXSin;
    offset[2] = localXCos - localY2Sin;
    offset[3] = localY2Cos + localXSin;
    offset[4] = localX2Cos - localY2Sin;
    offset[5] = localY2Cos + localX2Sin;
    offset[6] = localX2Cos - localYSin;
    offset[7] = localYCos + localX2Sin;
    const uvs = this.uvs;
    if (region.degrees == 90) {
      uvs[2] = region.u;
      uvs[3] = region.v2;
      uvs[4] = region.u;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v;
      uvs[0] = region.u2;
      uvs[1] = region.v2;
    } else {
      uvs[0] = region.u;
      uvs[1] = region.v2;
      uvs[2] = region.u;
      uvs[3] = region.v;
      uvs[4] = region.u2;
      uvs[5] = region.v;
      uvs[6] = region.u2;
      uvs[7] = region.v2;
    }
  }
  /** Transforms the attachment's four vertices to world coordinates. If the attachment has a {@link #sequence}, the region may
   * be changed.
   * <p>
   * See <a href="http://esotericsoftware.com/spine-runtime-skeletons#World-transforms">World transforms</a> in the Spine
   * Runtimes Guide.
   * @param worldVertices The output world vertices. Must have a length >= <code>offset</code> + 8.
   * @param offset The <code>worldVertices</code> index to begin writing values.
   * @param stride The number of <code>worldVertices</code> entries between the value pairs written. */
  computeWorldVertices(slot, worldVertices, offset, stride) {
    if (this.sequence != null)
      this.sequence.apply(slot, this);
    const bone = slot.bone;
    const vertexOffset = this.offset;
    const mat = bone.matrix;
    const x = mat.tx;
    const y = mat.ty;
    const a = mat.a;
    const b = mat.c;
    const c = mat.b;
    const d = mat.d;
    let offsetX = 0;
    let offsetY = 0;
    offsetX = vertexOffset[0];
    offsetY = vertexOffset[1];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[2];
    offsetY = vertexOffset[3];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[4];
    offsetY = vertexOffset[5];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
    offset += stride;
    offsetX = vertexOffset[6];
    offsetY = vertexOffset[7];
    worldVertices[offset] = offsetX * a + offsetY * b + x;
    worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
  }
  copy() {
    const copy = new _RegionAttachment(this.name, this.path);
    copy.region = this.region;
    copy.rendererObject = this.rendererObject;
    copy.x = this.x;
    copy.y = this.y;
    copy.scaleX = this.scaleX;
    copy.scaleY = this.scaleY;
    copy.rotation = this.rotation;
    copy.width = this.width;
    copy.height = this.height;
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
    copy.color.setFromColor(this.color);
    copy.sequence = this.sequence != null ? this.sequence.copy() : null;
    return copy;
  }
};
let RegionAttachment = _RegionAttachment;
RegionAttachment.X1 = 0;
RegionAttachment.Y1 = 1;
RegionAttachment.C1R = 2;
RegionAttachment.C1G = 3;
RegionAttachment.C1B = 4;
RegionAttachment.C1A = 5;
RegionAttachment.U1 = 6;
RegionAttachment.V1 = 7;
RegionAttachment.X2 = 8;
RegionAttachment.Y2 = 9;
RegionAttachment.C2R = 10;
RegionAttachment.C2G = 11;
RegionAttachment.C2B = 12;
RegionAttachment.C2A = 13;
RegionAttachment.U2 = 14;
RegionAttachment.V2 = 15;
RegionAttachment.X3 = 16;
RegionAttachment.Y3 = 17;
RegionAttachment.C3R = 18;
RegionAttachment.C3G = 19;
RegionAttachment.C3B = 20;
RegionAttachment.C3A = 21;
RegionAttachment.U3 = 22;
RegionAttachment.V3 = 23;
RegionAttachment.X4 = 24;
RegionAttachment.Y4 = 25;
RegionAttachment.C4R = 26;
RegionAttachment.C4G = 27;
RegionAttachment.C4B = 28;
RegionAttachment.C4A = 29;
RegionAttachment.U4 = 30;
RegionAttachment.V4 = 31;


//# sourceMappingURL=RegionAttachment.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sequence": function() { return /* binding */ Sequence; },
/* harmony export */   "SequenceMode": function() { return /* binding */ SequenceMode; },
/* harmony export */   "SequenceModeValues": function() { return /* binding */ SequenceModeValues; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");


const _Sequence = class {
  constructor(count) {
    this.id = _Sequence.nextID();
    this.start = 0;
    this.digits = 0;
    /** The index of the region to show for the setup pose. */
    this.setupIndex = 0;
    this.regions = new Array(count);
  }
  copy() {
    const copy = new _Sequence(this.regions.length);
    _pixi_spine_base__WEBPACK_IMPORTED_MODULE_0__.Utils.arrayCopy(this.regions, 0, copy.regions, 0, this.regions.length);
    copy.start = this.start;
    copy.digits = this.digits;
    copy.setupIndex = this.setupIndex;
    return copy;
  }
  apply(slot, attachment) {
    let index = slot.sequenceIndex;
    if (index == -1)
      index = this.setupIndex;
    if (index >= this.regions.length)
      index = this.regions.length - 1;
    const region = this.regions[index];
    if (attachment.region != region) {
      attachment.region = region;
    }
  }
  getPath(basePath, index) {
    let result = basePath;
    const frame = (this.start + index).toString();
    for (let i = this.digits - frame.length; i > 0; i--)
      result += "0";
    result += frame;
    return result;
  }
  static nextID() {
    return _Sequence._nextID++;
  }
};
let Sequence = _Sequence;
Sequence._nextID = 0;
var SequenceMode = /* @__PURE__ */ ((SequenceMode2) => {
  SequenceMode2[SequenceMode2["hold"] = 0] = "hold";
  SequenceMode2[SequenceMode2["once"] = 1] = "once";
  SequenceMode2[SequenceMode2["loop"] = 2] = "loop";
  SequenceMode2[SequenceMode2["pingpong"] = 3] = "pingpong";
  SequenceMode2[SequenceMode2["onceReverse"] = 4] = "onceReverse";
  SequenceMode2[SequenceMode2["loopReverse"] = 5] = "loopReverse";
  SequenceMode2[SequenceMode2["pingpongReverse"] = 6] = "pingpongReverse";
  return SequenceMode2;
})(SequenceMode || {});
const SequenceModeValues = [
  0 /* hold */,
  1 /* once */,
  2 /* loop */,
  3 /* pingpong */,
  4 /* onceReverse */,
  5 /* loopReverse */,
  6 /* pingpongReverse */
];


//# sourceMappingURL=Sequence.mjs.map


/***/ }),

/***/ "./node_modules/@pixi-spine/runtime-4.1/lib/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi-spine/runtime-4.1/lib/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlphaTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.AlphaTimeline; },
/* harmony export */   "Animation": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.Animation; },
/* harmony export */   "AnimationState": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_9__.AnimationState; },
/* harmony export */   "AnimationStateAdapter": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_9__.AnimationStateAdapter; },
/* harmony export */   "AnimationStateData": function() { return /* reexport safe */ _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_10__.AnimationStateData; },
/* harmony export */   "AtlasAttachmentLoader": function() { return /* reexport safe */ _core_AtlasAttachmentLoader_mjs__WEBPACK_IMPORTED_MODULE_11__.AtlasAttachmentLoader; },
/* harmony export */   "Attachment": function() { return /* reexport safe */ _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.Attachment; },
/* harmony export */   "AttachmentTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.AttachmentTimeline; },
/* harmony export */   "Bone": function() { return /* reexport safe */ _core_Bone_mjs__WEBPACK_IMPORTED_MODULE_12__.Bone; },
/* harmony export */   "BoneData": function() { return /* reexport safe */ _core_BoneData_mjs__WEBPACK_IMPORTED_MODULE_13__.BoneData; },
/* harmony export */   "BoundingBoxAttachment": function() { return /* reexport safe */ _core_attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__.BoundingBoxAttachment; },
/* harmony export */   "ClippingAttachment": function() { return /* reexport safe */ _core_attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__.ClippingAttachment; },
/* harmony export */   "ConstraintData": function() { return /* reexport safe */ _core_ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_14__.ConstraintData; },
/* harmony export */   "CurveTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.CurveTimeline; },
/* harmony export */   "CurveTimeline1": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.CurveTimeline1; },
/* harmony export */   "CurveTimeline2": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.CurveTimeline2; },
/* harmony export */   "DeformTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.DeformTimeline; },
/* harmony export */   "DrawOrderTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.DrawOrderTimeline; },
/* harmony export */   "Event": function() { return /* reexport safe */ _core_Event_mjs__WEBPACK_IMPORTED_MODULE_15__.Event; },
/* harmony export */   "EventData": function() { return /* reexport safe */ _core_EventData_mjs__WEBPACK_IMPORTED_MODULE_16__.EventData; },
/* harmony export */   "EventQueue": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_9__.EventQueue; },
/* harmony export */   "EventTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.EventTimeline; },
/* harmony export */   "EventType": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_9__.EventType; },
/* harmony export */   "IkConstraint": function() { return /* reexport safe */ _core_IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_17__.IkConstraint; },
/* harmony export */   "IkConstraintData": function() { return /* reexport safe */ _core_IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_18__.IkConstraintData; },
/* harmony export */   "IkConstraintTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.IkConstraintTimeline; },
/* harmony export */   "MeshAttachment": function() { return /* reexport safe */ _core_attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__.MeshAttachment; },
/* harmony export */   "PathAttachment": function() { return /* reexport safe */ _core_attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__.PathAttachment; },
/* harmony export */   "PathConstraint": function() { return /* reexport safe */ _core_PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_19__.PathConstraint; },
/* harmony export */   "PathConstraintData": function() { return /* reexport safe */ _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_20__.PathConstraintData; },
/* harmony export */   "PathConstraintMixTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.PathConstraintMixTimeline; },
/* harmony export */   "PathConstraintPositionTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.PathConstraintPositionTimeline; },
/* harmony export */   "PathConstraintSpacingTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.PathConstraintSpacingTimeline; },
/* harmony export */   "PointAttachment": function() { return /* reexport safe */ _core_attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__.PointAttachment; },
/* harmony export */   "RGB2Timeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.RGB2Timeline; },
/* harmony export */   "RGBA2Timeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.RGBA2Timeline; },
/* harmony export */   "RGBATimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.RGBATimeline; },
/* harmony export */   "RGBTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.RGBTimeline; },
/* harmony export */   "RegionAttachment": function() { return /* reexport safe */ _core_attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__.RegionAttachment; },
/* harmony export */   "RotateTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.RotateTimeline; },
/* harmony export */   "ScaleTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.ScaleTimeline; },
/* harmony export */   "ScaleXTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.ScaleXTimeline; },
/* harmony export */   "ScaleYTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.ScaleYTimeline; },
/* harmony export */   "Sequence": function() { return /* reexport safe */ _core_attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_7__.Sequence; },
/* harmony export */   "SequenceMode": function() { return /* reexport safe */ _core_attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_7__.SequenceMode; },
/* harmony export */   "SequenceModeValues": function() { return /* reexport safe */ _core_attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_7__.SequenceModeValues; },
/* harmony export */   "SequenceTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.SequenceTimeline; },
/* harmony export */   "ShearTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.ShearTimeline; },
/* harmony export */   "ShearXTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.ShearXTimeline; },
/* harmony export */   "ShearYTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.ShearYTimeline; },
/* harmony export */   "Skeleton": function() { return /* reexport safe */ _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_21__.Skeleton; },
/* harmony export */   "SkeletonBinary": function() { return /* reexport safe */ _core_SkeletonBinary_mjs__WEBPACK_IMPORTED_MODULE_22__.SkeletonBinary; },
/* harmony export */   "SkeletonBounds": function() { return /* reexport safe */ _core_SkeletonBounds_mjs__WEBPACK_IMPORTED_MODULE_23__.SkeletonBounds; },
/* harmony export */   "SkeletonData": function() { return /* reexport safe */ _core_SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_24__.SkeletonData; },
/* harmony export */   "SkeletonJson": function() { return /* reexport safe */ _core_SkeletonJson_mjs__WEBPACK_IMPORTED_MODULE_25__.SkeletonJson; },
/* harmony export */   "Skin": function() { return /* reexport safe */ _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_26__.Skin; },
/* harmony export */   "SkinEntry": function() { return /* reexport safe */ _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_26__.SkinEntry; },
/* harmony export */   "Slot": function() { return /* reexport safe */ _core_Slot_mjs__WEBPACK_IMPORTED_MODULE_27__.Slot; },
/* harmony export */   "SlotData": function() { return /* reexport safe */ _core_SlotData_mjs__WEBPACK_IMPORTED_MODULE_28__.SlotData; },
/* harmony export */   "SpacingMode": function() { return /* reexport safe */ _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_20__.SpacingMode; },
/* harmony export */   "Spine": function() { return /* reexport safe */ _Spine_mjs__WEBPACK_IMPORTED_MODULE_31__.Spine; },
/* harmony export */   "Timeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.Timeline; },
/* harmony export */   "TrackEntry": function() { return /* reexport safe */ _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_9__.TrackEntry; },
/* harmony export */   "TransformConstraint": function() { return /* reexport safe */ _core_TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_29__.TransformConstraint; },
/* harmony export */   "TransformConstraintData": function() { return /* reexport safe */ _core_TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_30__.TransformConstraintData; },
/* harmony export */   "TransformConstraintTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.TransformConstraintTimeline; },
/* harmony export */   "TranslateTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.TranslateTimeline; },
/* harmony export */   "TranslateXTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.TranslateXTimeline; },
/* harmony export */   "TranslateYTimeline": function() { return /* reexport safe */ _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__.TranslateYTimeline; },
/* harmony export */   "VertexAttachment": function() { return /* reexport safe */ _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__.VertexAttachment; }
/* harmony export */ });
/* harmony import */ var _core_attachments_Attachment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/attachments/Attachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Attachment.mjs");
/* harmony import */ var _core_attachments_BoundingBoxAttachment_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/attachments/BoundingBoxAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/BoundingBoxAttachment.mjs");
/* harmony import */ var _core_attachments_ClippingAttachment_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/attachments/ClippingAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/ClippingAttachment.mjs");
/* harmony import */ var _core_attachments_MeshAttachment_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/attachments/MeshAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/MeshAttachment.mjs");
/* harmony import */ var _core_attachments_PathAttachment_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/attachments/PathAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PathAttachment.mjs");
/* harmony import */ var _core_attachments_PointAttachment_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/attachments/PointAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/PointAttachment.mjs");
/* harmony import */ var _core_attachments_RegionAttachment_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/attachments/RegionAttachment.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/RegionAttachment.mjs");
/* harmony import */ var _core_attachments_Sequence_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/attachments/Sequence.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/attachments/Sequence.mjs");
/* harmony import */ var _core_Animation_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/Animation.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Animation.mjs");
/* harmony import */ var _core_AnimationState_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/AnimationState.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationState.mjs");
/* harmony import */ var _core_AnimationStateData_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AnimationStateData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AnimationStateData.mjs");
/* harmony import */ var _core_AtlasAttachmentLoader_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/AtlasAttachmentLoader.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/AtlasAttachmentLoader.mjs");
/* harmony import */ var _core_Bone_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/Bone.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Bone.mjs");
/* harmony import */ var _core_BoneData_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/BoneData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/BoneData.mjs");
/* harmony import */ var _core_ConstraintData_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./core/ConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/ConstraintData.mjs");
/* harmony import */ var _core_Event_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./core/Event.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Event.mjs");
/* harmony import */ var _core_EventData_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./core/EventData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/EventData.mjs");
/* harmony import */ var _core_IkConstraint_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./core/IkConstraint.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraint.mjs");
/* harmony import */ var _core_IkConstraintData_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./core/IkConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/IkConstraintData.mjs");
/* harmony import */ var _core_PathConstraint_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./core/PathConstraint.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraint.mjs");
/* harmony import */ var _core_PathConstraintData_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./core/PathConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/PathConstraintData.mjs");
/* harmony import */ var _core_Skeleton_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./core/Skeleton.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Skeleton.mjs");
/* harmony import */ var _core_SkeletonBinary_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./core/SkeletonBinary.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBinary.mjs");
/* harmony import */ var _core_SkeletonBounds_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./core/SkeletonBounds.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonBounds.mjs");
/* harmony import */ var _core_SkeletonData_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./core/SkeletonData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonData.mjs");
/* harmony import */ var _core_SkeletonJson_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./core/SkeletonJson.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SkeletonJson.mjs");
/* harmony import */ var _core_Skin_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./core/Skin.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Skin.mjs");
/* harmony import */ var _core_Slot_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./core/Slot.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/Slot.mjs");
/* harmony import */ var _core_SlotData_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./core/SlotData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/SlotData.mjs");
/* harmony import */ var _core_TransformConstraint_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./core/TransformConstraint.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraint.mjs");
/* harmony import */ var _core_TransformConstraintData_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./core/TransformConstraintData.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/core/TransformConstraintData.mjs");
/* harmony import */ var _Spine_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./Spine.mjs */ "./node_modules/@pixi-spine/runtime-4.1/lib/Spine.mjs");
































//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccessibilityManager": function() { return /* binding */ AccessibilityManager; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _pixi_events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/events */ "./node_modules/@pixi/events/lib/index.mjs");
/* harmony import */ var _accessibleTarget_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./accessibleTarget.mjs */ "./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs");





_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.mixin(_accessibleTarget_mjs__WEBPACK_IMPORTED_MODULE_3__.accessibleTarget);
const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
class AccessibilityManager {
  constructor(renderer) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (_pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.isMobile.tablet || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.isMobile.phone) {
      this.createTouchHook();
    }
    const div = document.createElement("div");
    div.style.width = `${DIV_TOUCH_SIZE}px`;
    div.style.height = `${DIV_TOUCH_SIZE}px`;
    div.style.position = "absolute";
    div.style.top = `${DIV_TOUCH_POS_X}px`;
    div.style.left = `${DIV_TOUCH_POS_Y}px`;
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this.activate();
      this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    this.renderer.view.parentNode?.appendChild(this.div);
  }
  deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    this.div.parentNode?.removeChild(this.div);
  }
  updateAccessibleObjects(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.isInteractive()) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    const children = displayObject.children;
    if (children) {
      for (let i = 0; i < children.length; i++) {
        this.updateAccessibleObjects(children[i]);
      }
    }
  }
  update() {
    const now = performance.now();
    if (_pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.isMobile.android.device && now < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer.lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    }
    const { x, y, width, height } = this.renderer.view.getBoundingClientRect();
    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;
    const sx = width / viewWidth * resolution;
    const sy = height / viewHeight * resolution;
    let div = this.div;
    div.style.left = `${x}px`;
    div.style.top = `${y}px`;
    div.style.width = `${viewWidth}px`;
    div.style.height = `${viewHeight}px`;
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.removeItems(this.children, i, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i--;
      } else {
        div = child._accessibleDiv;
        let hitArea = child.hitArea;
        const wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
          div.style.width = `${hitArea.width * wt.a * sx}px`;
          div.style.height = `${hitArea.height * wt.d * sy}px`;
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = `${hitArea.x * sx}px`;
          div.style.top = `${hitArea.y * sy}px`;
          div.style.width = `${hitArea.width * sx}px`;
          div.style.height = `${hitArea.height * sy}px`;
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug)
            this.updateDebugHTML(div);
        }
      }
    }
    this.renderId++;
  }
  updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this.renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  addChild(displayObject) {
    let div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = `displayObject ${displayObject.tabIndex}`;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug)
      this.updateDebugHTML(div);
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  }
  _dispatchEvent(e, type) {
    const { displayObject: target } = e.target;
    const boundry = this.renderer.events.rootBoundary;
    const event = Object.assign(new _pixi_events__WEBPACK_IMPORTED_MODULE_2__.FederatedEvent(boundry), { target });
    boundry.rootTarget = this.renderer.lastObjectRendered;
    type.forEach((type2) => boundry.dispatchEvent(event, type2));
  }
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  _onFocus(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e, ["mouseover"]);
  }
  _onFocusOut(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e, ["mouseout"]);
  }
  _onKeyDown(e) {
    if (e.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  }
  _onMouseMove(e) {
    if (e.movementX === 0 && e.movementY === 0) {
      return;
    }
    this.deactivate();
  }
  destroy() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  }
}
AccessibilityManager.extension = {
  name: "accessibility",
  type: [
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererPlugin,
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasRendererPlugin
  ]
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(AccessibilityManager);


//# sourceMappingURL=AccessibilityManager.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "accessibleTarget": function() { return /* binding */ accessibleTarget; }
/* harmony export */ });
const accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};


//# sourceMappingURL=accessibleTarget.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/accessibility/lib/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/accessibility/lib/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccessibilityManager": function() { return /* reexport safe */ _AccessibilityManager_mjs__WEBPACK_IMPORTED_MODULE_0__.AccessibilityManager; },
/* harmony export */   "accessibleTarget": function() { return /* reexport safe */ _accessibleTarget_mjs__WEBPACK_IMPORTED_MODULE_1__.accessibleTarget; }
/* harmony export */ });
/* harmony import */ var _AccessibilityManager_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AccessibilityManager.mjs */ "./node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs");
/* harmony import */ var _accessibleTarget_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessibleTarget.mjs */ "./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/app/lib/Application.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/app/lib/Application.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": function() { return /* binding */ Application; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");



const _Application = class {
  constructor(options) {
    this.stage = new _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = (0,_pixi_core__WEBPACK_IMPORTED_MODULE_0__.autoDetectRenderer)(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer.view;
  }
  get screen() {
    return this.renderer.screen;
  }
  destroy(removeView, stageOptions) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  }
};
let Application = _Application;
Application._plugins = [];
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.handleByList(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Application, Application._plugins);


//# sourceMappingURL=Application.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/app/lib/ResizePlugin.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/app/lib/ResizePlugin.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ResizePlugin": function() { return /* binding */ ResizePlugin; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class ResizePlugin {
  static init(options) {
    Object.defineProperty(this, "resizeTo", {
      set(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get() {
        return this._resizeTo;
      }
    });
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this.cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this.cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
ResizePlugin.extension = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Application;
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(ResizePlugin);


//# sourceMappingURL=ResizePlugin.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/app/lib/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/app/lib/index.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Application": function() { return /* reexport safe */ _Application_mjs__WEBPACK_IMPORTED_MODULE_0__.Application; },
/* harmony export */   "ResizePlugin": function() { return /* reexport safe */ _ResizePlugin_mjs__WEBPACK_IMPORTED_MODULE_1__.ResizePlugin; }
/* harmony export */ });
/* harmony import */ var _Application_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Application.mjs */ "./node_modules/@pixi/app/lib/Application.mjs");
/* harmony import */ var _ResizePlugin_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResizePlugin.mjs */ "./node_modules/@pixi/app/lib/ResizePlugin.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/AssetExtension.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/AssetExtension.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const assetKeyMap = {
  loader: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
  resolver: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ResolveParser,
  cache: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CacheParser,
  detection: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.handle(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => _pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => _pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.remove(ref[key]));
});
//# sourceMappingURL=AssetExtension.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/Assets.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/Assets.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Assets": function() { return /* binding */ Assets; },
/* harmony export */   "AssetsClass": function() { return /* binding */ AssetsClass; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _BackgroundLoader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BackgroundLoader.mjs */ "./node_modules/@pixi/assets/lib/BackgroundLoader.mjs");
/* harmony import */ var _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache/Cache.mjs */ "./node_modules/@pixi/assets/lib/cache/Cache.mjs");
/* harmony import */ var _loader_Loader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader/Loader.mjs */ "./node_modules/@pixi/assets/lib/loader/Loader.mjs");
/* harmony import */ var _loader_parsers_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader/parsers/index.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/index.mjs");
/* harmony import */ var _resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolver/Resolver.mjs */ "./node_modules/@pixi/assets/lib/resolver/Resolver.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/convertToList.mjs */ "./node_modules/@pixi/assets/lib/utils/convertToList.mjs");
/* harmony import */ var _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/isSingleItem.mjs */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs");
/* harmony import */ var _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs");










class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new _resolver_Resolver_mjs__WEBPACK_IMPORTED_MODULE_5__.Resolver();
    this.loader = new _loader_Loader_mjs__WEBPACK_IMPORTED_MODULE_3__.Loader();
    this.cache = _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache;
    this._backgroundLoader = new _BackgroundLoader_mjs__WEBPACK_IMPORTED_MODULE_1__.BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  async init(options = {}) {
    if (this._initialized) {
      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = options.texturePreference?.resolution ?? 1;
    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    let formats = [];
    if (options.texturePreference?.format) {
      const formatPref = options.texturePreference?.format;
      formats = typeof formatPref === "string" ? [formatPref] : formatPref;
      for (const detection of this._detections) {
        if (!await detection.test()) {
          formats = await detection.remove(formats);
        }
      }
    } else {
      for (const detection of this._detections) {
        if (await detection.test()) {
          formats = await detection.add(formats);
        }
      }
    }
    this.resolver.prefer({
      params: {
        format: formats,
        resolution
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
  }
  add(keysIn, assetsIn, data) {
    this.resolver.add(keysIn, assetsIn, data);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_7__.isSingleItem)(urls);
    const urlArray = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__.convertToList)(urls).map((url) => {
      if (typeof url !== "string") {
        this.resolver.add(url.src, url);
        return url.src;
      }
      if (!this.resolver.hasKey(url)) {
        this.resolver.add(url, url);
      }
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out[urlArray[0]] : out;
  }
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out = {};
    const keys = Object.keys(resolveResults);
    let count = 0;
    let total = 0;
    const _onProgress = () => {
      onProgress?.(++count / total);
    };
    const promises = keys.map((bundleId) => {
      const resolveResult = resolveResults[bundleId];
      total += Object.keys(resolveResult).length;
      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
        out[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out[bundleIds[0]] : out;
  }
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.get(keys);
    }
    const assets = {};
    for (let i = 0; i < keys.length; i++) {
      assets[i] = _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.get(keys[i]);
    }
    return assets;
  }
  async _mapLoadToResolve(resolveResults, onProgress) {
    const resolveArray = Object.values(resolveResults);
    const resolveKeys = Object.keys(resolveResults);
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, onProgress);
    this._backgroundLoader.active = true;
    const out = {};
    resolveArray.forEach((resolveResult, i) => {
      const asset = loadedAssets[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      out[resolveKeys[i]] = asset;
      _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.set(keys, asset);
    });
    return out;
  }
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__.convertToList)(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_6__.convertToList)(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_2__.Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_8__.loadTextures.config.preferWorkers;
  }
  set preferWorkers(value) {
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
    this.setPreferences({ preferWorkers: value });
  }
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
        parser.config[key] = preferences[key];
      });
    });
  }
}
const Assets = new AssetsClass();
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.handleByList(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser, Assets.detections);


//# sourceMappingURL=Assets.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/BackgroundLoader.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/BackgroundLoader.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundLoader": function() { return /* binding */ BackgroundLoader; }
/* harmony export */ });
class BackgroundLoader {
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  add(assetUrls) {
    assetUrls.forEach((a) => {
      this._assetList.push(a);
    });
    if (this.verbose)
      console.log("[BackgroundLoader] assets: ", this._assetList);
    if (this._isActive && !this._isLoading) {
      this._next();
    }
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < toLoadAmount; i++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      this._next();
    }
  }
  get active() {
    return this._isActive;
  }
  set active(value) {
    if (this._isActive === value)
      return;
    this._isActive = value;
    if (value && !this._isLoading) {
      this._next();
    }
  }
}


//# sourceMappingURL=BackgroundLoader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/Cache.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/Cache.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": function() { return /* binding */ Cache; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.mjs */ "./node_modules/@pixi/assets/lib/utils/index.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/convertToList.mjs */ "./node_modules/@pixi/assets/lib/utils/convertToList.mjs");




class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  has(key) {
    return this._cache.has(key);
  }
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  set(key, value) {
    const keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_2__.convertToList)(key);
    let cacheableAssets;
    for (let i = 0; i < this.parsers.length; i++) {
      const parser = this.parsers[i];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    if (!cacheableAssets) {
      cacheableAssets = {};
      keys.forEach((key2) => {
        cacheableAssets[key2] = value;
      });
    }
    const cacheKeys = Object.keys(cacheableAssets);
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      if (this._cache.has(key2) && this._cache.get(key2) !== value) {
        console.warn("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableAssets[key2]);
    });
    if (value instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture) {
      const texture = value;
      keys.forEach((key2) => {
        if (texture.baseTexture !== _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY.baseTexture) {
          _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture.addToCache(texture.baseTexture, key2);
        }
        _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.addToCache(texture, key2);
      });
    }
  }
  remove(key) {
    this._cacheMap.get(key);
    if (!this._cacheMap.has(key)) {
      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();


//# sourceMappingURL=Cache.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/CacheParser.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/CacheParser.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=CacheParser.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": function() { return /* reexport safe */ _Cache_mjs__WEBPACK_IMPORTED_MODULE_0__.Cache; }
/* harmony export */ });
/* harmony import */ var _Cache_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache.mjs */ "./node_modules/@pixi/assets/lib/cache/Cache.mjs");
/* harmony import */ var _CacheParser_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CacheParser.mjs */ "./node_modules/@pixi/assets/lib/cache/CacheParser.mjs");
/* harmony import */ var _parsers_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parsers/index.mjs */ "./node_modules/@pixi/assets/lib/cache/parsers/index.mjs");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cacheTextureArray": function() { return /* binding */ cacheTextureArray; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const cacheTextureArray = {
  extension: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CacheParser,
  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture),
  getCacheableAssets: (keys, asset) => {
    const out = {};
    keys.forEach((key) => {
      asset.forEach((item, i) => {
        out[key + (i === 0 ? "" : i + 1)] = item;
      });
    });
    return out;
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(cacheTextureArray);


//# sourceMappingURL=cacheTextureArray.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/cache/parsers/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/cache/parsers/index.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cacheTextureArray": function() { return /* reexport safe */ _cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_0__.cacheTextureArray; }
/* harmony export */ });
/* harmony import */ var _cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cacheTextureArray.mjs */ "./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parsers_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers/index.mjs */ "./node_modules/@pixi/assets/lib/detections/parsers/index.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detectAvif": function() { return /* binding */ detectAvif; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const detectAvif = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    const blob = await _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.fetch(avifData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f) => f !== "avif")
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(detectAvif);


//# sourceMappingURL=detectAvif.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detectDefaults": function() { return /* binding */ detectDefaults; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(detectDefaults);


//# sourceMappingURL=detectDefaults.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detectWebp": function() { return /* binding */ detectWebp; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const detectWebp = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => {
    if (!globalThis.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    const blob = await _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.fetch(webpData).then((r) => r.blob());
    return createImageBitmap(blob).then(() => true, () => false);
  },
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f) => f !== "webp")
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(detectWebp);


//# sourceMappingURL=detectWebp.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/detections/parsers/index.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/detections/parsers/index.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detectAvif": function() { return /* reexport safe */ _detectAvif_mjs__WEBPACK_IMPORTED_MODULE_0__.detectAvif; },
/* harmony export */   "detectDefaults": function() { return /* reexport safe */ _detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_2__.detectDefaults; },
/* harmony export */   "detectWebp": function() { return /* reexport safe */ _detectWebp_mjs__WEBPACK_IMPORTED_MODULE_1__.detectWebp; }
/* harmony export */ });
/* harmony import */ var _detectAvif_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./detectAvif.mjs */ "./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs");
/* harmony import */ var _detectWebp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./detectWebp.mjs */ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs");
/* harmony import */ var _detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectDefaults.mjs */ "./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/index.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Assets": function() { return /* reexport safe */ _Assets_mjs__WEBPACK_IMPORTED_MODULE_1__.Assets; },
/* harmony export */   "AssetsClass": function() { return /* reexport safe */ _Assets_mjs__WEBPACK_IMPORTED_MODULE_1__.AssetsClass; },
/* harmony export */   "Cache": function() { return /* reexport safe */ _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_7__.Cache; },
/* harmony export */   "LoaderParserPriority": function() { return /* reexport safe */ _loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_12__.LoaderParserPriority; },
/* harmony export */   "cacheTextureArray": function() { return /* reexport safe */ _cache_parsers_cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_8__.cacheTextureArray; },
/* harmony export */   "checkDataUrl": function() { return /* reexport safe */ _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_20__.checkDataUrl; },
/* harmony export */   "checkExtension": function() { return /* reexport safe */ _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_21__.checkExtension; },
/* harmony export */   "convertToList": function() { return /* reexport safe */ _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_22__.convertToList; },
/* harmony export */   "copySearchParams": function() { return /* reexport safe */ _utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_23__.copySearchParams; },
/* harmony export */   "createStringVariations": function() { return /* reexport safe */ _utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_24__.createStringVariations; },
/* harmony export */   "createTexture": function() { return /* reexport safe */ _loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_18__.createTexture; },
/* harmony export */   "detectAvif": function() { return /* reexport safe */ _detections_parsers_detectAvif_mjs__WEBPACK_IMPORTED_MODULE_9__.detectAvif; },
/* harmony export */   "detectDefaults": function() { return /* reexport safe */ _detections_parsers_detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_11__.detectDefaults; },
/* harmony export */   "detectWebp": function() { return /* reexport safe */ _detections_parsers_detectWebp_mjs__WEBPACK_IMPORTED_MODULE_10__.detectWebp; },
/* harmony export */   "getFontFamilyName": function() { return /* reexport safe */ _loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_15__.getFontFamilyName; },
/* harmony export */   "isSingleItem": function() { return /* reexport safe */ _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_25__.isSingleItem; },
/* harmony export */   "loadImageBitmap": function() { return /* reexport safe */ _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_17__.loadImageBitmap; },
/* harmony export */   "loadJson": function() { return /* reexport safe */ _loader_parsers_loadJson_mjs__WEBPACK_IMPORTED_MODULE_13__.loadJson; },
/* harmony export */   "loadSVG": function() { return /* reexport safe */ _loader_parsers_textures_loadSVG_mjs__WEBPACK_IMPORTED_MODULE_16__.loadSVG; },
/* harmony export */   "loadTextures": function() { return /* reexport safe */ _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_17__.loadTextures; },
/* harmony export */   "loadTxt": function() { return /* reexport safe */ _loader_parsers_loadTxt_mjs__WEBPACK_IMPORTED_MODULE_14__.loadTxt; },
/* harmony export */   "loadWebFont": function() { return /* reexport safe */ _loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_15__.loadWebFont; },
/* harmony export */   "resolveTextureUrl": function() { return /* reexport safe */ _resolver_parsers_resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_19__.resolveTextureUrl; }
/* harmony export */ });
/* harmony import */ var _AssetExtension_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssetExtension.mjs */ "./node_modules/@pixi/assets/lib/AssetExtension.mjs");
/* harmony import */ var _Assets_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Assets.mjs */ "./node_modules/@pixi/assets/lib/Assets.mjs");
/* harmony import */ var _cache_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cache/index.mjs */ "./node_modules/@pixi/assets/lib/cache/index.mjs");
/* harmony import */ var _detections_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./detections/index.mjs */ "./node_modules/@pixi/assets/lib/detections/index.mjs");
/* harmony import */ var _loader_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader/index.mjs */ "./node_modules/@pixi/assets/lib/loader/index.mjs");
/* harmony import */ var _resolver_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolver/index.mjs */ "./node_modules/@pixi/assets/lib/resolver/index.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/assets/lib/utils/index.mjs");
/* harmony import */ var _cache_Cache_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cache/Cache.mjs */ "./node_modules/@pixi/assets/lib/cache/Cache.mjs");
/* harmony import */ var _cache_parsers_cacheTextureArray_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cache/parsers/cacheTextureArray.mjs */ "./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs");
/* harmony import */ var _detections_parsers_detectAvif_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./detections/parsers/detectAvif.mjs */ "./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs");
/* harmony import */ var _detections_parsers_detectWebp_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./detections/parsers/detectWebp.mjs */ "./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs");
/* harmony import */ var _detections_parsers_detectDefaults_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./detections/parsers/detectDefaults.mjs */ "./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs");
/* harmony import */ var _loader_parsers_LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./loader/parsers/LoaderParser.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _loader_parsers_loadJson_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./loader/parsers/loadJson.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs");
/* harmony import */ var _loader_parsers_loadTxt_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./loader/parsers/loadTxt.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs");
/* harmony import */ var _loader_parsers_loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./loader/parsers/loadWebFont.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs");
/* harmony import */ var _loader_parsers_textures_loadSVG_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./loader/parsers/textures/loadSVG.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs");
/* harmony import */ var _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./loader/parsers/textures/loadTextures.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs");
/* harmony import */ var _loader_parsers_textures_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./loader/parsers/textures/utils/createTexture.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs");
/* harmony import */ var _resolver_parsers_resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./resolver/parsers/resolveTextureUrl.mjs */ "./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/checkDataUrl.mjs */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/checkExtension.mjs */ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./utils/convertToList.mjs */ "./node_modules/@pixi/assets/lib/utils/convertToList.mjs");
/* harmony import */ var _utils_copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./utils/copySearchParams.mjs */ "./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs");
/* harmony import */ var _utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./utils/createStringVariations.mjs */ "./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs");
/* harmony import */ var _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./utils/isSingleItem.mjs */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs");


























//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/Loader.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/Loader.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Loader": function() { return /* binding */ Loader; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.mjs */ "./node_modules/@pixi/assets/lib/utils/index.mjs");
/* harmony import */ var _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/isSingleItem.mjs */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/convertToList.mjs */ "./node_modules/@pixi/assets/lib/utils/convertToList.mjs");





class Loader {
  constructor() {
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key, value) => {
        this._parsersValidated = false;
        target[key] = value;
        return true;
      }
    });
    this.promiseCache = {};
  }
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      let asset = null;
      let parser = null;
      if (data.loadParser) {
        parser = this._parserHash[data.loadParser];
        if (!parser) {
          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
        }
      }
      if (!parser) {
        for (let i = 0; i < this.parsers.length; i++) {
          const parserX = this.parsers[i];
          if (parserX.load && parserX.test?.(url, data, this)) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        if (parser2.parse) {
          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgress) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    let count = 0;
    const assets = {};
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_2__.isSingleItem)(assetsToLoadIn);
    const assetsToLoad = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_3__.convertToList)(assetsToLoadIn, (item) => ({
      src: item
    }));
    const total = assetsToLoad.length;
    const promises = assetsToLoad.map(async (asset) => {
      const url = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.toAbsolute(asset.src);
      if (!assets[asset.src]) {
        try {
          if (!this.promiseCache[url]) {
            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
          }
          assets[asset.src] = await this.promiseCache[url].promise;
          if (onProgress)
            onProgress(++count / total);
        } catch (e) {
          delete this.promiseCache[url];
          delete assets[asset.src];
          throw new Error(`[Loader.load] Failed to load ${url}.
${e}`);
        }
      }
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  async unload(assetsToUnloadIn) {
    const assetsToUnload = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_3__.convertToList)(assetsToUnloadIn, (item) => ({
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      const url = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        loadPromise.parser?.unload?.(loadedAsset, asset, this);
        delete this.promiseCache[url];
      }
    });
    await Promise.all(promises);
  }
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
      if (hash[parser.name]) {
        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);
      }
      return { ...hash, [parser.name]: parser };
    }, {});
  }
}


//# sourceMappingURL=Loader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parsers_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers/index.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/index.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/@pixi/assets/lib/loader/types.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoaderParserPriority": function() { return /* binding */ LoaderParserPriority; }
/* harmony export */ });
var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});


//# sourceMappingURL=LoaderParser.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WorkerManager": function() { return /* binding */ WorkerManager; }
/* harmony export */ });
let UUID = 0;
let MAX_WORKERS;
const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
const checkImageBitmapCode = {
  id: "checkImageBitmap",
  code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${WHITE_PNG}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
};
const workerCode = {
  id: "loadImageBitmap",
  code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let workerURL;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this.workerPool = [];
    this.queue = [];
    this.resolveHash = {};
  }
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve) => {
      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));
      const worker = new Worker(workerURL2);
      worker.addEventListener("message", (event) => {
        worker.terminate();
        URL.revokeObjectURL(workerURL2);
        resolve(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  loadImageBitmap(src) {
    return this._run("loadImageBitmap", [src]);
  }
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this.workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      if (!workerURL) {
        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));
      }
      this._createdWorkers++;
      worker = new Worker(workerURL);
      worker.addEventListener("message", (event) => {
        this.complete(event.data);
        this.returnWorker(event.target);
        this.next();
      });
    }
    return worker;
  }
  returnWorker(worker) {
    this.workerPool.push(worker);
  }
  complete(data) {
    if (data.error !== void 0) {
      this.resolveHash[data.uuid].reject(data.error);
    } else {
      this.resolveHash[data.uuid].resolve(data.data);
    }
    this.resolveHash[data.uuid] = null;
  }
  async _run(id, args) {
    await this._initWorkers();
    const promise = new Promise((resolve, reject) => {
      this.queue.push({ id, arguments: args, resolve, reject });
    });
    this.next();
    return promise;
  }
  next() {
    if (!this.queue.length)
      return;
    const worker = this.getWorker();
    if (!worker) {
      return;
    }
    const toDo = this.queue.pop();
    const id = toDo.id;
    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id
    });
  }
}
const WorkerManager = new WorkerManagerClass();


//# sourceMappingURL=WorkerManager.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/index.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoaderParserPriority": function() { return /* reexport safe */ _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_0__.LoaderParserPriority; },
/* harmony export */   "getFontFamilyName": function() { return /* reexport safe */ _loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_3__.getFontFamilyName; },
/* harmony export */   "loadJson": function() { return /* reexport safe */ _loadJson_mjs__WEBPACK_IMPORTED_MODULE_1__.loadJson; },
/* harmony export */   "loadTxt": function() { return /* reexport safe */ _loadTxt_mjs__WEBPACK_IMPORTED_MODULE_2__.loadTxt; },
/* harmony export */   "loadWebFont": function() { return /* reexport safe */ _loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_3__.loadWebFont; }
/* harmony export */ });
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoaderParser.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _loadJson_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadJson.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs");
/* harmony import */ var _loadTxt_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadTxt.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs");
/* harmony import */ var _loadWebFont_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadWebFont.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs");
/* harmony import */ var _textures_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./textures/index.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs");





//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadJson": function() { return /* binding */ loadJson; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/checkDataUrl.mjs */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/checkExtension.mjs */ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LoaderParser.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs");





const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__.LoaderParserPriority.Low
  },
  name: "loadJson",
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__.checkDataUrl)(url, validJSONMIME) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, validJSONExtension);
  },
  async load(url) {
    const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.fetch(url);
    const json = await response.json();
    return json;
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(loadJson);


//# sourceMappingURL=loadJson.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadTxt": function() { return /* binding */ loadTxt; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/checkDataUrl.mjs */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/checkExtension.mjs */ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LoaderParser.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs");





const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  name: "loadTxt",
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__.LoaderParserPriority.Low
  },
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__.checkDataUrl)(url, validTXTMIME) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, validTXTExtension);
  },
  async load(url) {
    const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.fetch(url);
    const txt = await response.text();
    return txt;
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(loadTxt);


//# sourceMappingURL=loadTxt.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getFontFamilyName": function() { return /* binding */ getFontFamilyName; },
/* harmony export */   "loadWebFont": function() { return /* binding */ loadWebFont; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/checkDataUrl.mjs */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/checkExtension.mjs */ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LoaderParser.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs");





const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url) {
  const ext = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.extname(url);
  const name = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const loadWebFont = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__.LoaderParserPriority.Low
  },
  name: "loadWebFont",
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__.checkDataUrl)(url, validFontMIMEs) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, validFontExtensions);
  },
  async load(url, options) {
    const fonts = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name = options.data?.family ?? getFontFamilyName(url);
      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
      const data = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        const weight = weights[i];
        const font = new FontFace(name, `url(${encodeURI(url)})`, {
          ...data,
          weight
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    (Array.isArray(font) ? font : [font]).forEach((t) => _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.getFontFaceSet().delete(t));
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(loadWebFont);


//# sourceMappingURL=loadWebFont.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadImageBitmap": function() { return /* reexport safe */ _loadTextures_mjs__WEBPACK_IMPORTED_MODULE_1__.loadImageBitmap; },
/* harmony export */   "loadSVG": function() { return /* reexport safe */ _loadSVG_mjs__WEBPACK_IMPORTED_MODULE_0__.loadSVG; },
/* harmony export */   "loadTextures": function() { return /* reexport safe */ _loadTextures_mjs__WEBPACK_IMPORTED_MODULE_1__.loadTextures; }
/* harmony export */ });
/* harmony import */ var _loadSVG_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadSVG.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs");
/* harmony import */ var _loadTextures_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadTextures.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadSVG": function() { return /* binding */ loadSVG; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/checkDataUrl.mjs */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/checkExtension.mjs */ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../LoaderParser.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _loadTextures_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadTextures.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs");
/* harmony import */ var _utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/createTexture.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs");







const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSVG = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__.LoaderParserPriority.High
  },
  name: "loadSVG",
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__.checkDataUrl)(url, validSVGMIME) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, validSVGExtension);
  },
  async testParse(data) {
    return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SVGResource.test(data);
  },
  async parse(asset, data, loader) {
    const src = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SVGResource(asset, data?.data?.resourceOptions);
    await src.load();
    const base = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture(src, {
      resolution: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.getResolutionOfUrl(asset),
      ...data?.data
    });
    base.resource.src = asset;
    const texture = (0,_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_5__.createTexture)(base, loader, asset);
    return texture;
  },
  async load(url, _options) {
    const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload: _loadTextures_mjs__WEBPACK_IMPORTED_MODULE_4__.loadTextures.unload
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(loadSVG);


//# sourceMappingURL=loadSVG.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadImageBitmap": function() { return /* binding */ loadImageBitmap; },
/* harmony export */   "loadTextures": function() { return /* binding */ loadTextures; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/checkDataUrl.mjs */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs");
/* harmony import */ var _utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/checkExtension.mjs */ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs");
/* harmony import */ var _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../LoaderParser.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs");
/* harmony import */ var _WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../WorkerManager.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs");
/* harmony import */ var _utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/createTexture.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs");







const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url) {
  const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  const imageBitmap = await createImageBitmap(imageBlob);
  return imageBitmap;
}
const loadTextures = {
  name: "loadTextures",
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.LoadParser,
    priority: _LoaderParser_mjs__WEBPACK_IMPORTED_MODULE_3__.LoaderParserPriority.High
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url) {
    return (0,_utils_checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_1__.checkDataUrl)(url, validImageMIMEs) || (0,_utils_checkExtension_mjs__WEBPACK_IMPORTED_MODULE_2__.checkExtension)(url, validImageExtensions);
  },
  async load(url, asset, loader) {
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await _WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_4__.WorkerManager.isImageBitmapSupported()) {
        src = await _WorkerManager_mjs__WEBPACK_IMPORTED_MODULE_4__.WorkerManager.loadImageBitmap(url);
      } else {
        src = await loadImageBitmap(url);
      }
    } else {
      src = await new Promise((resolve) => {
        src = new Image();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url;
        if (src.complete) {
          resolve(src);
        } else {
          src.onload = () => {
            resolve(src);
          };
        }
      });
    }
    const base = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture(src, {
      resolution: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.getResolutionOfUrl(url),
      ...asset.data
    });
    base.resource.src = url;
    return (0,_utils_createTexture_mjs__WEBPACK_IMPORTED_MODULE_5__.createTexture)(base, loader, url);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(loadTextures);


//# sourceMappingURL=loadTextures.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTexture": function() { return /* binding */ createTexture; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


function createTexture(base, loader, url) {
  const texture = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture(base);
  texture.baseTexture.on("dispose", () => {
    delete loader.promiseCache[url];
  });
  return texture;
}


//# sourceMappingURL=createTexture.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTexture": function() { return /* reexport safe */ _createTexture_mjs__WEBPACK_IMPORTED_MODULE_0__.createTexture; }
/* harmony export */ });
/* harmony import */ var _createTexture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createTexture.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/loader/types.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/loader/types.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/Resolver.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/Resolver.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Resolver": function() { return /* binding */ Resolver; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/convertToList.mjs */ "./node_modules/@pixi/assets/lib/utils/convertToList.mjs");
/* harmony import */ var _utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/createStringVariations.mjs */ "./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs");
/* harmony import */ var _utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/isSingleItem.mjs */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs");





class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  addManifest(manifest) {
    if (this._manifest) {
      console.warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  addBundle(bundleId, assets) {
    const assetNames = [];
    if (Array.isArray(assets)) {
      assets.forEach((asset) => {
        if (typeof asset.name === "string") {
          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);
          assetNames.push(bundleAssetId);
          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);
        } else {
          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));
          bundleIds.forEach((bundleId2) => {
            assetNames.push(bundleId2);
          });
          this.add([...asset.name, ...bundleIds], asset.srcs);
        }
      });
    } else {
      Object.keys(assets).forEach((key) => {
        assetNames.push(this._createBundleAssetId(bundleId, key));
        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);
      });
    }
    this._bundles[bundleId] = assetNames;
  }
  add(keysIn, assetsIn, data) {
    const keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__.convertToList)(keysIn);
    keys.forEach((key) => {
      if (this.hasKey(key)) {
        console.warn(`[Resolver] already has key: ${key} overwriting`);
      }
    });
    if (!Array.isArray(assetsIn)) {
      if (typeof assetsIn === "string") {
        assetsIn = (0,_utils_createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_2__.createStringVariations)(assetsIn);
      } else {
        assetsIn = [assetsIn];
      }
    }
    const assetMap = assetsIn.map((asset) => {
      let formattedAsset = asset;
      if (typeof asset === "string") {
        let parsed = false;
        for (let i = 0; i < this._parsers.length; i++) {
          const parser = this._parsers[i];
          if (parser.test(asset)) {
            formattedAsset = parser.parse(asset);
            parsed = true;
            break;
          }
        }
        if (!parsed) {
          formattedAsset = {
            src: asset
          };
        }
      }
      if (!formattedAsset.format) {
        formattedAsset.format = formattedAsset.src.split(".").pop();
      }
      if (!formattedAsset.alias) {
        formattedAsset.alias = keys;
      }
      if (this._basePath || this._rootPath) {
        formattedAsset.src = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = formattedAsset.data ?? data;
      return formattedAsset;
    });
    keys.forEach((key) => {
      this._assetMap[key] = assetMap;
    });
  }
  resolveBundle(bundleIds) {
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_3__.isSingleItem)(bundleIds);
    bundleIds = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__.convertToList)(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i in result) {
        out[i] = result[i].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = (0,_utils_isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_3__.isSingleItem)(keys);
    keys = (0,_utils_convertToList_mjs__WEBPACK_IMPORTED_MODULE_1__.convertToList)(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          const bestAsset = assets[0];
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0] ?? bestAsset;
        } else {
          let src = key;
          if (this._basePath || this._rootPath) {
            src = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.toAbsolute(src, this._basePath, this._rootPath);
          }
          src = this._appendDefaultSearchParams(src);
          this._resolverHash[key] = {
            src
          };
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  hasKey(key) {
    return !!this._assetMap[key];
  }
  hasBundle(key) {
    return !!this._bundles[key];
  }
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[0];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
}


//# sourceMappingURL=Resolver.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/index.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parsers_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers/index.mjs */ "./node_modules/@pixi/assets/lib/resolver/parsers/index.mjs");
/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ "./node_modules/@pixi/assets/lib/resolver/types.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/parsers/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/parsers/index.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolveTextureUrl": function() { return /* reexport safe */ _resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveTextureUrl; }
/* harmony export */ });
/* harmony import */ var _resolveTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resolveTextureUrl.mjs */ "./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolveTextureUrl": function() { return /* binding */ resolveTextureUrl; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _loader_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../loader/index.mjs */ "./node_modules/@pixi/assets/lib/loader/index.mjs");
/* harmony import */ var _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../loader/parsers/textures/loadTextures.mjs */ "./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs");




const resolveTextureUrl = {
  extension: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ResolveParser,
  test: _loader_parsers_textures_loadTextures_mjs__WEBPACK_IMPORTED_MODULE_2__.loadTextures.test,
  parse: (value) => ({
    resolution: parseFloat(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
    format: value.split(".").pop(),
    src: value
  })
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(resolveTextureUrl);


//# sourceMappingURL=resolveTextureUrl.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/resolver/types.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/resolver/types.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkDataUrl": function() { return /* binding */ checkDataUrl; }
/* harmony export */ });
function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}


//# sourceMappingURL=checkDataUrl.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/checkExtension.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkExtension": function() { return /* binding */ checkExtension; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}


//# sourceMappingURL=checkExtension.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/convertToList.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/convertToList.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertToList": function() { return /* binding */ convertToList; }
/* harmony export */ });
const convertToList = (input, transform) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string") {
      return transform(item);
    }
    return item;
  });
};


//# sourceMappingURL=convertToList.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copySearchParams": function() { return /* binding */ copySearchParams; }
/* harmony export */ });
const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};


//# sourceMappingURL=copySearchParams.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createStringVariations": function() { return /* binding */ createStringVariations; }
/* harmony export */ });
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}


//# sourceMappingURL=createStringVariations.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkDataUrl": function() { return /* reexport safe */ _checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_0__.checkDataUrl; },
/* harmony export */   "checkExtension": function() { return /* reexport safe */ _checkExtension_mjs__WEBPACK_IMPORTED_MODULE_1__.checkExtension; },
/* harmony export */   "convertToList": function() { return /* reexport safe */ _convertToList_mjs__WEBPACK_IMPORTED_MODULE_2__.convertToList; },
/* harmony export */   "copySearchParams": function() { return /* reexport safe */ _copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_3__.copySearchParams; },
/* harmony export */   "createStringVariations": function() { return /* reexport safe */ _createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_4__.createStringVariations; },
/* harmony export */   "isSingleItem": function() { return /* reexport safe */ _isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_5__.isSingleItem; }
/* harmony export */ });
/* harmony import */ var _checkDataUrl_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./checkDataUrl.mjs */ "./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs");
/* harmony import */ var _checkExtension_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./checkExtension.mjs */ "./node_modules/@pixi/assets/lib/utils/checkExtension.mjs");
/* harmony import */ var _convertToList_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./convertToList.mjs */ "./node_modules/@pixi/assets/lib/utils/convertToList.mjs");
/* harmony import */ var _copySearchParams_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./copySearchParams.mjs */ "./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs");
/* harmony import */ var _createStringVariations_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createStringVariations.mjs */ "./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs");
/* harmony import */ var _isSingleItem_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isSingleItem.mjs */ "./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs");






//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isSingleItem": function() { return /* binding */ isSingleItem; }
/* harmony export */ });
const isSingleItem = (item) => !Array.isArray(item);


//# sourceMappingURL=isSingleItem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/color/lib/Color.mjs":
/*!************************************************!*\
  !*** ./node_modules/@pixi/color/lib/Color.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": function() { return /* binding */ Color; }
/* harmony export */ });
/* harmony import */ var colord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colord */ "./node_modules/colord/index.mjs");
/* harmony import */ var colord_plugins_names__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! colord/plugins/names */ "./node_modules/colord/plugins/names.mjs");



(0,colord__WEBPACK_IMPORTED_MODULE_0__.extend)([colord_plugins_names__WEBPACK_IMPORTED_MODULE_1__["default"]]);
const _Color = class {
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  set value(value) {
    if (value instanceof _Color) {
      this._value = this.cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set PIXI.Color#value to null");
    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {
      this.normalize(value);
      this._value = this.cloneSource(value);
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v, i) => v === value2[i]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  toRgba() {
    const [r, g, b, a] = this._components;
    return { r, g, b, a };
  }
  toRgb() {
    const [r, g, b] = this._components;
    return { r, g, b };
  }
  toRgbaString() {
    const [r, g, b] = this.toUint8RgbArray();
    return `rgba(${r},${g},${b},${this.alpha})`;
  }
  toUint8RgbArray(out) {
    const [r, g, b] = this._components;
    out = out ?? [];
    out[0] = Math.round(r * 255);
    out[1] = Math.round(g * 255);
    out[2] = Math.round(b * 255);
    return out;
  }
  toRgbArray(out) {
    out = out ?? [];
    const [r, g, b] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    return out;
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  multiply(value) {
    const [r, g, b, a] = _Color.temp.setValue(value)._components;
    this._components[0] *= r;
    this._components[1] *= g;
    this._components[2] *= b;
    this._components[3] *= a;
    this.refreshInt();
    this._value = null;
    return this;
  }
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r = this._int >> 16 & 255;
    let g = this._int >> 8 & 255;
    let b = this._int & 255;
    if (applyToRGB) {
      r = r * alpha + 0.5 | 0;
      g = g * alpha + 0.5 | 0;
      b = b * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
  }
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  round(steps) {
    const [r, g, b] = this._components;
    this._components[0] = Math.round(r * steps) / steps;
    this._components[1] = Math.round(g * steps) / steps;
    this._components[2] = Math.round(b * steps) / steps;
    this.refreshInt();
    this._value = null;
    return this;
  }
  toArray(out) {
    out = out ?? [];
    const [r, g, b, a] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
  }
  normalize(value) {
    let r;
    let g;
    let b;
    let a;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r = (int >> 16 & 255) / 255;
      g = (int >> 8 & 255) / 255;
      b = (int & 255) / 255;
      a = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r, g, b, a = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r, g, b, a = 255] = value;
      r /= 255;
      g /= 255;
      b /= 255;
      a /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)(value);
      if (color.isValid()) {
        ({ r, g, b, a } = color.rgba);
        r /= 255;
        g /= 255;
        b /= 255;
      }
    }
    if (r !== void 0) {
      this._components[0] = r;
      this._components[1] = g;
      this._components[2] = b;
      this._components[3] = a;
      this.refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  refreshInt() {
    this._clamp(this._components);
    const [r, g, b] = this._components;
    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
  }
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v, i) => {
      value[i] = Math.min(Math.max(v, min), max);
    });
    return value;
  }
};
let Color = _Color;
Color.shared = new _Color();
Color.temp = new _Color();
Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;


//# sourceMappingURL=Color.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/color/lib/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/@pixi/color/lib/index.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": function() { return /* reexport safe */ _Color_mjs__WEBPACK_IMPORTED_MODULE_0__.Color; }
/* harmony export */ });
/* harmony import */ var _Color_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color.mjs */ "./node_modules/@pixi/color/lib/Color.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/const.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/const.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INTERNAL_FORMATS": function() { return /* binding */ INTERNAL_FORMATS; },
/* harmony export */   "INTERNAL_FORMAT_TO_BYTES_PER_PIXEL": function() { return /* binding */ INTERNAL_FORMAT_TO_BYTES_PER_PIXEL; }
/* harmony export */ });
var INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
  return INTERNAL_FORMATS2;
})(INTERNAL_FORMATS || {});
const INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,
  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,
  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,
  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,
  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,
  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,
  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,
  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,
  [37488 /* COMPRESSED_R11_EAC */]: 0.5,
  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,
  [37490 /* COMPRESSED_RG11_EAC */]: 1,
  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,
  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,
  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,
  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,
  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,
  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,
  [35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */]: 0.5,
  [35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */]: 0.5,
  [35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */]: 0.25,
  [35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */]: 0.25,
  [36196 /* COMPRESSED_RGB_ETC1_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGB_ATC_WEBGL */]: 0.5,
  [35986 /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */]: 1,
  [34798 /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */]: 1,
  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1
};


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobResource": function() { return /* reexport safe */ _resources_BlobResource_mjs__WEBPACK_IMPORTED_MODULE_10__.BlobResource; },
/* harmony export */   "CompressedTextureResource": function() { return /* reexport safe */ _resources_CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_11__.CompressedTextureResource; },
/* harmony export */   "FORMATS_TO_COMPONENTS": function() { return /* reexport safe */ _parsers_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_9__.FORMATS_TO_COMPONENTS; },
/* harmony export */   "INTERNAL_FORMATS": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS; },
/* harmony export */   "INTERNAL_FORMAT_TO_BYTES_PER_PIXEL": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL; },
/* harmony export */   "TYPES_TO_BYTES_PER_COMPONENT": function() { return /* reexport safe */ _parsers_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_9__.TYPES_TO_BYTES_PER_COMPONENT; },
/* harmony export */   "TYPES_TO_BYTES_PER_PIXEL": function() { return /* reexport safe */ _parsers_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_9__.TYPES_TO_BYTES_PER_PIXEL; },
/* harmony export */   "detectCompressedTextures": function() { return /* reexport safe */ _loaders_detectCompressedTextures_mjs__WEBPACK_IMPORTED_MODULE_4__.detectCompressedTextures; },
/* harmony export */   "loadDDS": function() { return /* reexport safe */ _loaders_loadDDS_mjs__WEBPACK_IMPORTED_MODULE_5__.loadDDS; },
/* harmony export */   "loadKTX": function() { return /* reexport safe */ _loaders_loadKTX_mjs__WEBPACK_IMPORTED_MODULE_6__.loadKTX; },
/* harmony export */   "parseDDS": function() { return /* reexport safe */ _parsers_parseDDS_mjs__WEBPACK_IMPORTED_MODULE_8__.parseDDS; },
/* harmony export */   "parseKTX": function() { return /* reexport safe */ _parsers_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_9__.parseKTX; },
/* harmony export */   "resolveCompressedTextureUrl": function() { return /* reexport safe */ _loaders_resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_7__.resolveCompressedTextureUrl; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/compressed-textures/lib/const.mjs");
/* harmony import */ var _loaders_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loaders/index.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/index.mjs");
/* harmony import */ var _parsers_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parsers/index.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs");
/* harmony import */ var _resources_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/index.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/index.mjs");
/* harmony import */ var _loaders_detectCompressedTextures_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loaders/detectCompressedTextures.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs");
/* harmony import */ var _loaders_loadDDS_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loaders/loadDDS.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs");
/* harmony import */ var _loaders_loadKTX_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loaders/loadKTX.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs");
/* harmony import */ var _loaders_resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./loaders/resolveCompressedTextureUrl.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs");
/* harmony import */ var _parsers_parseDDS_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parsers/parseDDS.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs");
/* harmony import */ var _parsers_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parsers/parseKTX.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs");
/* harmony import */ var _resources_BlobResource_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resources/BlobResource.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs");
/* harmony import */ var _resources_CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./resources/CompressedTextureResource.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs");












//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.mjs ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=compressedTextureExtensions.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detectCompressedTextures": function() { return /* binding */ detectCompressedTextures; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


let storedGl;
let extensions;
function getCompressedTextureExtensions() {
  extensions = {
    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),
    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),
    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")
  };
}
const detectCompressedTextures = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.DetectionParser,
    priority: 2
  },
  test: async () => {
    const canvas = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.createCanvas();
    const gl = canvas.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures.");
      return false;
    }
    storedGl = gl;
    return true;
  },
  add: async (formats) => {
    if (!extensions)
      getCompressedTextureExtensions();
    const textureFormats = [];
    for (const extensionName in extensions) {
      const extension = extensions[extensionName];
      if (!extension) {
        continue;
      }
      textureFormats.push(extensionName);
    }
    return [...textureFormats, ...formats];
  },
  remove: async (formats) => {
    if (!extensions)
      getCompressedTextureExtensions();
    return formats.filter((f) => !(f in extensions));
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(detectCompressedTextures);


//# sourceMappingURL=detectCompressedTextures.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/index.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/index.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detectCompressedTextures": function() { return /* reexport safe */ _detectCompressedTextures_mjs__WEBPACK_IMPORTED_MODULE_1__.detectCompressedTextures; },
/* harmony export */   "loadDDS": function() { return /* reexport safe */ _loadDDS_mjs__WEBPACK_IMPORTED_MODULE_2__.loadDDS; },
/* harmony export */   "loadKTX": function() { return /* reexport safe */ _loadKTX_mjs__WEBPACK_IMPORTED_MODULE_3__.loadKTX; },
/* harmony export */   "resolveCompressedTextureUrl": function() { return /* reexport safe */ _resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_4__.resolveCompressedTextureUrl; }
/* harmony export */ });
/* harmony import */ var _compressedTextureExtensions_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compressedTextureExtensions.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.mjs");
/* harmony import */ var _detectCompressedTextures_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./detectCompressedTextures.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs");
/* harmony import */ var _loadDDS_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadDDS.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs");
/* harmony import */ var _loadKTX_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadKTX.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs");
/* harmony import */ var _resolveCompressedTextureUrl_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolveCompressedTextureUrl.mjs */ "./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs");





//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadDDS": function() { return /* binding */ loadDDS; }
/* harmony export */ });
/* harmony import */ var _pixi_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _parsers_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parsers/index.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs");
/* harmony import */ var _parsers_parseDDS_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parsers/parseDDS.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs");





const loadDDS = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.LoadParser,
    priority: _pixi_assets__WEBPACK_IMPORTED_MODULE_0__.LoaderParserPriority.High
  },
  name: "loadDDS",
  test(url) {
    return (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_0__.checkExtension)(url, ".dds");
  },
  async load(url, asset, loader) {
    const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const resources = (0,_parsers_parseDDS_mjs__WEBPACK_IMPORTED_MODULE_3__.parseDDS)(arrayBuffer);
    const textures = resources.map((resource) => {
      const base = new _pixi_core__WEBPACK_IMPORTED_MODULE_1__.BaseTexture(resource, {
        mipmap: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.MIPMAP_MODES.OFF,
        alphaMode: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        resolution: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.getResolutionOfUrl(url),
        ...asset.data
      });
      return (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_0__.createTexture)(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_1__.extensions.add(loadDDS);


//# sourceMappingURL=loadDDS.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadKTX": function() { return /* binding */ loadKTX; }
/* harmony export */ });
/* harmony import */ var _pixi_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _parsers_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parsers/index.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs");
/* harmony import */ var _parsers_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parsers/parseKTX.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs");





const loadKTX = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.LoadParser,
    priority: _pixi_assets__WEBPACK_IMPORTED_MODULE_0__.LoaderParserPriority.High
  },
  name: "loadKTX",
  test(url) {
    return (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_0__.checkExtension)(url, ".ktx");
  },
  async load(url, asset, loader) {
    const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const { compressed, uncompressed, kvData } = (0,_parsers_parseKTX_mjs__WEBPACK_IMPORTED_MODULE_3__.parseKTX)(url, arrayBuffer);
    const resources = compressed ?? uncompressed;
    const options = {
      mipmap: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.MIPMAP_MODES.OFF,
      alphaMode: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
      resolution: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.getResolutionOfUrl(url),
      ...asset.data
    };
    const textures = resources.map((resource) => {
      if (resources === uncompressed) {
        Object.assign(options, {
          type: resource.type,
          format: resource.format
        });
      }
      const base = new _pixi_core__WEBPACK_IMPORTED_MODULE_1__.BaseTexture(resource, options);
      base.ktxKeyValueData = kvData;
      return (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_0__.createTexture)(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_1__.extensions.add(loadKTX);


//# sourceMappingURL=loadKTX.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolveCompressedTextureUrl": function() { return /* binding */ resolveCompressedTextureUrl; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const resolveCompressedTextureUrl = {
  extension: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.ResolveParser,
  test: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    return ["basis", "ktx", "dds"].includes(extension);
  },
  parse: (value) => {
    const temp = value.split("?")[0];
    const extension = temp.split(".").pop();
    if (extension === "ktx") {
      const extensions2 = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx"
      ];
      if (extensions2.some((ext) => value.endsWith(ext))) {
        return {
          resolution: parseFloat(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format: extensions2.find((ext) => value.endsWith(ext)),
          src: value
        };
      }
    }
    return {
      resolution: parseFloat(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
      format: value.split(".").pop(),
      src: value
    };
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(resolveCompressedTextureUrl);


//# sourceMappingURL=resolveCompressedTextureUrl.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FORMATS_TO_COMPONENTS": function() { return /* reexport safe */ _parseKTX_mjs__WEBPACK_IMPORTED_MODULE_1__.FORMATS_TO_COMPONENTS; },
/* harmony export */   "TYPES_TO_BYTES_PER_COMPONENT": function() { return /* reexport safe */ _parseKTX_mjs__WEBPACK_IMPORTED_MODULE_1__.TYPES_TO_BYTES_PER_COMPONENT; },
/* harmony export */   "TYPES_TO_BYTES_PER_PIXEL": function() { return /* reexport safe */ _parseKTX_mjs__WEBPACK_IMPORTED_MODULE_1__.TYPES_TO_BYTES_PER_PIXEL; },
/* harmony export */   "parseDDS": function() { return /* reexport safe */ _parseDDS_mjs__WEBPACK_IMPORTED_MODULE_0__.parseDDS; },
/* harmony export */   "parseKTX": function() { return /* reexport safe */ _parseKTX_mjs__WEBPACK_IMPORTED_MODULE_1__.parseKTX; }
/* harmony export */ });
/* harmony import */ var _parseDDS_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseDDS.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs");
/* harmony import */ var _parseKTX_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseKTX.mjs */ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseDDS": function() { return /* binding */ parseDDS; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/compressed-textures/lib/const.mjs");
/* harmony import */ var _resources_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resources/index.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/index.mjs");
/* harmony import */ var _resources_CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/CompressedTextureResource.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs");




const DDS_MAGIC_SIZE = 4;
const DDS_HEADER_SIZE = 124;
const DDS_HEADER_PF_SIZE = 32;
const DDS_HEADER_DX10_SIZE = 20;
const DDS_MAGIC = 542327876;
const DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
const DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
const DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
  return DXGI_FORMAT2;
})(DXGI_FORMAT || {});
var D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
  return D3D10_RESOURCE_DIMENSION2;
})(D3D10_RESOURCE_DIMENSION || {});
const PF_FLAGS = 1;
const DDPF_ALPHA = 2;
const DDPF_FOURCC = 4;
const DDPF_RGB = 64;
const DDPF_YUV = 512;
const DDPF_LUMINANCE = 131072;
const FOURCC_DXT1 = 827611204;
const FOURCC_DXT3 = 861165636;
const FOURCC_DXT5 = 894720068;
const FOURCC_DX10 = 808540228;
const DDS_RESOURCE_MISC_TEXTURECUBE = 4;
const FOURCC_TO_FORMAT = {
  [FOURCC_DXT1]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [FOURCC_DXT3]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [FOURCC_DXT5]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
};
const DXGI_TO_FORMAT = {
  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [71 /* DXGI_FORMAT_BC1_UNORM */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [74 /* DXGI_FORMAT_BC2_UNORM */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [77 /* DXGI_FORMAT_BC3_UNORM */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function parseDDS(arrayBuffer) {
  const data = new Uint32Array(arrayBuffer);
  const magicWord = data[0];
  if (magicWord !== DDS_MAGIC) {
    throw new Error("Invalid DDS file magic word");
  }
  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const height = header[DDS_FIELDS.HEIGHT];
  const width = header[DDS_FIELDS.WIDTH];
  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  const formatFlags = pixelFormat[PF_FLAGS];
  if (formatFlags & DDPF_FOURCC) {
    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
    if (fourCC !== FOURCC_DX10) {
      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];
      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      const texData = new Uint8Array(arrayBuffer, dataOffset2);
      const resource = new _resources_CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_2__.CompressedTextureResource(texData, {
        format: internalFormat2,
        width,
        height,
        levels: mipmapCount
      });
      return [resource];
    }
    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];
    if (internalFormat === void 0) {
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
      throw new Error("DDSParser does not support cubemap textures");
    }
    if (resourceDimension === 6 /* DDS_DIMENSION_TEXTURE3D */) {
      throw new Error("DDSParser does not supported 3D texture data");
    }
    const imageBuffers = new Array();
    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (arraySize === 1) {
      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
    } else {
      const pixelSize = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];
      let imageSize = 0;
      let levelWidth = width;
      let levelHeight = height;
      for (let i = 0; i < mipmapCount; i++) {
        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
        imageSize += levelSize;
        levelWidth = levelWidth >>> 1;
        levelHeight = levelHeight >>> 1;
      }
      let imageOffset = dataOffset;
      for (let i = 0; i < arraySize; i++) {
        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
        imageOffset += imageSize;
      }
    }
    return imageBuffers.map((buffer) => new _resources_CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_2__.CompressedTextureResource(buffer, {
      format: internalFormat,
      width,
      height,
      levels: mipmapCount
    }));
  }
  if (formatFlags & DDPF_RGB) {
    throw new Error("DDSParser does not support uncompressed texture data.");
  }
  if (formatFlags & DDPF_YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (formatFlags & DDPF_LUMINANCE) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (formatFlags & DDPF_ALPHA) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}


//# sourceMappingURL=parseDDS.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FORMATS_TO_COMPONENTS": function() { return /* binding */ FORMATS_TO_COMPONENTS; },
/* harmony export */   "TYPES_TO_BYTES_PER_COMPONENT": function() { return /* binding */ TYPES_TO_BYTES_PER_COMPONENT; },
/* harmony export */   "TYPES_TO_BYTES_PER_PIXEL": function() { return /* binding */ TYPES_TO_BYTES_PER_PIXEL; },
/* harmony export */   "parseKTX": function() { return /* binding */ parseKTX; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/compressed-textures/lib/const.mjs");
/* harmony import */ var _resources_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../resources/index.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/index.mjs");
/* harmony import */ var _resources_CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../resources/CompressedTextureResource.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs");





const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
const ENDIANNESS = 67305985;
const KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
const FILE_HEADER_SIZE = 64;
const TYPES_TO_BYTES_PER_COMPONENT = {
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE]: 1,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT]: 2,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.INT]: 4,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_INT]: 4,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT]: 4,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.HALF_FLOAT]: 8
};
const FORMATS_TO_COMPONENTS = {
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: 4,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: 3,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG]: 2,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED]: 1,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.LUMINANCE]: 1,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.LUMINANCE_ALPHA]: 2,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.ALPHA]: 1
};
const TYPES_TO_BYTES_PER_PIXEL = {
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_5_6_5]: 2
};
function parseKTX(url, arrayBuffer, loadKeyValueData = false) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(url, dataView)) {
    return null;
  }
  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  const blockWidth = 4;
  const blockHeight = 4;
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  const imageBuffers = new Array(numberOfArrayElements);
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let imagePixelByteSize;
  if (glType !== 0) {
    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  } else {
    imagePixelByteSize = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;
  const imageByteSize = imagePixels * imagePixelByteSize;
  let mipByteSize = imageByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
      let mips = imageBuffers[arrayElement];
      if (!mips) {
        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
      }
      mips[mipmapLevel] = {
        levelID: mipmapLevel,
        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
      };
      elementOffset += mipByteSize;
    }
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  if (glType !== 0) {
    return {
      uncompressed: imageBuffers.map((levelBuffers) => {
        let buffer = levelBuffers[0].levelBuffer;
        let convertToInt = false;
        if (glType === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT) {
          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_INT) {
          convertToInt = true;
          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        } else if (glType === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.INT) {
          convertToInt = true;
          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
        }
        return {
          resource: new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BufferResource(buffer, {
            width: levelBuffers[0].levelWidth,
            height: levelBuffers[0].levelHeight
          }),
          type: glType,
          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat
        };
      }),
      kvData
    };
  }
  return {
    compressed: imageBuffers.map((levelBuffers) => new _resources_CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_3__.CompressedTextureResource(null, {
      format: glInternalFormat,
      width: pixelWidth,
      height: pixelHeight,
      levels: numberOfMipmapLevels,
      levelBuffers
    })),
    kvData
  };
}
function validate(url, dataView) {
  for (let i = 0; i < FILE_IDENTIFIER.length; i++) {
    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
      console.error(`${url} is not a valid *.ktx file!`);
      return false;
    }
  }
  return true;
}
function convertFormatToInteger(format) {
  switch (format) {
    case _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA:
      return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER;
    case _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB:
      return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB_INTEGER;
    case _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG:
      return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG_INTEGER;
    case _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED:
      return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED_INTEGER;
    default:
      return format;
  }
}
function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
  const kvData = /* @__PURE__ */ new Map();
  let bytesIntoKeyValueData = 0;
  while (bytesIntoKeyValueData < bytesOfKeyValueData) {
    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);
    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;
    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let keyNulByte = 0;
    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {
      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {
        break;
      }
    }
    if (keyNulByte === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
    kvData.set(key, value);
    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
  }
  return kvData;
}


//# sourceMappingURL=parseKTX.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobResource": function() { return /* binding */ BlobResource; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class BlobResource extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BufferResource {
  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {
    let origin;
    let data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    super(data, options);
    this.origin = origin;
    this.buffer = data ? new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ViewableBuffer(data) : null;
    this._load = null;
    this.loaded = false;
    if (this.origin !== null && options.autoLoad !== false) {
      this.load();
    }
    if (this.origin === null && this.buffer) {
      this._load = Promise.resolve(this);
      this.loaded = true;
      this.onBlobLoaded(this.buffer.rawBinaryData);
    }
  }
  onBlobLoaded(_data) {
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {
      this.data = new Uint32Array(arrayBuffer);
      this.buffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ViewableBuffer(arrayBuffer);
      this.loaded = true;
      this.onBlobLoaded(arrayBuffer);
      this.update();
      return this;
    });
    return this._load;
  }
}


//# sourceMappingURL=BlobResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompressedTextureResource": function() { return /* binding */ CompressedTextureResource; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/compressed-textures/lib/const.mjs");
/* harmony import */ var _BlobResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BlobResource.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs");



class CompressedTextureResource extends _BlobResource_mjs__WEBPACK_IMPORTED_MODULE_1__.BlobResource {
  constructor(source, options) {
    super(source, options);
    this.format = options.format;
    this.levels = options.levels || 1;
    this._width = options.width;
    this._height = options.height;
    this._extension = CompressedTextureResource._formatToExtension(this.format);
    if (options.levelBuffers || this.buffer) {
      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
  }
  upload(renderer, _texture, _glTexture) {
    const gl = renderer.gl;
    const extension = renderer.context.extensions[this._extension];
    if (!extension) {
      throw new Error(`${this._extension} textures are not supported on the current machine`);
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (let i = 0, j = this.levels; i < j; i++) {
      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  }
  onBlobLoaded() {
    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  }
  static _formatToExtension(format) {
    if (format >= 33776 && format <= 33779) {
      return "s3tc";
    } else if (format >= 37488 && format <= 37497) {
      return "etc";
    } else if (format >= 35840 && format <= 35843) {
      return "pvrtc";
    } else if (format >= 36196) {
      return "etc1";
    } else if (format >= 35986 && format <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    const buffers = new Array(levels);
    let offset = buffer.byteOffset;
    let levelWidth = imageWidth;
    let levelHeight = imageHeight;
    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    let levelSize = alignedLevelWidth * alignedLevelHeight * _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    for (let i = 0; i < levels; i++) {
      buffers[i] = {
        levelID: i,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * _const_mjs__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
    }
    return buffers;
  }
}


//# sourceMappingURL=CompressedTextureResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/compressed-textures/lib/resources/index.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/compressed-textures/lib/resources/index.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlobResource": function() { return /* reexport safe */ _BlobResource_mjs__WEBPACK_IMPORTED_MODULE_0__.BlobResource; },
/* harmony export */   "CompressedTextureResource": function() { return /* reexport safe */ _CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_1__.CompressedTextureResource; }
/* harmony export */ });
/* harmony import */ var _BlobResource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BlobResource.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs");
/* harmony import */ var _CompressedTextureResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CompressedTextureResource.mjs */ "./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/constants/lib/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/constants/lib/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ALPHA_MODES": function() { return /* binding */ ALPHA_MODES; },
/* harmony export */   "BLEND_MODES": function() { return /* binding */ BLEND_MODES; },
/* harmony export */   "BUFFER_BITS": function() { return /* binding */ BUFFER_BITS; },
/* harmony export */   "BUFFER_TYPE": function() { return /* binding */ BUFFER_TYPE; },
/* harmony export */   "CLEAR_MODES": function() { return /* binding */ CLEAR_MODES; },
/* harmony export */   "COLOR_MASK_BITS": function() { return /* binding */ COLOR_MASK_BITS; },
/* harmony export */   "DRAW_MODES": function() { return /* binding */ DRAW_MODES; },
/* harmony export */   "ENV": function() { return /* binding */ ENV; },
/* harmony export */   "FORMATS": function() { return /* binding */ FORMATS; },
/* harmony export */   "GC_MODES": function() { return /* binding */ GC_MODES; },
/* harmony export */   "MASK_TYPES": function() { return /* binding */ MASK_TYPES; },
/* harmony export */   "MIPMAP_MODES": function() { return /* binding */ MIPMAP_MODES; },
/* harmony export */   "MSAA_QUALITY": function() { return /* binding */ MSAA_QUALITY; },
/* harmony export */   "PRECISION": function() { return /* binding */ PRECISION; },
/* harmony export */   "RENDERER_TYPE": function() { return /* binding */ RENDERER_TYPE; },
/* harmony export */   "SAMPLER_TYPES": function() { return /* binding */ SAMPLER_TYPES; },
/* harmony export */   "SCALE_MODES": function() { return /* binding */ SCALE_MODES; },
/* harmony export */   "TARGETS": function() { return /* binding */ TARGETS; },
/* harmony export */   "TYPES": function() { return /* binding */ TYPES; },
/* harmony export */   "WRAP_MODES": function() { return /* binding */ WRAP_MODES; }
/* harmony export */ });
var ENV = /* @__PURE__ */ ((ENV2) => {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
  return ENV2;
})(ENV || {});
var RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
  return RENDERER_TYPE2;
})(RENDERER_TYPE || {});
var BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
  return BUFFER_BITS2;
})(BUFFER_BITS || {});
var BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
  return BLEND_MODES2;
})(BLEND_MODES || {});
var DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  return DRAW_MODES2;
})(DRAW_MODES || {});
var FORMATS = /* @__PURE__ */ ((FORMATS2) => {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return FORMATS2;
})(FORMATS || {});
var TARGETS = /* @__PURE__ */ ((TARGETS2) => {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return TARGETS2;
})(TARGETS || {});
var TYPES = /* @__PURE__ */ ((TYPES2) => {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return TYPES2;
})(TYPES || {});
var SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
  return SAMPLER_TYPES2;
})(SAMPLER_TYPES || {});
var SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
  return SCALE_MODES2;
})(SCALE_MODES || {});
var WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  return WRAP_MODES2;
})(WRAP_MODES || {});
var MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
  return MIPMAP_MODES2;
})(MIPMAP_MODES || {});
var ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
  return ALPHA_MODES2;
})(ALPHA_MODES || {});
var CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
  return CLEAR_MODES2;
})(CLEAR_MODES || {});
var GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
  return GC_MODES2;
})(GC_MODES || {});
var PRECISION = /* @__PURE__ */ ((PRECISION2) => {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
  return PRECISION2;
})(PRECISION || {});
var MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";
  return MASK_TYPES2;
})(MASK_TYPES || {});
var COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";
  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";
  return COLOR_MASK_BITS2;
})(COLOR_MASK_BITS || {});
var MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
  return MSAA_QUALITY2;
})(MSAA_QUALITY || {});
var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/IRenderer.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/core/lib/IRenderer.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=IRenderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/Renderer.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/core/lib/Renderer.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Renderer": function() { return /* binding */ Renderer; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shader/UniformGroup.mjs */ "./node_modules/@pixi/core/lib/shader/UniformGroup.mjs");
/* harmony import */ var _system_SystemManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./system/SystemManager.mjs */ "./node_modules/@pixi/core/lib/system/SystemManager.mjs");








const _Renderer = class extends _system_SystemManager_mjs__WEBPACK_IMPORTED_MODULE_6__.SystemManager {
  constructor(options) {
    super();
    this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.RENDERER_TYPE.WEBGL;
    options = Object.assign({}, _pixi_settings__WEBPACK_IMPORTED_MODULE_3__.settings.RENDER_OPTIONS, options);
    this.gl = null;
    this.CONTEXT_UID = 0;
    this.globalUniforms = new _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_5__.UniformGroup({
      projectionMatrix: new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Matrix()
    }, true);
    const systemConfig = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize"
      ],
      systems: _Renderer.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample"
      ]
    };
    this.setup(systemConfig);
    if ("useContextAlpha" in options) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");
      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";
      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;
    }
    this._plugin.rendererPlugins = _Renderer.__plugins;
    this.options = options;
    this.startup.run(this.options);
  }
  static test(options) {
    if (options?.forceCanvas) {
      return false;
    }
    return (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.isWebGLSupported)();
  }
  render(displayObject, options) {
    this.objectRenderer.render(displayObject, options);
  }
  resize(desiredScreenWidth, desiredScreenHeight) {
    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
  }
  reset() {
    this.runners.reset.emit();
    return this;
  }
  clear() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  }
  destroy(removeView = false) {
    this.runners.destroy.items.reverse();
    this.emitWithCustomOptions(this.runners.destroy, {
      _view: removeView
    });
    super.destroy();
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(value) {
    this._view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");
    return this.background.clearBeforeRender;
  }
  get useContextAlpha() {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");
    return this.context.useContextAlpha;
  }
  get preserveDrawingBuffer() {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");
    return this.context.preserveDrawingBuffer;
  }
  get backgroundColor() {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    return this.background.color;
  }
  set backgroundColor(value) {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
    this.background.color = value;
  }
  get backgroundAlpha() {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    return this.background.alpha;
  }
  set backgroundAlpha(value) {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
    this.background.alpha = value;
  }
  get powerPreference() {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");
    return this.context.powerPreference;
  }
  generateTexture(displayObject, options) {
    return this.textureGenerator.generateTexture(displayObject, options);
  }
};
let Renderer = _Renderer;
Renderer.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.Renderer,
  priority: 1
};
Renderer.__plugins = {};
Renderer.__systems = {};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.handleByMap(_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererPlugin, Renderer.__plugins);
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.handleByMap(_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem, Renderer.__systems);
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(Renderer);


//# sourceMappingURL=Renderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/autoDetectRenderer.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/autoDetectRenderer.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "autoDetectRenderer": function() { return /* binding */ autoDetectRenderer; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");


const renderers = [];
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.handleByList(_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Renderer, renderers);
function autoDetectRenderer(options) {
  for (const RendererType of renderers) {
    if (RendererType.test(options)) {
      return new RendererType(options);
    }
  }
  throw new Error("Unable to auto-detect a suitable renderer.");
}


//# sourceMappingURL=autoDetectRenderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundSystem": function() { return /* binding */ BackgroundSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");



class BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color(0);
    this.alpha = 1;
  }
  init(options) {
    this.clearBeforeRender = options.clearBeforeRender;
    const { backgroundColor, background, backgroundAlpha } = options;
    const color = background ?? backgroundColor;
    if (color !== void 0) {
      this.color = color;
    }
    this.alpha = backgroundAlpha;
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(value) {
    this._backgroundColor.setValue(value);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {
  }
}
BackgroundSystem.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: true
};
BackgroundSystem.extension = {
  type: [
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.CanvasRendererSystem
  ],
  name: "background"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(BackgroundSystem);


//# sourceMappingURL=BackgroundSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchDrawCall": function() { return /* binding */ BatchDrawCall; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


class BatchDrawCall {
  constructor() {
    this.texArray = null;
    this.blend = 0;
    this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
}


//# sourceMappingURL=BatchDrawCall.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchGeometry": function() { return /* binding */ BatchGeometry; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Buffer.mjs */ "./node_modules/@pixi/core/lib/geometry/Buffer.mjs");
/* harmony import */ var _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/Geometry.mjs */ "./node_modules/@pixi/core/lib/geometry/Geometry.mjs");




class BatchGeometry extends _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_2__.Geometry {
  constructor(_static = false) {
    super();
    this._buffer = new _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer(null, _static, false);
    this._indexBuffer = new _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer(null, _static, true);
    this.addAttribute("aVertexPosition", this._buffer, 2, false, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT).addIndex(this._indexBuffer);
  }
}


//# sourceMappingURL=BatchGeometry.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchRenderer": function() { return /* binding */ BatchRenderer; }
/* harmony export */ });
/* harmony import */ var _pixi_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.mjs");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _geometry_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geometry/ViewableBuffer.mjs */ "./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs");
/* harmony import */ var _shader_utils_checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shader/utils/checkMaxIfStatementsInShader.mjs */ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs");
/* harmony import */ var _state_State_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../state/State.mjs */ "./node_modules/@pixi/core/lib/state/State.mjs");
/* harmony import */ var _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../textures/BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");
/* harmony import */ var _BatchDrawCall_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./BatchDrawCall.mjs */ "./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs");
/* harmony import */ var _BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./BatchGeometry.mjs */ "./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs");
/* harmony import */ var _BatchShaderGenerator_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./BatchShaderGenerator.mjs */ "./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs");
/* harmony import */ var _BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./BatchTextureArray.mjs */ "./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs");
/* harmony import */ var _canUploadSameBuffer_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./canUploadSameBuffer.mjs */ "./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs");
/* harmony import */ var _maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./maxRecommendedTextures.mjs */ "./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs");
/* harmony import */ var _ObjectRenderer_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ObjectRenderer.mjs */ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs");
/* harmony import */ var _texture_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./texture.mjs */ "./node_modules/@pixi/core/lib/batch/texture.mjs");
/* harmony import */ var _texture2_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./texture2.mjs */ "./node_modules/@pixi/core/lib/batch/texture2.mjs");



















const _BatchRenderer = class extends _ObjectRenderer_mjs__WEBPACK_IMPORTED_MODULE_15__.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.setShaderGenerator();
    this.geometryClass = _BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_10__.BatchGeometry;
    this.vertexSize = 6;
    this.state = _state_State_mjs__WEBPACK_IMPORTED_MODULE_7__.State.for2d();
    this.size = _BatchRenderer.defaultBatchSize * 4;
    this._vertexCount = 0;
    this._indexCount = 0;
    this._bufferedElements = [];
    this._bufferedTextures = [];
    this._bufferSize = 0;
    this._shader = null;
    this._packedGeometries = [];
    this._packedGeometryPoolSize = 2;
    this._flushId = 0;
    this._aBuffers = {};
    this._iBuffers = {};
    this.maxTextures = 1;
    this.renderer.on("prerender", this.onPrerender, this);
    renderer.runners.contextChange.add(this);
    this._dcIndex = 0;
    this._aIndex = 0;
    this._iIndex = 0;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    this._tempBoundTextures = [];
  }
  static get defaultMaxTextures() {
    this._defaultMaxTextures = this._defaultMaxTextures ?? (0,_maxRecommendedTextures_mjs__WEBPACK_IMPORTED_MODULE_14__.maxRecommendedTextures)(32);
    return this._defaultMaxTextures;
  }
  static set defaultMaxTextures(value) {
    this._defaultMaxTextures = value;
  }
  static get canUploadSameBuffer() {
    this._canUploadSameBuffer = this._canUploadSameBuffer ?? (0,_canUploadSameBuffer_mjs__WEBPACK_IMPORTED_MODULE_13__.canUploadSameBuffer)();
    return this._canUploadSameBuffer;
  }
  static set canUploadSameBuffer(value) {
    this._canUploadSameBuffer = value;
  }
  get MAX_TEXTURES() {
    (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.deprecation)("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");
    return this.maxTextures;
  }
  static get defaultVertexSrc() {
    return _texture2_mjs__WEBPACK_IMPORTED_MODULE_17__["default"];
  }
  static get defaultFragmentTemplate() {
    return _texture_mjs__WEBPACK_IMPORTED_MODULE_16__["default"];
  }
  setShaderGenerator({
    vertex = _BatchRenderer.defaultVertexSrc,
    fragment = _BatchRenderer.defaultFragmentTemplate
  } = {}) {
    this.shaderGenerator = new _BatchShaderGenerator_mjs__WEBPACK_IMPORTED_MODULE_11__.BatchShaderGenerator(vertex, fragment);
  }
  contextChange() {
    const gl = this.renderer.gl;
    if (_pixi_settings__WEBPACK_IMPORTED_MODULE_3__.settings.PREFER_ENV === _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.ENV.WEBGL_LEGACY) {
      this.maxTextures = 1;
    } else {
      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);
      this.maxTextures = (0,_shader_utils_checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_6__.checkMaxIfStatementsInShader)(this.maxTextures, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.maxTextures);
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      this._packedGeometries[i] = new this.geometryClass();
    }
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const {
      _drawCallPool,
      _textureArrayPool
    } = _BatchRenderer;
    const MAX_SPRITES = this.size / 4;
    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new _BatchDrawCall_mjs__WEBPACK_IMPORTED_MODULE_9__.BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new _BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_12__.BatchTextureArray());
    }
    for (let i = 0; i < this.maxTextures; i++) {
      this._tempBoundTextures[i] = null;
    }
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  }
  buildTexturesAndDrawCalls() {
    const {
      _bufferedTextures: textures,
      maxTextures
    } = this;
    const textureArrays = _BatchRenderer._textureArrayPool;
    const batch = this.renderer.batch;
    const boundTextures = this._tempBoundTextures;
    const touch = this.renderer.textureGC.count;
    let TICK = ++_textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_8__.BaseTexture._globalBatch;
    let countTexArrays = 0;
    let texArray = textureArrays[0];
    let start = 0;
    batch.copyBoundTextures(boundTextures, maxTextures);
    for (let i = 0; i < this._bufferSize; ++i) {
      const tex = textures[i];
      textures[i] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= maxTextures) {
        batch.boundArray(texArray, boundTextures, TICK, maxTextures);
        this.buildDrawCalls(texArray, start, i);
        start = i;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, maxTextures);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (let i = 0; i < boundTextures.length; i++) {
      boundTextures[i] = null;
    }
    _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_8__.BaseTexture._globalBatch = TICK;
  }
  buildDrawCalls(texArray, start, finish) {
    const {
      _bufferedElements: elements,
      _attributeBuffer,
      _indexBuffer,
      vertexSize
    } = this;
    const drawCalls = _BatchRenderer._drawCallPool;
    let dcIndex = this._dcIndex;
    let aIndex = this._aIndex;
    let iIndex = this._iIndex;
    let drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (let i = start; i < finish; ++i) {
      const sprite = elements[i];
      const tex = sprite._texture.baseTexture;
      const spriteBlendMode = _pixi_utils__WEBPACK_IMPORTED_MODULE_4__.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i] = null;
      if (start < i && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  }
  bindAndClearTexArray(texArray) {
    const textureSystem = this.renderer.texture;
    for (let j = 0; j < texArray.count; j++) {
      textureSystem.bind(texArray.elements[j], texArray.ids[j]);
      texArray.elements[j] = null;
    }
    texArray.count = 0;
  }
  updateGeometry() {
    const {
      _packedGeometries: packedGeometries,
      _attributeBuffer: attributeBuffer,
      _indexBuffer: indexBuffer
    } = this;
    if (!_BatchRenderer.canUploadSameBuffer) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  }
  drawBatches() {
    const dcCount = this._dcIndex;
    const { gl, state: stateSystem } = this.renderer;
    const drawCalls = _BatchRenderer._drawCallPool;
    let curTexArray = null;
    for (let i = 0; i < dcCount; i++) {
      const { texArray, type, size, start, blend } = drawCalls[i];
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  }
  flush() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  }
  start() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.maxTextures);
    this.renderer.shader.bind(this._shader);
    if (_BatchRenderer.canUploadSameBuffer) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let i = 0; i < this._packedGeometryPoolSize; i++) {
      if (this._packedGeometries[i]) {
        this._packedGeometries[i].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    super.destroy();
  }
  getAttributeBuffer(size) {
    const roundedP2 = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.nextPow2)(Math.ceil(size / 8));
    const roundedSizeIndex = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.log2)(roundedP2);
    const roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new _geometry_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_5__.ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  }
  getIndexBuffer(size) {
    const roundedP2 = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.nextPow2)(Math.ceil(size / 12));
    const roundedSizeIndex = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_4__.log2)(roundedP2);
    const roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    let buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  }
  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    const {
      uint32View,
      float32View
    } = attributeBuffer;
    const packedVertices = aIndex / this.vertexSize;
    const uvs = element.uvs;
    const indicies = element.indices;
    const vertexData = element.vertexData;
    const textureId = element._texture.baseTexture._batchLocation;
    const alpha = Math.min(element.worldAlpha, 1);
    const argb = _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);
    for (let i = 0; i < vertexData.length; i += 2) {
      float32View[aIndex++] = vertexData[i];
      float32View[aIndex++] = vertexData[i + 1];
      float32View[aIndex++] = uvs[i];
      float32View[aIndex++] = uvs[i + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (let i = 0; i < indicies.length; i++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i];
    }
  }
};
let BatchRenderer = _BatchRenderer;
BatchRenderer.defaultBatchSize = 4096;
BatchRenderer.extension = {
  name: "batch",
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_2__.ExtensionType.RendererPlugin
};
BatchRenderer._drawCallPool = [];
BatchRenderer._textureArrayPool = [];
_pixi_extensions__WEBPACK_IMPORTED_MODULE_2__.extensions.add(BatchRenderer);


//# sourceMappingURL=BatchRenderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchShaderGenerator": function() { return /* binding */ BatchShaderGenerator; }
/* harmony export */ });
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader/Program.mjs */ "./node_modules/@pixi/core/lib/shader/Program.mjs");
/* harmony import */ var _shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader/Shader.mjs */ "./node_modules/@pixi/core/lib/shader/Shader.mjs");
/* harmony import */ var _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shader/UniformGroup.mjs */ "./node_modules/@pixi/core/lib/shader/UniformGroup.mjs");





class BatchShaderGenerator {
  constructor(vertexSrc, fragTemplate) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (!fragTemplate.includes("%count%")) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (!fragTemplate.includes("%forloop%")) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  generateShader(maxTextures) {
    if (!this.programCache[maxTextures]) {
      const sampleValues = new Int32Array(maxTextures);
      for (let i = 0; i < maxTextures; i++) {
        sampleValues[i] = i;
      }
      this.defaultGroupCache[maxTextures] = _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_3__.UniformGroup.from({ uSamplers: sampleValues }, true);
      let fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_1__.Program(this.vertexSrc, fragmentSrc);
    }
    const uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new _shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_2__.Shader(this.programCache[maxTextures], uniforms);
  }
  generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += `if(vTextureId < ${i}.5)`;
      }
      src += "\n{";
      src += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
}


//# sourceMappingURL=BatchShaderGenerator.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchSystem.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchSystem.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchSystem": function() { return /* binding */ BatchSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _ObjectRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectRenderer.mjs */ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs");



class BatchSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new _ObjectRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__.ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  setObjectRenderer(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(arr, maxTextures) {
    const { boundTextures } = this.renderer.texture;
    for (let i = maxTextures - 1; i >= 0; --i) {
      arr[i] = boundTextures[i] || null;
      if (arr[i]) {
        arr[i]._batchLocation = i;
      }
    }
  }
  boundArray(texArray, boundTextures, batchId, maxTextures) {
    const { elements, ids, count } = texArray;
    let j = 0;
    for (let i = 0; i < count; i++) {
      const tex = elements[i];
      const loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i] = loc;
        continue;
      }
      while (j < maxTextures) {
        const bound = boundTextures[j];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {
          j++;
          continue;
        }
        ids[i] = j;
        tex._batchLocation = j;
        boundTextures[j] = tex;
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
BatchSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "batch"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(BatchSystem);


//# sourceMappingURL=BatchSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchTextureArray": function() { return /* binding */ BatchTextureArray; }
/* harmony export */ });
class BatchTextureArray {
  constructor() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  clear() {
    for (let i = 0; i < this.count; i++) {
      this.elements[i] = null;
    }
    this.count = 0;
  }
}


//# sourceMappingURL=BatchTextureArray.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectRenderer": function() { return /* binding */ ObjectRenderer; }
/* harmony export */ });
class ObjectRenderer {
  constructor(renderer) {
    this.renderer = renderer;
  }
  flush() {
  }
  destroy() {
    this.renderer = null;
  }
  start() {
  }
  stop() {
    this.flush();
  }
  render(_object) {
  }
}


//# sourceMappingURL=ObjectRenderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "canUploadSameBuffer": function() { return /* binding */ canUploadSameBuffer; }
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");


function canUploadSameBuffer() {
  return !_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.isMobile.apple.device;
}


//# sourceMappingURL=canUploadSameBuffer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "maxRecommendedTextures": function() { return /* binding */ maxRecommendedTextures; }
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");


function maxRecommendedTextures(max) {
  let allowMax = true;
  const navigator = _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.getNavigator();
  if (_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.isMobile.tablet || _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.isMobile.phone) {
    if (_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.isMobile.apple.device) {
      const match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.isMobile.android.device) {
      const match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        const majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}


//# sourceMappingURL=maxRecommendedTextures.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/texture.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/texture.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ defaultFragment; }
/* harmony export */ });
var defaultFragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";


//# sourceMappingURL=texture.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/batch/texture2.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/batch/texture2.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ defaultVertex; }
/* harmony export */ });
var defaultVertex = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";


//# sourceMappingURL=texture2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/context/ContextSystem.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/context/ContextSystem.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContextSystem": function() { return /* binding */ ContextSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");




let CONTEXT_UID_COUNTER = 0;
class ContextSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
  }
  init(options) {
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this.renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha;
      this.preserveDrawingBuffer = options.preserveDrawingBuffer;
      this.useContextAlpha = options.useContextAlpha;
      this.powerPreference = options.powerPreference;
      this.initFromOptions({
        alpha,
        premultipliedAlpha,
        antialias: options.antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference
      });
    }
  }
  initFromContext(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
    const view = this.renderer.view;
    if (view.addEventListener !== void 0) {
      view.addEventListener("webglcontextlost", this.handleContextLost, false);
      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
  }
  initFromOptions(options) {
    const gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  }
  createContext(canvas, options) {
    let gl;
    if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV >= _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  }
  getExtensions() {
    const { gl } = this;
    const common = {
      loseContext: gl.getExtension("WEBGL_lose_context"),
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  }
  handleContextLost(event) {
    event.preventDefault();
    setTimeout(() => {
      if (this.gl.isContextLost() && this.extensions.loseContext) {
        this.extensions.loseContext.restoreContext();
      }
    }, 0);
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const view = this.renderer.view;
    this.renderer = null;
    if (view.removeEventListener !== void 0) {
      view.removeEventListener("webglcontextlost", this.handleContextLost);
      view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    }
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  }
  postrender() {
    if (this.renderer.objectRenderer.renderingToScreen) {
      this.gl.flush();
    }
  }
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (attributes && !attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
}
ContextSystem.defaultOptions = {
  context: null,
  antialias: false,
  premultipliedAlpha: true,
  preserveDrawingBuffer: false,
  powerPreference: "default"
};
ContextSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "context"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(ContextSystem);


//# sourceMappingURL=ContextSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/Filter.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/Filter.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Filter": function() { return /* binding */ Filter; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader/Program.mjs */ "./node_modules/@pixi/core/lib/shader/Program.mjs");
/* harmony import */ var _shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shader/Shader.mjs */ "./node_modules/@pixi/core/lib/shader/Shader.mjs");
/* harmony import */ var _state_State_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../state/State.mjs */ "./node_modules/@pixi/core/lib/state/State.mjs");
/* harmony import */ var _defaultFilter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaultFilter.mjs */ "./node_modules/@pixi/core/lib/filters/defaultFilter.mjs");
/* harmony import */ var _defaultFilter2_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./defaultFilter2.mjs */ "./node_modules/@pixi/core/lib/filters/defaultFilter2.mjs");







const _Filter = class extends _shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_2__.Shader {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    const program = _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_1__.Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);
    super(program, uniforms);
    this.padding = 0;
    this.resolution = _Filter.defaultResolution;
    this.multisample = _Filter.defaultMultisample;
    this.enabled = true;
    this.autoFit = true;
    this.state = new _state_State_mjs__WEBPACK_IMPORTED_MODULE_3__.State();
  }
  apply(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._resolution = value;
  }
  static get defaultVertexSrc() {
    return _defaultFilter2_mjs__WEBPACK_IMPORTED_MODULE_5__["default"];
  }
  static get defaultFragmentSrc() {
    return _defaultFilter_mjs__WEBPACK_IMPORTED_MODULE_4__["default"];
  }
};
let Filter = _Filter;
Filter.defaultResolution = 1;
Filter.defaultMultisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE;


//# sourceMappingURL=Filter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/FilterState.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/FilterState.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FilterState": function() { return /* binding */ FilterState; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");



class FilterState {
  constructor() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE;
    this.sourceFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    this.destinationFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    this.bindingSourceFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    this.bindingDestinationFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    this.filters = [];
    this.transform = null;
  }
  clear() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  }
}


//# sourceMappingURL=FilterState.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/FilterSystem.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/FilterSystem.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FilterSystem": function() { return /* binding */ FilterSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _renderTexture_RenderTexturePool_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderTexture/RenderTexturePool.mjs */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs");
/* harmony import */ var _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader/UniformGroup.mjs */ "./node_modules/@pixi/core/lib/shader/UniformGroup.mjs");
/* harmony import */ var _utils_Quad_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/Quad.mjs */ "./node_modules/@pixi/core/lib/utils/Quad.mjs");
/* harmony import */ var _utils_QuadUv_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/QuadUv.mjs */ "./node_modules/@pixi/core/lib/utils/QuadUv.mjs");
/* harmony import */ var _FilterState_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./FilterState.mjs */ "./node_modules/@pixi/core/lib/filters/FilterState.mjs");









const tempPoints = [new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Point(), new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Point(), new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Point(), new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Point()];
const tempMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Matrix();
class FilterSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new _renderTexture_RenderTexturePool_mjs__WEBPACK_IMPORTED_MODULE_3__.RenderTexturePool();
    this.statePool = [];
    this.quad = new _utils_Quad_mjs__WEBPACK_IMPORTED_MODULE_5__.Quad();
    this.quadUv = new _utils_QuadUv_mjs__WEBPACK_IMPORTED_MODULE_6__.QuadUv();
    this.tempRect = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
    this.activeState = {};
    this.globalUniforms = new _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_4__.UniformGroup({
      outputFrame: new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(target, filters) {
    const renderer = this.renderer;
    const filterStack = this.defaultFilterStack;
    const state = this.statePool.pop() || new _FilterState_mjs__WEBPACK_IMPORTED_MODULE_7__.FilterState();
    const renderTextureSystem = this.renderer.renderTexture;
    let resolution = filters[0].resolution;
    let multisample = filters[0].multisample;
    let padding = filters[0].padding;
    let autoFit = filters[0].autoFit;
    let legacy = filters[0].legacy ?? true;
    for (let i = 1; i < filters.length; i++) {
      const filter = filters[i];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || (filter.legacy ?? true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
    if (renderer.projection.transform) {
      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
    }
    if (autoFit) {
      state.sourceFrame.fit(sourceFrameProjected);
      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {
        state.sourceFrame.width = 0;
        state.sourceFrame.height = 0;
      }
    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {
      state.sourceFrame.width = 0;
      state.sourceFrame.height = 0;
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    const destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  }
  pop() {
    const filterStack = this.defaultFilterStack;
    const state = filterStack.pop();
    const filters = state.filters;
    this.activeState = state;
    const globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    const inputSize = globalUniforms.inputSize;
    const inputPixel = globalUniforms.inputPixel;
    const inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      const filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    const lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      let flip = state.renderTexture;
      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      let i = 0;
      for (i = 0; i < filters.length - 1; ++i) {
        if (i === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i].apply(this, flip, flop, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.CLEAR, state);
        const t = flip;
        flip = flop;
        flop = t;
      }
      filters[i].apply(this, flip, lastState.renderTexture, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.BLEND, state);
      if (i > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  }
  bindAndClear(filterTexture, clearMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.CLEAR) {
    const {
      renderTexture: renderTextureSystem,
      state: stateSystem
    } = this.renderer;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture?.filterFrame) {
      const destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    const autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.CLEAR || clearMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  }
  applyFilter(filter, input, output, clearMode) {
    const renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLE_STRIP);
    }
  }
  calculateSpriteMatrix(outputMatrix, sprite) {
    const { sourceFrame, destinationFrame } = this.activeState;
    const { orig } = sprite._texture;
    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    const worldTransform = sprite.worldTransform.copyTo(_pixi_math__WEBPACK_IMPORTED_MODULE_2__.Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this.renderer = null;
    this.texturePool.clear(false);
  }
  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE) {
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  }
  getFilterTexture(input, resolution, multisample) {
    if (typeof input === "number") {
      const swap = input;
      input = resolution;
      resolution = swap;
    }
    input = input || this.activeState.renderTexture;
    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnFilterTexture(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  }
  emptyPool() {
    this.texturePool.clear(true);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(matrix, rect) {
    const lt = tempPoints[0];
    const lb = tempPoints[1];
    const rt = tempPoints[2];
    const rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  }
  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      const { a, b, c, d } = transform;
      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  }
}
FilterSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "filter"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(FilterSystem);


//# sourceMappingURL=FilterSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/IFilterTarget.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/IFilterTarget.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=IFilterTarget.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/defaultFilter.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/defaultFilter.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ defaultFragment; }
/* harmony export */ });
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";


//# sourceMappingURL=defaultFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/defaultFilter2.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/defaultFilter2.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ defaultVertex; }
/* harmony export */ });
var defaultVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";


//# sourceMappingURL=defaultFilter2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteMaskFilter": function() { return /* binding */ SpriteMaskFilter; }
/* harmony export */ });
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _textures_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../textures/TextureMatrix.mjs */ "./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs");
/* harmony import */ var _Filter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Filter.mjs */ "./node_modules/@pixi/core/lib/filters/Filter.mjs");
/* harmony import */ var _spriteMaskFilter2_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./spriteMaskFilter2.mjs */ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.mjs");
/* harmony import */ var _spriteMaskFilter3_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./spriteMaskFilter3.mjs */ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.mjs");






class SpriteMaskFilter extends _Filter_mjs__WEBPACK_IMPORTED_MODULE_2__.Filter {
  constructor(vertexSrc, fragmentSrc, uniforms) {
    let sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    super(vertexSrc || _spriteMaskFilter3_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], fragmentSrc || _spriteMaskFilter2_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], uniforms);
    this.maskSprite = sprite;
    this.maskMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Matrix();
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(value) {
    this._maskSprite = value;
    if (this._maskSprite) {
      this._maskSprite.renderable = false;
    }
  }
  apply(filterManager, input, output, clearMode) {
    const maskSprite = this._maskSprite;
    const tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new _textures_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__.TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}


//# sourceMappingURL=SpriteMaskFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";


//# sourceMappingURL=spriteMaskFilter2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ vertex; }
/* harmony export */ });
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";


//# sourceMappingURL=spriteMaskFilter3.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/default.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/default.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ $defaultVertex; }
/* harmony export */ });
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";


//# sourceMappingURL=default.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/defaultFilter.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/defaultFilter.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ $defaultFilterVertex; }
/* harmony export */ });
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";


//# sourceMappingURL=defaultFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/fragments/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/fragments/index.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultFilterVertex": function() { return /* binding */ defaultFilterVertex; },
/* harmony export */   "defaultVertex": function() { return /* binding */ defaultVertex; }
/* harmony export */ });
/* harmony import */ var _default_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default.mjs */ "./node_modules/@pixi/core/lib/fragments/default.mjs");
/* harmony import */ var _defaultFilter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultFilter.mjs */ "./node_modules/@pixi/core/lib/fragments/defaultFilter.mjs");



const defaultVertex = _default_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
const defaultFilterVertex = _defaultFilter_mjs__WEBPACK_IMPORTED_MODULE_1__["default"];


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Framebuffer": function() { return /* binding */ Framebuffer; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");
/* harmony import */ var _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");
/* harmony import */ var _textures_resources_DepthResource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../textures/resources/DepthResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/DepthResource.mjs");





class Framebuffer {
  constructor(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_1__.Runner("disposeFramebuffer");
    this.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(index = 0, texture) {
    this.colorTextures[index] = texture || new _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseTexture(null, {
      scaleMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.NEAREST,
      resolution: 1,
      mipmap: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MIPMAP_MODES.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  addDepthTexture(texture) {
    this.depthTexture = texture || new _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseTexture(new _textures_resources_DepthResource_mjs__WEBPACK_IMPORTED_MODULE_3__.DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MIPMAP_MODES.OFF,
      format: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.DEPTH_COMPONENT,
      type: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableDepth() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  enableStencil() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height)
      return;
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (let i = 0; i < this.colorTextures.length; i++) {
      const texture = this.colorTextures[i];
      const resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      const resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroyDepthTexture() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  }
}


//# sourceMappingURL=Framebuffer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FramebufferSystem": function() { return /* binding */ FramebufferSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _Framebuffer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Framebuffer.mjs */ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs");
/* harmony import */ var _GLFramebuffer_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GLFramebuffer.mjs */ "./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs");







const tempRectangle = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
class FramebufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new _Framebuffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    if (this.renderer.context.webGLVersion === 1) {
      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (_pixi_settings__WEBPACK_IMPORTED_MODULE_3__.settings.PREFER_ENV === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ENV.WEBGL_LEGACY) {
        nativeDrawBuffersExtension = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension) {
        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);
      } else {
        this.hasMRT = false;
        gl.drawBuffers = () => {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  }
  bind(framebuffer, frame, mipLevel = 0) {
    const { gl } = this;
    if (framebuffer) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (let i = 0; i < framebuffer.colorTextures.length; i++) {
        const tex = framebuffer.colorTextures[i];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        const mipWidth = frame.width >> mipLevel;
        const mipHeight = frame.height >> mipLevel;
        const scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        const mipWidth = framebuffer.width >> mipLevel;
        const mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  }
  setViewport(x, y, width, height) {
    const v = this.viewport;
    x = Math.round(x);
    y = Math.round(y);
    width = Math.round(width);
    height = Math.round(height);
    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
      v.x = x;
      v.y = y;
      v.width = width;
      v.height = height;
      this.gl.viewport(x, y, width, height);
    }
  }
  get size() {
    if (this.current) {
      return { x: 0, y: 0, width: this.current.width, height: this.current.height };
    }
    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
  }
  clear(r, g, b, a, mask = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_BITS.COLOR | _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_BITS.DEPTH) {
    const { gl } = this;
    gl.clearColor(r, g, b, a);
    gl.clear(mask);
  }
  initFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = new _GLFramebuffer_mjs__WEBPACK_IMPORTED_MODULE_5__.GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  }
  resizeFramebuffer(framebuffer) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
      }
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  }
  updateFramebuffer(framebuffer, mipLevel) {
    const { gl } = this;
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const colorTextures = framebuffer.colorTextures;
    let count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    const activeTextures = [];
    for (let i = 0; i < count; i++) {
      const texture = colorTextures[i];
      const parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i === 0 && fbo.msaaBuffer) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
      }
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      const writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        const depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  }
  canMultisampleFramebuffer(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  }
  detectSamples(samples) {
    const { msaaSamples } = this;
    let res = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (let i = 0; i < msaaSamples.length; i++) {
      if (msaaSamples[i] <= samples) {
        res = msaaSamples[i];
        break;
      }
    }
    if (res === 1) {
      res = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE;
    }
    return res;
  }
  blit(framebuffer, sourcePixels, destPixels) {
    const { current, renderer, gl, CONTEXT_UID } = this;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    const fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      const colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new _Framebuffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
  }
  disposeFramebuffer(framebuffer, contextLost) {
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    const gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    const index = this.managedFramebuffers.indexOf(framebuffer);
    if (index >= 0) {
      this.managedFramebuffers.splice(index, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
    }
  }
  disposeAll(contextLost) {
    const list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i = 0; i < list.length; i++) {
      this.disposeFramebuffer(list[i], contextLost);
    }
  }
  forceStencil() {
    const framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    const w = framebuffer.width;
    const h = framebuffer.height;
    const gl = this.gl;
    const stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  }
  reset() {
    this.current = this.unknownFramebuffer;
    this.viewport = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
  }
  destroy() {
    this.renderer = null;
  }
}
FramebufferSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "framebuffer"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(FramebufferSystem);


//# sourceMappingURL=FramebufferSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLFramebuffer": function() { return /* binding */ GLFramebuffer; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


class GLFramebuffer {
  constructor(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
}


//# sourceMappingURL=GLFramebuffer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MultisampleSystem": function() { return /* binding */ MultisampleSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");



class MultisampleSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange(gl) {
    let samples;
    if (this.renderer.context.webGLVersion === 1) {
      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.HIGH) {
      this.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.HIGH;
    } else if (samples >= _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.MEDIUM) {
      this.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.MEDIUM;
    } else if (samples >= _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.LOW) {
      this.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.LOW;
    } else {
      this.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE;
    }
  }
  destroy() {
  }
}
MultisampleSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "_multisample"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(MultisampleSystem);


//# sourceMappingURL=MultisampleSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Attribute.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Attribute.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Attribute": function() { return /* binding */ Attribute; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


class Attribute {
  constructor(buffer, size = 0, normalized = false, type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT, stride, start, instance, divisor = 1) {
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
    this.divisor = divisor;
  }
  destroy() {
    this.buffer = null;
  }
  static from(buffer, size, normalized, type, stride) {
    return new Attribute(buffer, size, normalized, type, stride);
  }
}


//# sourceMappingURL=Attribute.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Buffer.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Buffer.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Buffer": function() { return /* binding */ Buffer; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");



let UID = 0;
class Buffer {
  constructor(data, _static = true, index = false) {
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index;
    this.static = _static;
    this.id = UID++;
    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_1__.Runner("disposeBuffer");
  }
  update(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.data = null;
  }
  set index(value) {
    this.type = value ? _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.ARRAY_BUFFER;
  }
  get index() {
    return this.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
  }
  static from(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer(data);
  }
}


//# sourceMappingURL=Buffer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/BufferSystem.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/BufferSystem.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BufferSystem": function() { return /* binding */ BufferSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _GLBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLBuffer.mjs */ "./node_modules/@pixi/core/lib/geometry/GLBuffer.mjs");



class BufferSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  }
  unbind(type) {
    const { gl } = this;
    gl.bindBuffer(type, null);
  }
  bindBufferBase(buffer, index) {
    const { gl, CONTEXT_UID } = this;
    if (this.boundBufferBases[index] !== buffer) {
      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  bindBufferRange(buffer, index, offset) {
    const { gl, CONTEXT_UID } = this;
    offset = offset || 0;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  }
  update(buffer) {
    const { gl, CONTEXT_UID } = this;
    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  }
  dispose(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    const gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedBuffers);
    for (let i = 0; i < all.length; i++) {
      this.dispose(this.managedBuffers[all[i]], contextLost);
    }
  }
  createGLBuffer(buffer) {
    const { CONTEXT_UID, gl } = this;
    buffer._glBuffers[CONTEXT_UID] = new _GLBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__.GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  }
}
BufferSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "buffer"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(BufferSystem);


//# sourceMappingURL=BufferSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/GLBuffer.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/GLBuffer.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLBuffer": function() { return /* binding */ GLBuffer; }
/* harmony export */ });
class GLBuffer {
  constructor(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
}


//# sourceMappingURL=GLBuffer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/Geometry.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/Geometry.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Geometry": function() { return /* binding */ Geometry; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _Attribute_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Attribute.mjs */ "./node_modules/@pixi/core/lib/geometry/Attribute.mjs");
/* harmony import */ var _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Buffer.mjs */ "./node_modules/@pixi/core/lib/geometry/Buffer.mjs");
/* harmony import */ var _utils_interleaveTypedArrays_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/interleaveTypedArrays.mjs */ "./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs");







const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
let UID = 0;
const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
class Geometry {
  constructor(buffers = [], attributes = {}) {
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_1__.Runner("disposeGeometry");
    this.refCount = 0;
  }
  addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer(buffer);
    }
    const ids = id.split("|");
    if (ids.length > 1) {
      for (let i = 0; i < ids.length; i++) {
        this.addAttribute(ids[i], buffer, size, normalized, type);
      }
      return this;
    }
    let bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new _Attribute_mjs__WEBPACK_IMPORTED_MODULE_3__.Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  }
  getAttribute(id) {
    return this.attributes[id];
  }
  getBuffer(id) {
    return this.buffers[this.getAttribute(id).buffer];
  }
  addIndex(buffer) {
    if (!(buffer instanceof _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer(buffer);
    }
    buffer.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (!this.buffers.includes(buffer)) {
      this.buffers.push(buffer);
    }
    return this;
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    const arrays = [];
    const sizes = [];
    const interleavedBuffer = new _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer();
    let i;
    for (i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = (0,_utils_interleaveTypedArrays_mjs__WEBPACK_IMPORTED_MODULE_5__.interleaveTypedArrays)(arrays, sizes);
    for (i = 0; i < this.buffers.length; i++) {
      if (this.buffers[i] !== this.indexBuffer) {
        this.buffers[i].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  }
  getSize() {
    for (const i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, false);
  }
  destroy() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  }
  clone() {
    const geometry = new Geometry();
    for (let i = 0; i < this.buffers.length; i++) {
      geometry.buffers[i] = new _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer(this.buffers[i].data.slice(0));
    }
    for (const i in this.attributes) {
      const attrib = this.attributes[i];
      geometry.attributes[i] = new _Attribute_mjs__WEBPACK_IMPORTED_MODULE_3__.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  }
  static merge(geometries) {
    const geometryOut = new Geometry();
    const arrays = [];
    const sizes = [];
    const offsets = [];
    let geometry;
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        sizes[j] = sizes[j] || 0;
        sizes[j] += geometry.buffers[j].data.length;
        offsets[j] = 0;
      }
    }
    for (let i = 0; i < geometry.buffers.length; i++) {
      arrays[i] = new map[(0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.getBufferType)(geometry.buffers[i].data)](sizes[i]);
      geometryOut.buffers[i] = new _Buffer_mjs__WEBPACK_IMPORTED_MODULE_4__.Buffer(arrays[i]);
    }
    for (let i = 0; i < geometries.length; i++) {
      geometry = geometries[i];
      for (let j = 0; j < geometry.buffers.length; j++) {
        arrays[j].set(geometry.buffers[j].data, offsets[j]);
        offsets[j] += geometry.buffers[j].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      let offset = 0;
      let stride = 0;
      let offset2 = 0;
      let bufferIndexToCount = 0;
      for (let i = 0; i < geometry.buffers.length; i++) {
        if (geometry.buffers[i] !== geometry.indexBuffer) {
          bufferIndexToCount = i;
          break;
        }
      }
      for (const i in geometry.attributes) {
        const attribute = geometry.attributes[i];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap[attribute.type] / 4;
        }
      }
      for (let i = 0; i < geometries.length; i++) {
        const indexBufferData = geometries[i].indexBuffer.data;
        for (let j = 0; j < indexBufferData.length; j++) {
          geometryOut.indexBuffer.data[j + offset2] += offset;
        }
        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  }
}


//# sourceMappingURL=Geometry.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GeometrySystem": function() { return /* binding */ GeometrySystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");




const byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
class GeometrySystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  contextChange() {
    this.disposeAll(true);
    const gl = this.gl = this.renderer.gl;
    const context = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context.webGLVersion !== 2) {
      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
      if (_pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.PREFER_ENV === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ENV.WEBGL_LEGACY) {
        nativeVaoExtension = null;
      }
      if (nativeVaoExtension) {
        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
      } else {
        this.hasVao = false;
        gl.createVertexArray = () => null;
        gl.bindVertexArray = () => null;
        gl.deleteVertexArray = () => null;
      }
    }
    if (context.webGLVersion !== 2) {
      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt) {
        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);
        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);
        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;
  }
  bind(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    const { gl } = this;
    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this.renderer.buffer;
    for (let i = 0; i < geometry.buffers.length; i++) {
      const buffer = geometry.buffers[i];
      bufferSystem.update(buffer);
    }
  }
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program.attributeData;
    for (const j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
      }
    }
  }
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program.attributeData;
    const strings = ["g", geometry.id];
    for (const i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  }
  initGeometryVao(geometry, shader, incRefCount = true) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    const tempStride = {};
    const tempStart = {};
    for (const j in buffers) {
      tempStride[j] = 0;
      tempStart[j] = 0;
    }
    for (const j in attributes) {
      if (!attributes[j].size && program.attributeData[j]) {
        attributes[j].size = program.attributeData[j].size;
      } else if (!attributes[j].size) {
        console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);
      }
      tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];
    }
    for (const j in attributes) {
      const attribute = attributes[j];
      const attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    bufferSystem.unbind(_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.ARRAY_BUFFER);
    return vao;
  }
  disposeGeometry(geometry, contextLost) {
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    const gl = this.gl;
    const buffers = geometry.buffers;
    const bufferSystem = this.renderer?.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (let i = 0; i < buffers.length; i++) {
        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (const vaoId in vaos) {
        if (vaoId[0] === "g") {
          const vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  }
  disposeAll(contextLost) {
    const all = Object.keys(this.managedGeometries);
    for (let i = 0; i < all.length; i++) {
      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
    }
  }
  activateVao(geometry, program) {
    const gl = this.gl;
    const CONTEXT_UID = this.CONTEXT_UID;
    const bufferSystem = this.renderer.buffer;
    const buffers = geometry.buffers;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j in attributes) {
      const attribute = attributes[j];
      const buffer = buffers[attribute.buffer];
      const glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location = program.attributeData[j].location;
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location, attribute.divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  draw(type, size, start, instanceCount) {
    const { gl } = this;
    const geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  }
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this.renderer = null;
  }
}
GeometrySystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "geometry"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(GeometrySystem);


//# sourceMappingURL=GeometrySystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewableBuffer": function() { return /* binding */ ViewableBuffer; }
/* harmony export */ });
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  get uint16View() {
    if (!this._uint16View) {
      this._uint16View = new Uint16Array(this.rawBinaryData);
    }
    return this._uint16View;
  }
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  view(type) {
    return this[`${type}View`];
  }
  destroy() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  }
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}


//# sourceMappingURL=ViewableBuffer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interleaveTypedArrays": function() { return /* binding */ interleaveTypedArrays; }
/* harmony export */ });
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");


const map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_0__.getBufferType)(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}


//# sourceMappingURL=interleaveTypedArrays.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/core/lib/index.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ALPHA_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.ALPHA_MODES; },
/* harmony export */   "AbstractMultiResource": function() { return /* reexport safe */ _textures_resources_AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_81__.AbstractMultiResource; },
/* harmony export */   "ArrayResource": function() { return /* reexport safe */ _textures_resources_ArrayResource_mjs__WEBPACK_IMPORTED_MODULE_82__.ArrayResource; },
/* harmony export */   "Attribute": function() { return /* reexport safe */ _geometry_Attribute_mjs__WEBPACK_IMPORTED_MODULE_29__.Attribute; },
/* harmony export */   "BLEND_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.BLEND_MODES; },
/* harmony export */   "BUFFER_BITS": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.BUFFER_BITS; },
/* harmony export */   "BUFFER_TYPE": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.BUFFER_TYPE; },
/* harmony export */   "BackgroundSystem": function() { return /* reexport safe */ _background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_10__.BackgroundSystem; },
/* harmony export */   "BaseImageResource": function() { return /* reexport safe */ _textures_resources_BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_79__.BaseImageResource; },
/* harmony export */   "BaseRenderTexture": function() { return /* reexport safe */ _renderTexture_BaseRenderTexture_mjs__WEBPACK_IMPORTED_MODULE_44__.BaseRenderTexture; },
/* harmony export */   "BaseTexture": function() { return /* reexport safe */ _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_65__.BaseTexture; },
/* harmony export */   "BatchDrawCall": function() { return /* reexport safe */ _batch_BatchDrawCall_mjs__WEBPACK_IMPORTED_MODULE_11__.BatchDrawCall; },
/* harmony export */   "BatchGeometry": function() { return /* reexport safe */ _batch_BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_12__.BatchGeometry; },
/* harmony export */   "BatchRenderer": function() { return /* reexport safe */ _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_13__.BatchRenderer; },
/* harmony export */   "BatchShaderGenerator": function() { return /* reexport safe */ _batch_BatchShaderGenerator_mjs__WEBPACK_IMPORTED_MODULE_14__.BatchShaderGenerator; },
/* harmony export */   "BatchSystem": function() { return /* reexport safe */ _batch_BatchSystem_mjs__WEBPACK_IMPORTED_MODULE_15__.BatchSystem; },
/* harmony export */   "BatchTextureArray": function() { return /* reexport safe */ _batch_BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_16__.BatchTextureArray; },
/* harmony export */   "BrowserAdapter": function() { return /* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_6__.BrowserAdapter; },
/* harmony export */   "Buffer": function() { return /* reexport safe */ _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_30__.Buffer; },
/* harmony export */   "BufferResource": function() { return /* reexport safe */ _textures_resources_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_84__.BufferResource; },
/* harmony export */   "BufferSystem": function() { return /* reexport safe */ _geometry_BufferSystem_mjs__WEBPACK_IMPORTED_MODULE_31__.BufferSystem; },
/* harmony export */   "CLEAR_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.CLEAR_MODES; },
/* harmony export */   "COLOR_MASK_BITS": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.COLOR_MASK_BITS; },
/* harmony export */   "CanvasResource": function() { return /* reexport safe */ _textures_resources_CanvasResource_mjs__WEBPACK_IMPORTED_MODULE_85__.CanvasResource; },
/* harmony export */   "Circle": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Circle; },
/* harmony export */   "Color": function() { return /* reexport safe */ _pixi_color__WEBPACK_IMPORTED_MODULE_1__.Color; },
/* harmony export */   "ContextSystem": function() { return /* reexport safe */ _context_ContextSystem_mjs__WEBPACK_IMPORTED_MODULE_18__.ContextSystem; },
/* harmony export */   "CubeResource": function() { return /* reexport safe */ _textures_resources_CubeResource_mjs__WEBPACK_IMPORTED_MODULE_86__.CubeResource; },
/* harmony export */   "DEG_TO_RAD": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.DEG_TO_RAD; },
/* harmony export */   "DRAW_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.DRAW_MODES; },
/* harmony export */   "ENV": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.ENV; },
/* harmony export */   "Ellipse": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Ellipse; },
/* harmony export */   "ExtensionType": function() { return /* reexport safe */ _pixi_extensions__WEBPACK_IMPORTED_MODULE_3__.ExtensionType; },
/* harmony export */   "FORMATS": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.FORMATS; },
/* harmony export */   "Filter": function() { return /* reexport safe */ _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_19__.Filter; },
/* harmony export */   "FilterState": function() { return /* reexport safe */ _filters_FilterState_mjs__WEBPACK_IMPORTED_MODULE_20__.FilterState; },
/* harmony export */   "FilterSystem": function() { return /* reexport safe */ _filters_FilterSystem_mjs__WEBPACK_IMPORTED_MODULE_21__.FilterSystem; },
/* harmony export */   "Framebuffer": function() { return /* reexport safe */ _framebuffer_Framebuffer_mjs__WEBPACK_IMPORTED_MODULE_25__.Framebuffer; },
/* harmony export */   "FramebufferSystem": function() { return /* reexport safe */ _framebuffer_FramebufferSystem_mjs__WEBPACK_IMPORTED_MODULE_26__.FramebufferSystem; },
/* harmony export */   "GC_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.GC_MODES; },
/* harmony export */   "GLFramebuffer": function() { return /* reexport safe */ _framebuffer_GLFramebuffer_mjs__WEBPACK_IMPORTED_MODULE_27__.GLFramebuffer; },
/* harmony export */   "GLProgram": function() { return /* reexport safe */ _shader_GLProgram_mjs__WEBPACK_IMPORTED_MODULE_49__.GLProgram; },
/* harmony export */   "GLTexture": function() { return /* reexport safe */ _textures_GLTexture_mjs__WEBPACK_IMPORTED_MODULE_66__.GLTexture; },
/* harmony export */   "GenerateTextureSystem": function() { return /* reexport safe */ _renderTexture_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_45__.GenerateTextureSystem; },
/* harmony export */   "Geometry": function() { return /* reexport safe */ _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_32__.Geometry; },
/* harmony export */   "GeometrySystem": function() { return /* reexport safe */ _geometry_GeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_33__.GeometrySystem; },
/* harmony export */   "IGLUniformData": function() { return /* reexport safe */ _shader_GLProgram_mjs__WEBPACK_IMPORTED_MODULE_49__.IGLUniformData; },
/* harmony export */   "INSTALLED": function() { return /* reexport safe */ _textures_resources_autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_83__.INSTALLED; },
/* harmony export */   "ImageBitmapResource": function() { return /* reexport safe */ _textures_resources_ImageBitmapResource_mjs__WEBPACK_IMPORTED_MODULE_87__.ImageBitmapResource; },
/* harmony export */   "ImageResource": function() { return /* reexport safe */ _textures_resources_ImageResource_mjs__WEBPACK_IMPORTED_MODULE_88__.ImageResource; },
/* harmony export */   "MASK_TYPES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.MASK_TYPES; },
/* harmony export */   "MIPMAP_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.MIPMAP_MODES; },
/* harmony export */   "MSAA_QUALITY": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.MSAA_QUALITY; },
/* harmony export */   "MaskData": function() { return /* reexport safe */ _mask_MaskData_mjs__WEBPACK_IMPORTED_MODULE_36__.MaskData; },
/* harmony export */   "MaskSystem": function() { return /* reexport safe */ _mask_MaskSystem_mjs__WEBPACK_IMPORTED_MODULE_37__.MaskSystem; },
/* harmony export */   "Matrix": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Matrix; },
/* harmony export */   "MultisampleSystem": function() { return /* reexport safe */ _framebuffer_MultisampleSystem_mjs__WEBPACK_IMPORTED_MODULE_28__.MultisampleSystem; },
/* harmony export */   "ObjectRenderer": function() { return /* reexport safe */ _batch_ObjectRenderer_mjs__WEBPACK_IMPORTED_MODULE_17__.ObjectRenderer; },
/* harmony export */   "ObjectRendererSystem": function() { return /* reexport safe */ _render_ObjectRendererSystem_mjs__WEBPACK_IMPORTED_MODULE_42__.ObjectRendererSystem; },
/* harmony export */   "ObservablePoint": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.ObservablePoint; },
/* harmony export */   "PI_2": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.PI_2; },
/* harmony export */   "PRECISION": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.PRECISION; },
/* harmony export */   "PluginSystem": function() { return /* reexport safe */ _plugin_PluginSystem_mjs__WEBPACK_IMPORTED_MODULE_40__.PluginSystem; },
/* harmony export */   "Point": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Point; },
/* harmony export */   "Polygon": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Polygon; },
/* harmony export */   "Program": function() { return /* reexport safe */ _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_50__.Program; },
/* harmony export */   "ProjectionSystem": function() { return /* reexport safe */ _projection_ProjectionSystem_mjs__WEBPACK_IMPORTED_MODULE_41__.ProjectionSystem; },
/* harmony export */   "Quad": function() { return /* reexport safe */ _utils_Quad_mjs__WEBPACK_IMPORTED_MODULE_75__.Quad; },
/* harmony export */   "QuadUv": function() { return /* reexport safe */ _utils_QuadUv_mjs__WEBPACK_IMPORTED_MODULE_76__.QuadUv; },
/* harmony export */   "RAD_TO_DEG": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.RAD_TO_DEG; },
/* harmony export */   "RENDERER_TYPE": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.RENDERER_TYPE; },
/* harmony export */   "Rectangle": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Rectangle; },
/* harmony export */   "RenderTexture": function() { return /* reexport safe */ _renderTexture_RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_46__.RenderTexture; },
/* harmony export */   "RenderTexturePool": function() { return /* reexport safe */ _renderTexture_RenderTexturePool_mjs__WEBPACK_IMPORTED_MODULE_47__.RenderTexturePool; },
/* harmony export */   "RenderTextureSystem": function() { return /* reexport safe */ _renderTexture_RenderTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_48__.RenderTextureSystem; },
/* harmony export */   "Renderer": function() { return /* reexport safe */ _Renderer_mjs__WEBPACK_IMPORTED_MODULE_43__.Renderer; },
/* harmony export */   "Resource": function() { return /* reexport safe */ _textures_resources_Resource_mjs__WEBPACK_IMPORTED_MODULE_80__.Resource; },
/* harmony export */   "RoundedRectangle": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.RoundedRectangle; },
/* harmony export */   "Runner": function() { return /* reexport safe */ _pixi_runner__WEBPACK_IMPORTED_MODULE_5__.Runner; },
/* harmony export */   "SAMPLER_TYPES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.SAMPLER_TYPES; },
/* harmony export */   "SCALE_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.SCALE_MODES; },
/* harmony export */   "SHAPES": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.SHAPES; },
/* harmony export */   "SVGResource": function() { return /* reexport safe */ _textures_resources_SVGResource_mjs__WEBPACK_IMPORTED_MODULE_89__.SVGResource; },
/* harmony export */   "ScissorSystem": function() { return /* reexport safe */ _mask_ScissorSystem_mjs__WEBPACK_IMPORTED_MODULE_38__.ScissorSystem; },
/* harmony export */   "Shader": function() { return /* reexport safe */ _shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_51__.Shader; },
/* harmony export */   "ShaderSystem": function() { return /* reexport safe */ _shader_ShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_52__.ShaderSystem; },
/* harmony export */   "SpriteMaskFilter": function() { return /* reexport safe */ _filters_spriteMask_SpriteMaskFilter_mjs__WEBPACK_IMPORTED_MODULE_23__.SpriteMaskFilter; },
/* harmony export */   "StartupSystem": function() { return /* reexport safe */ _startup_StartupSystem_mjs__WEBPACK_IMPORTED_MODULE_60__.StartupSystem; },
/* harmony export */   "State": function() { return /* reexport safe */ _state_State_mjs__WEBPACK_IMPORTED_MODULE_61__.State; },
/* harmony export */   "StateSystem": function() { return /* reexport safe */ _state_StateSystem_mjs__WEBPACK_IMPORTED_MODULE_62__.StateSystem; },
/* harmony export */   "StencilSystem": function() { return /* reexport safe */ _mask_StencilSystem_mjs__WEBPACK_IMPORTED_MODULE_39__.StencilSystem; },
/* harmony export */   "SystemManager": function() { return /* reexport safe */ _system_SystemManager_mjs__WEBPACK_IMPORTED_MODULE_78__.SystemManager; },
/* harmony export */   "TARGETS": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.TARGETS; },
/* harmony export */   "TYPES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.TYPES; },
/* harmony export */   "Texture": function() { return /* reexport safe */ _textures_Texture_mjs__WEBPACK_IMPORTED_MODULE_68__.Texture; },
/* harmony export */   "TextureGCSystem": function() { return /* reexport safe */ _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_69__.TextureGCSystem; },
/* harmony export */   "TextureMatrix": function() { return /* reexport safe */ _textures_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_70__.TextureMatrix; },
/* harmony export */   "TextureSystem": function() { return /* reexport safe */ _textures_TextureSystem_mjs__WEBPACK_IMPORTED_MODULE_71__.TextureSystem; },
/* harmony export */   "TextureUvs": function() { return /* reexport safe */ _textures_TextureUvs_mjs__WEBPACK_IMPORTED_MODULE_72__.TextureUvs; },
/* harmony export */   "Ticker": function() { return /* reexport safe */ _pixi_ticker__WEBPACK_IMPORTED_MODULE_7__.Ticker; },
/* harmony export */   "TickerPlugin": function() { return /* reexport safe */ _pixi_ticker__WEBPACK_IMPORTED_MODULE_7__.TickerPlugin; },
/* harmony export */   "Transform": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.Transform; },
/* harmony export */   "TransformFeedback": function() { return /* reexport safe */ _transformFeedback_TransformFeedback_mjs__WEBPACK_IMPORTED_MODULE_73__.TransformFeedback; },
/* harmony export */   "TransformFeedbackSystem": function() { return /* reexport safe */ _transformFeedback_TransformFeedbackSystem_mjs__WEBPACK_IMPORTED_MODULE_74__.TransformFeedbackSystem; },
/* harmony export */   "UPDATE_PRIORITY": function() { return /* reexport safe */ _pixi_ticker__WEBPACK_IMPORTED_MODULE_7__.UPDATE_PRIORITY; },
/* harmony export */   "UniformGroup": function() { return /* reexport safe */ _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_53__.UniformGroup; },
/* harmony export */   "VERSION": function() { return /* binding */ VERSION; },
/* harmony export */   "VideoResource": function() { return /* reexport safe */ _textures_resources_VideoResource_mjs__WEBPACK_IMPORTED_MODULE_90__.VideoResource; },
/* harmony export */   "ViewSystem": function() { return /* reexport safe */ _view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_77__.ViewSystem; },
/* harmony export */   "ViewableBuffer": function() { return /* reexport safe */ _geometry_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_34__.ViewableBuffer; },
/* harmony export */   "WRAP_MODES": function() { return /* reexport safe */ _pixi_constants__WEBPACK_IMPORTED_MODULE_2__.WRAP_MODES; },
/* harmony export */   "autoDetectRenderer": function() { return /* reexport safe */ _autoDetectRenderer_mjs__WEBPACK_IMPORTED_MODULE_9__.autoDetectRenderer; },
/* harmony export */   "autoDetectResource": function() { return /* reexport safe */ _textures_resources_autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_83__.autoDetectResource; },
/* harmony export */   "checkMaxIfStatementsInShader": function() { return /* reexport safe */ _shader_utils_checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_54__.checkMaxIfStatementsInShader; },
/* harmony export */   "createUBOElements": function() { return /* reexport safe */ _shader_utils_generateUniformBufferSync_mjs__WEBPACK_IMPORTED_MODULE_56__.createUBOElements; },
/* harmony export */   "defaultFilterVertex": function() { return /* reexport safe */ _fragments_index_mjs__WEBPACK_IMPORTED_MODULE_24__.defaultFilterVertex; },
/* harmony export */   "defaultVertex": function() { return /* reexport safe */ _fragments_index_mjs__WEBPACK_IMPORTED_MODULE_24__.defaultVertex; },
/* harmony export */   "extensions": function() { return /* reexport safe */ _pixi_extensions__WEBPACK_IMPORTED_MODULE_3__.extensions; },
/* harmony export */   "generateProgram": function() { return /* reexport safe */ _shader_utils_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_55__.generateProgram; },
/* harmony export */   "generateUniformBufferSync": function() { return /* reexport safe */ _shader_utils_generateUniformBufferSync_mjs__WEBPACK_IMPORTED_MODULE_56__.generateUniformBufferSync; },
/* harmony export */   "getTestContext": function() { return /* reexport safe */ _shader_utils_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_57__.getTestContext; },
/* harmony export */   "getUBOData": function() { return /* reexport safe */ _shader_utils_generateUniformBufferSync_mjs__WEBPACK_IMPORTED_MODULE_56__.getUBOData; },
/* harmony export */   "groupD8": function() { return /* reexport safe */ _pixi_math__WEBPACK_IMPORTED_MODULE_4__.groupD8; },
/* harmony export */   "isMobile": function() { return /* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_6__.isMobile; },
/* harmony export */   "settings": function() { return /* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_6__.settings; },
/* harmony export */   "uniformParsers": function() { return /* reexport safe */ _shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_58__.uniformParsers; },
/* harmony export */   "unsafeEvalSupported": function() { return /* reexport safe */ _shader_utils_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_59__.unsafeEvalSupported; },
/* harmony export */   "utils": function() { return /* reexport module object */ _pixi_utils__WEBPACK_IMPORTED_MODULE_8__; }
/* harmony export */ });
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi/core/lib/settings.mjs");
/* harmony import */ var _pixi_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.mjs");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_ticker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _autoDetectRenderer_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./autoDetectRenderer.mjs */ "./node_modules/@pixi/core/lib/autoDetectRenderer.mjs");
/* harmony import */ var _background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./background/BackgroundSystem.mjs */ "./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs");
/* harmony import */ var _batch_BatchDrawCall_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./batch/BatchDrawCall.mjs */ "./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs");
/* harmony import */ var _batch_BatchGeometry_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./batch/BatchGeometry.mjs */ "./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs");
/* harmony import */ var _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./batch/BatchRenderer.mjs */ "./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs");
/* harmony import */ var _batch_BatchShaderGenerator_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./batch/BatchShaderGenerator.mjs */ "./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs");
/* harmony import */ var _batch_BatchSystem_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./batch/BatchSystem.mjs */ "./node_modules/@pixi/core/lib/batch/BatchSystem.mjs");
/* harmony import */ var _batch_BatchTextureArray_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./batch/BatchTextureArray.mjs */ "./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs");
/* harmony import */ var _batch_ObjectRenderer_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./batch/ObjectRenderer.mjs */ "./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs");
/* harmony import */ var _context_ContextSystem_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./context/ContextSystem.mjs */ "./node_modules/@pixi/core/lib/context/ContextSystem.mjs");
/* harmony import */ var _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./filters/Filter.mjs */ "./node_modules/@pixi/core/lib/filters/Filter.mjs");
/* harmony import */ var _filters_FilterState_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./filters/FilterState.mjs */ "./node_modules/@pixi/core/lib/filters/FilterState.mjs");
/* harmony import */ var _filters_FilterSystem_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./filters/FilterSystem.mjs */ "./node_modules/@pixi/core/lib/filters/FilterSystem.mjs");
/* harmony import */ var _filters_IFilterTarget_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./filters/IFilterTarget.mjs */ "./node_modules/@pixi/core/lib/filters/IFilterTarget.mjs");
/* harmony import */ var _filters_spriteMask_SpriteMaskFilter_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./filters/spriteMask/SpriteMaskFilter.mjs */ "./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs");
/* harmony import */ var _fragments_index_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./fragments/index.mjs */ "./node_modules/@pixi/core/lib/fragments/index.mjs");
/* harmony import */ var _framebuffer_Framebuffer_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./framebuffer/Framebuffer.mjs */ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs");
/* harmony import */ var _framebuffer_FramebufferSystem_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./framebuffer/FramebufferSystem.mjs */ "./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs");
/* harmony import */ var _framebuffer_GLFramebuffer_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./framebuffer/GLFramebuffer.mjs */ "./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs");
/* harmony import */ var _framebuffer_MultisampleSystem_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./framebuffer/MultisampleSystem.mjs */ "./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs");
/* harmony import */ var _geometry_Attribute_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./geometry/Attribute.mjs */ "./node_modules/@pixi/core/lib/geometry/Attribute.mjs");
/* harmony import */ var _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./geometry/Buffer.mjs */ "./node_modules/@pixi/core/lib/geometry/Buffer.mjs");
/* harmony import */ var _geometry_BufferSystem_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./geometry/BufferSystem.mjs */ "./node_modules/@pixi/core/lib/geometry/BufferSystem.mjs");
/* harmony import */ var _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./geometry/Geometry.mjs */ "./node_modules/@pixi/core/lib/geometry/Geometry.mjs");
/* harmony import */ var _geometry_GeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./geometry/GeometrySystem.mjs */ "./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs");
/* harmony import */ var _geometry_ViewableBuffer_mjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./geometry/ViewableBuffer.mjs */ "./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs");
/* harmony import */ var _IRenderer_mjs__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./IRenderer.mjs */ "./node_modules/@pixi/core/lib/IRenderer.mjs");
/* harmony import */ var _mask_MaskData_mjs__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./mask/MaskData.mjs */ "./node_modules/@pixi/core/lib/mask/MaskData.mjs");
/* harmony import */ var _mask_MaskSystem_mjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./mask/MaskSystem.mjs */ "./node_modules/@pixi/core/lib/mask/MaskSystem.mjs");
/* harmony import */ var _mask_ScissorSystem_mjs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./mask/ScissorSystem.mjs */ "./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs");
/* harmony import */ var _mask_StencilSystem_mjs__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./mask/StencilSystem.mjs */ "./node_modules/@pixi/core/lib/mask/StencilSystem.mjs");
/* harmony import */ var _plugin_PluginSystem_mjs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./plugin/PluginSystem.mjs */ "./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs");
/* harmony import */ var _projection_ProjectionSystem_mjs__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./projection/ProjectionSystem.mjs */ "./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs");
/* harmony import */ var _render_ObjectRendererSystem_mjs__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./render/ObjectRendererSystem.mjs */ "./node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs");
/* harmony import */ var _Renderer_mjs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./Renderer.mjs */ "./node_modules/@pixi/core/lib/Renderer.mjs");
/* harmony import */ var _renderTexture_BaseRenderTexture_mjs__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./renderTexture/BaseRenderTexture.mjs */ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs");
/* harmony import */ var _renderTexture_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.mjs */ "./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs");
/* harmony import */ var _renderTexture_RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./renderTexture/RenderTexture.mjs */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs");
/* harmony import */ var _renderTexture_RenderTexturePool_mjs__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./renderTexture/RenderTexturePool.mjs */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs");
/* harmony import */ var _renderTexture_RenderTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.mjs */ "./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs");
/* harmony import */ var _shader_GLProgram_mjs__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./shader/GLProgram.mjs */ "./node_modules/@pixi/core/lib/shader/GLProgram.mjs");
/* harmony import */ var _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./shader/Program.mjs */ "./node_modules/@pixi/core/lib/shader/Program.mjs");
/* harmony import */ var _shader_Shader_mjs__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./shader/Shader.mjs */ "./node_modules/@pixi/core/lib/shader/Shader.mjs");
/* harmony import */ var _shader_ShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./shader/ShaderSystem.mjs */ "./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs");
/* harmony import */ var _shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./shader/UniformGroup.mjs */ "./node_modules/@pixi/core/lib/shader/UniformGroup.mjs");
/* harmony import */ var _shader_utils_checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./shader/utils/checkMaxIfStatementsInShader.mjs */ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs");
/* harmony import */ var _shader_utils_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./shader/utils/generateProgram.mjs */ "./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs");
/* harmony import */ var _shader_utils_generateUniformBufferSync_mjs__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./shader/utils/generateUniformBufferSync.mjs */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs");
/* harmony import */ var _shader_utils_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./shader/utils/getTestContext.mjs */ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs");
/* harmony import */ var _shader_utils_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./shader/utils/uniformParsers.mjs */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs");
/* harmony import */ var _shader_utils_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./shader/utils/unsafeEvalSupported.mjs */ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs");
/* harmony import */ var _startup_StartupSystem_mjs__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./startup/StartupSystem.mjs */ "./node_modules/@pixi/core/lib/startup/StartupSystem.mjs");
/* harmony import */ var _state_State_mjs__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./state/State.mjs */ "./node_modules/@pixi/core/lib/state/State.mjs");
/* harmony import */ var _state_StateSystem_mjs__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./state/StateSystem.mjs */ "./node_modules/@pixi/core/lib/state/StateSystem.mjs");
/* harmony import */ var _system_ISystem_mjs__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./system/ISystem.mjs */ "./node_modules/@pixi/core/lib/system/ISystem.mjs");
/* harmony import */ var _systems_mjs__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./systems.mjs */ "./node_modules/@pixi/core/lib/systems.mjs");
/* harmony import */ var _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./textures/BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");
/* harmony import */ var _textures_GLTexture_mjs__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./textures/GLTexture.mjs */ "./node_modules/@pixi/core/lib/textures/GLTexture.mjs");
/* harmony import */ var _textures_resources_index_mjs__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./textures/resources/index.mjs */ "./node_modules/@pixi/core/lib/textures/resources/index.mjs");
/* harmony import */ var _textures_Texture_mjs__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./textures/Texture.mjs */ "./node_modules/@pixi/core/lib/textures/Texture.mjs");
/* harmony import */ var _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./textures/TextureGCSystem.mjs */ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs");
/* harmony import */ var _textures_TextureMatrix_mjs__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./textures/TextureMatrix.mjs */ "./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs");
/* harmony import */ var _textures_TextureSystem_mjs__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./textures/TextureSystem.mjs */ "./node_modules/@pixi/core/lib/textures/TextureSystem.mjs");
/* harmony import */ var _textures_TextureUvs_mjs__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./textures/TextureUvs.mjs */ "./node_modules/@pixi/core/lib/textures/TextureUvs.mjs");
/* harmony import */ var _transformFeedback_TransformFeedback_mjs__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./transformFeedback/TransformFeedback.mjs */ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs");
/* harmony import */ var _transformFeedback_TransformFeedbackSystem_mjs__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.mjs */ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs");
/* harmony import */ var _utils_Quad_mjs__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./utils/Quad.mjs */ "./node_modules/@pixi/core/lib/utils/Quad.mjs");
/* harmony import */ var _utils_QuadUv_mjs__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./utils/QuadUv.mjs */ "./node_modules/@pixi/core/lib/utils/QuadUv.mjs");
/* harmony import */ var _view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./view/ViewSystem.mjs */ "./node_modules/@pixi/core/lib/view/ViewSystem.mjs");
/* harmony import */ var _system_SystemManager_mjs__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./system/SystemManager.mjs */ "./node_modules/@pixi/core/lib/system/SystemManager.mjs");
/* harmony import */ var _textures_resources_BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./textures/resources/BaseImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs");
/* harmony import */ var _textures_resources_Resource_mjs__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./textures/resources/Resource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/Resource.mjs");
/* harmony import */ var _textures_resources_AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./textures/resources/AbstractMultiResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs");
/* harmony import */ var _textures_resources_ArrayResource_mjs__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./textures/resources/ArrayResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs");
/* harmony import */ var _textures_resources_autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./textures/resources/autoDetectResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs");
/* harmony import */ var _textures_resources_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./textures/resources/BufferResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs");
/* harmony import */ var _textures_resources_CanvasResource_mjs__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./textures/resources/CanvasResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs");
/* harmony import */ var _textures_resources_CubeResource_mjs__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./textures/resources/CubeResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs");
/* harmony import */ var _textures_resources_ImageBitmapResource_mjs__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./textures/resources/ImageBitmapResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs");
/* harmony import */ var _textures_resources_ImageResource_mjs__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./textures/resources/ImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs");
/* harmony import */ var _textures_resources_SVGResource_mjs__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./textures/resources/SVGResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs");
/* harmony import */ var _textures_resources_VideoResource_mjs__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./textures/resources/VideoResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs");





























































































const VERSION = "7.2.4";


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractMaskSystem": function() { return /* binding */ AbstractMaskSystem; }
/* harmony export */ });
class AbstractMaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(maskStack) {
    const { gl } = this.renderer;
    const curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    const newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  }
  _useCurrent() {
  }
  destroy() {
    this.renderer = null;
    this.maskStack = null;
  }
}


//# sourceMappingURL=AbstractMaskSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/MaskData.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/MaskData.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaskData": function() { return /* binding */ MaskData; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filters/Filter.mjs */ "./node_modules/@pixi/core/lib/filters/Filter.mjs");



class MaskData {
  constructor(maskObject = null) {
    this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_1__.Filter.defaultMultisample;
    this.enabled = true;
    this.colorMask = 15;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._colorMask = 15;
    this._target = null;
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(value) {
    if (value) {
      if (this._filters) {
        this._filters[0] = value;
      } else {
        this._filters = [value];
      }
    } else {
      this._filters = null;
    }
  }
  reset() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  }
  copyCountersOrReset(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  }
}


//# sourceMappingURL=MaskData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/MaskSystem.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/MaskSystem.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaskSystem": function() { return /* binding */ MaskSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _filters_spriteMask_SpriteMaskFilter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../filters/spriteMask/SpriteMaskFilter.mjs */ "./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs");
/* harmony import */ var _MaskData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MaskData.mjs */ "./node_modules/@pixi/core/lib/mask/MaskData.mjs");





class MaskSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  setMaskStack(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  }
  push(target, maskDataOrTarget) {
    let maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      const d = this.maskDataPool.pop() || new _MaskData_mjs__WEBPACK_IMPORTED_MODULE_3__.MaskData();
      d.pooled = true;
      d.maskObject = maskDataOrTarget;
      maskData = d;
    }
    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.COLOR:
          this.pushColorMask(maskData);
          break;
        default:
          break;
      }
    }
    if (maskData.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SPRITE) {
      this.maskStack.push(maskData);
    }
  }
  pop(target) {
    const maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SCISSOR:
          this.renderer.scissor.pop(maskData);
          break;
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SPRITE:
          this.popSpriteMask(maskData);
          break;
        case _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.COLOR:
          this.popColorMask(maskData);
          break;
        default:
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      const maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  }
  detect(maskData) {
    const maskObject = maskData.maskObject;
    if (!maskObject) {
      maskData.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.COLOR;
    } else if (maskObject.isSprite) {
      maskData.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.SCISSOR;
    } else {
      maskData.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.STENCIL;
    }
  }
  pushSpriteMask(maskData) {
    const { maskObject } = maskData;
    const target = maskData._target;
    let alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new _filters_spriteMask_SpriteMaskFilter_mjs__WEBPACK_IMPORTED_MODULE_2__.SpriteMaskFilter()];
      }
    }
    const renderer = this.renderer;
    const renderTextureSystem = renderer.renderTexture;
    let resolution;
    let multisample;
    if (renderTextureSystem.current) {
      const renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = maskData.multisample ?? renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = maskData.multisample ?? renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    const stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  }
  popSpriteMask(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  }
  pushColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  popColorMask(maskData) {
    const currColorMask = maskData._colorMask;
    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    if (nextColorMask !== currColorMask) {
      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);
    }
  }
  destroy() {
    this.renderer = null;
  }
}
MaskSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "mask"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(MaskSystem);


//# sourceMappingURL=MaskSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScissorSystem": function() { return /* binding */ ScissorSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _AbstractMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbstractMaskSystem.mjs */ "./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs");





const tempMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();
const rectPool = [];
const _ScissorSystem = class extends _AbstractMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_3__.AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  }
  calcScissorRect(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    const prevData = maskData._scissorRect;
    const { maskObject } = maskData;
    const { renderer } = this;
    const renderTextureSystem = renderer.renderTexture;
    const rect = maskObject.getBounds(true, rectPool.pop() ?? new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle());
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  }
  static isMatrixRotated(matrix) {
    if (!matrix) {
      return false;
    }
    const { a, b, c, d } = matrix;
    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);
  }
  testScissor(maskData) {
    const { maskObject } = maskData;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    const rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  }
  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (_ScissorSystem.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  }
  push(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    const { gl } = this.renderer;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  }
  pop(maskData) {
    const { gl } = this.renderer;
    if (maskData) {
      rectPool.push(maskData._scissorRectLocal);
    }
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  _useCurrent() {
    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    let y;
    if (this.renderer.renderTexture.current) {
      y = rect.y;
    } else {
      y = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
  }
};
let ScissorSystem = _ScissorSystem;
ScissorSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "scissor"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(ScissorSystem);


//# sourceMappingURL=ScissorSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/mask/StencilSystem.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/mask/StencilSystem.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StencilSystem": function() { return /* binding */ StencilSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _AbstractMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractMaskSystem.mjs */ "./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs");




class StencilSystem extends _AbstractMaskSystem_mjs__WEBPACK_IMPORTED_MODULE_2__.AbstractMaskSystem {
  constructor(renderer) {
    super(renderer);
    this.glConst = _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;
  }
  getStackLength() {
    const maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  }
  push(maskData) {
    const maskObject = maskData.maskObject;
    const { gl } = this.renderer;
    const prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    const colorMask = maskData._colorMask;
    if (colorMask !== 0) {
      maskData._colorMask = 0;
      gl.colorMask(false, false, false, false);
    }
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    if (colorMask !== 0) {
      maskData._colorMask = colorMask;
      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
    }
    this._useCurrent();
  }
  pop(maskObject) {
    const gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      const colorMask = maskData ? maskData._colorMask : 15;
      if (colorMask !== 0) {
        maskData._colorMask = 0;
        gl.colorMask(false, false, false, false);
      }
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      if (colorMask !== 0) {
        maskData._colorMask = colorMask;
        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);
      }
      this._useCurrent();
    }
  }
  _useCurrent() {
    const gl = this.renderer.gl;
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  }
}
StencilSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "stencil"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(StencilSystem);


//# sourceMappingURL=StencilSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PluginSystem": function() { return /* binding */ PluginSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");



class PluginSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.plugins = {};
    Object.defineProperties(this.plugins, {
      extract: {
        enumerable: false,
        get() {
          (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.0.0", "renderer.plugins.extract has moved to renderer.extract");
          return renderer.extract;
        }
      },
      prepare: {
        enumerable: false,
        get() {
          (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");
          return renderer.prepare;
        }
      },
      interaction: {
        enumerable: false,
        get() {
          (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");
          return renderer.events;
        }
      }
    });
  }
  init() {
    const staticMap = this.rendererPlugins;
    for (const o in staticMap) {
      this.plugins[o] = new staticMap[o](this.renderer);
    }
  }
  destroy() {
    for (const o in this.plugins) {
      this.plugins[o].destroy();
      this.plugins[o] = null;
    }
  }
}
PluginSystem.extension = {
  type: [
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasRendererSystem
  ],
  name: "_plugin"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(PluginSystem);


//# sourceMappingURL=PluginSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ProjectionSystem": function() { return /* binding */ ProjectionSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");



class ProjectionSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();
    this.transform = null;
  }
  update(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    const renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  }
  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
    const pm = this.projectionMatrix;
    const sign = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign - sourceFrame.y * pm.d;
  }
  setTransform(_matrix) {
  }
  destroy() {
    this.renderer = null;
  }
}
ProjectionSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "projection"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(ProjectionSystem);


//# sourceMappingURL=ProjectionSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseRenderTexture": function() { return /* binding */ BaseRenderTexture; }
/* harmony export */ });
/* harmony import */ var _pixi_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.mjs");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _framebuffer_Framebuffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framebuffer/Framebuffer.mjs */ "./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs");
/* harmony import */ var _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../textures/BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");





class BaseRenderTexture extends _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture {
  constructor(options = {}) {
    if (typeof options === "number") {
      const width = arguments[0];
      const height = arguments[1];
      const scaleMode = arguments[2];
      const resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample ?? (options.multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.MSAA_QUALITY.NONE);
    super(null, options);
    this.mipmap = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.MIPMAP_MODES.OFF;
    this.valid = true;
    this._clear = new _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color([0, 0, 0, 0]);
    this.framebuffer = new _framebuffer_Framebuffer_mjs__WEBPACK_IMPORTED_MODULE_2__.Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);
    this.framebuffer.multisample = options.multisample;
    this.maskStack = [];
    this.filterStack = [{}];
  }
  set clearColor(value) {
    this._clear.setValue(value);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  resize(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }
  dispose() {
    this.framebuffer.dispose();
    super.dispose();
  }
  destroy() {
    super.destroy();
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  }
}


//# sourceMappingURL=BaseRenderTexture.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GenerateTextureSystem": function() { return /* binding */ GenerateTextureSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RenderTexture.mjs */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs");




const tempTransform = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Transform();
class GenerateTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this._tempMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();
  }
  generateTexture(displayObject, options) {
    const { region: manualRegion, ...textureOptions } = options || {};
    const region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0)
      region.width = 1;
    if (region.height === 0)
      region.height = 1;
    const renderTexture = _RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_2__.RenderTexture.create({
      width: region.width,
      height: region.height,
      ...textureOptions
    });
    this._tempMatrix.tx = -region.x;
    this._tempMatrix.ty = -region.y;
    const transform = displayObject.transform;
    displayObject.transform = tempTransform;
    this.renderer.render(displayObject, {
      renderTexture,
      transform: this._tempMatrix,
      skipUpdateTransform: !!displayObject.parent,
      blit: true
    });
    displayObject.transform = transform;
    return renderTexture;
  }
  destroy() {
  }
}
GenerateTextureSystem.extension = {
  type: [
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasRendererSystem
  ],
  name: "textureGenerator"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(GenerateTextureSystem);


//# sourceMappingURL=GenerateTextureSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderTexture": function() { return /* binding */ RenderTexture; }
/* harmony export */ });
/* harmony import */ var _textures_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../textures/Texture.mjs */ "./node_modules/@pixi/core/lib/textures/Texture.mjs");
/* harmony import */ var _BaseRenderTexture_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseRenderTexture.mjs */ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs");



class RenderTexture extends _textures_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__.Texture {
  constructor(baseRenderTexture, frame) {
    super(baseRenderTexture, frame);
    this.valid = true;
    this.filterFrame = null;
    this.filterPoolKey = null;
    this.updateUvs();
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(value) {
    this.framebuffer.multisample = value;
  }
  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {
    const resolution = this.baseTexture.resolution;
    const width = Math.round(desiredWidth * resolution) / resolution;
    const height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  }
  setResolution(resolution) {
    const { baseTexture } = this;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  }
  static create(options) {
    return new RenderTexture(new _BaseRenderTexture_mjs__WEBPACK_IMPORTED_MODULE_1__.BaseRenderTexture(options));
  }
}


//# sourceMappingURL=RenderTexture.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderTexturePool": function() { return /* binding */ RenderTexturePool; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _BaseRenderTexture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseRenderTexture.mjs */ "./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs");
/* harmony import */ var _RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderTexture.mjs */ "./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs");





class RenderTexturePool {
  constructor(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  createTexture(realWidth, realHeight, multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE) {
    const baseRenderTexture = new _BaseRenderTexture_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new _RenderTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.RenderTexture(baseRenderTexture);
  }
  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE) {
    let key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(minWidth);
      minHeight = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    let renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  }
  getFilterTexture(input, resolution, multisample) {
    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MSAA_QUALITY.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  }
  returnTexture(renderTexture) {
    const key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  }
  returnFilterTexture(renderTexture) {
    this.returnTexture(renderTexture);
  }
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i in this.texturePool) {
        const textures = this.texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  }
  setScreenSize(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (const i in this.texturePool) {
      if (!(Number(i) < 0)) {
        continue;
      }
      const textures = this.texturePool[i];
      if (textures) {
        for (let j = 0; j < textures.length; j++) {
          textures[j].destroy(true);
        }
      }
      this.texturePool[i] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  }
}
RenderTexturePool.SCREEN_KEY = -1;


//# sourceMappingURL=RenderTexturePool.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderTextureSystem": function() { return /* binding */ RenderTextureSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");




const tempRect = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
const tempRect2 = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
class RenderTextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
    this.destinationFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
    this.viewportFrame = new _pixi_math__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
  }
  contextChange() {
    const attributes = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
  }
  bind(renderTexture = null, sourceFrame, destinationFrame) {
    const renderer = this.renderer;
    this.current = renderTexture;
    let baseTexture;
    let framebuffer;
    let resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer._view.screen.width;
        tempRect.height = renderer._view.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    const viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  }
  clear(clearColor, mask) {
    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;
    const color = _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(clearColor ? clearColor : fallbackColor);
    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {
      color.premultiply(color.alpha);
    }
    const destinationFrame = this.destinationFrame;
    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;
    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      let { x, y, width, height } = this.viewportFrame;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x, y, width, height);
    }
    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
RenderTextureSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "renderTexture"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(RenderTextureSystem);


//# sourceMappingURL=RenderTextureSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectRendererSystem": function() { return /* binding */ ObjectRendererSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");


class ObjectRendererSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  render(displayObject, options) {
    const renderer = this.renderer;
    let renderTexture;
    let clear;
    let transform;
    let skipUpdateTransform;
    if (options) {
      renderTexture = options.renderTexture;
      clear = options.clear;
      transform = options.transform;
      skipUpdateTransform = options.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer.runners.prerender.emit();
    renderer.emit("prerender");
    renderer.projection.transform = transform;
    if (renderer.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    renderer.renderTexture.bind(renderTexture);
    renderer.batch.currentRenderer.start();
    if (clear ?? renderer.background.clearBeforeRender) {
      renderer.renderTexture.clear();
    }
    displayObject.render(renderer);
    renderer.batch.currentRenderer.flush();
    if (renderTexture) {
      if (options.blit) {
        renderer.framebuffer.blit();
      }
      renderTexture.baseTexture.update();
    }
    renderer.runners.postrender.emit();
    renderer.projection.transform = null;
    renderer.emit("postrender");
  }
  destroy() {
    this.renderer = null;
    this.lastObjectRendered = null;
  }
}
ObjectRendererSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "objectRenderer"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(ObjectRendererSystem);


//# sourceMappingURL=ObjectRendererSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/settings.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/core/lib/settings.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./batch/BatchRenderer.mjs */ "./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs");
/* harmony import */ var _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filters/Filter.mjs */ "./node_modules/@pixi/core/lib/filters/Filter.mjs");
/* harmony import */ var _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shader/Program.mjs */ "./node_modules/@pixi/core/lib/shader/Program.mjs");
/* harmony import */ var _systems_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./systems.mjs */ "./node_modules/@pixi/core/lib/systems.mjs");
/* harmony import */ var _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./textures/BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");
/* harmony import */ var _context_ContextSystem_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./context/ContextSystem.mjs */ "./node_modules/@pixi/core/lib/context/ContextSystem.mjs");
/* harmony import */ var _background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./background/BackgroundSystem.mjs */ "./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs");
/* harmony import */ var _view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./view/ViewSystem.mjs */ "./node_modules/@pixi/core/lib/view/ViewSystem.mjs");
/* harmony import */ var _startup_StartupSystem_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./startup/StartupSystem.mjs */ "./node_modules/@pixi/core/lib/startup/StartupSystem.mjs");
/* harmony import */ var _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./textures/TextureGCSystem.mjs */ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs");














_pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.PREFER_ENV = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ENV.WEBGL2;
_pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.STRICT_TEXTURE_CACHE = false;
_pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.RENDER_OPTIONS = {
  ..._context_ContextSystem_mjs__WEBPACK_IMPORTED_MODULE_8__.ContextSystem.defaultOptions,
  ..._background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_9__.BackgroundSystem.defaultOptions,
  ..._view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_10__.ViewSystem.defaultOptions,
  ..._startup_StartupSystem_mjs__WEBPACK_IMPORTED_MODULE_11__.StartupSystem.defaultOptions
};
Object.defineProperties(_pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings, {
  WRAP_MODE: {
    get() {
      return _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.wrapMode;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");
      _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.wrapMode = value;
    }
  },
  SCALE_MODE: {
    get() {
      return _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.scaleMode;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");
      _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.scaleMode = value;
    }
  },
  MIPMAP_TEXTURES: {
    get() {
      return _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.mipmap;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");
      _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.mipmap = value;
    }
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.anisotropicLevel;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");
      _textures_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_7__.BaseTexture.defaultOptions.anisotropicLevel = value;
    }
  },
  FILTER_RESOLUTION: {
    get() {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");
      return _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_4__.Filter.defaultResolution;
    },
    set(value) {
      _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_4__.Filter.defaultResolution = value;
    }
  },
  FILTER_MULTISAMPLE: {
    get() {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");
      return _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_4__.Filter.defaultMultisample;
    },
    set(value) {
      _filters_Filter_mjs__WEBPACK_IMPORTED_MODULE_4__.Filter.defaultMultisample = value;
    }
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchRenderer.defaultMaxTextures;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");
      _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchRenderer.defaultMaxTextures = value;
    }
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchRenderer.defaultBatchSize;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");
      _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchRenderer.defaultBatchSize = value;
    }
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchRenderer.canUploadSameBuffer;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");
      _batch_BatchRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__.BatchRenderer.canUploadSameBuffer = value;
    }
  },
  GC_MODE: {
    get() {
      return _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.TextureGCSystem.defaultMode;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");
      _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.TextureGCSystem.defaultMode = value;
    }
  },
  GC_MAX_IDLE: {
    get() {
      return _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.TextureGCSystem.defaultMaxIdle;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");
      _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.TextureGCSystem.defaultMaxIdle = value;
    }
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.TextureGCSystem.defaultCheckCountMax;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");
      _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.TextureGCSystem.defaultCheckCountMax = value;
    }
  },
  PRECISION_VERTEX: {
    get() {
      return _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_5__.Program.defaultVertexPrecision;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");
      _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_5__.Program.defaultVertexPrecision = value;
    }
  },
  PRECISION_FRAGMENT: {
    get() {
      return _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_5__.Program.defaultFragmentPrecision;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");
      _shader_Program_mjs__WEBPACK_IMPORTED_MODULE_5__.Program.defaultFragmentPrecision = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/GLProgram.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/GLProgram.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLProgram": function() { return /* binding */ GLProgram; },
/* harmony export */   "IGLUniformData": function() { return /* binding */ IGLUniformData; }
/* harmony export */ });
class IGLUniformData {
}
class GLProgram {
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  }
}


//# sourceMappingURL=GLProgram.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/Program.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/Program.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Program": function() { return /* binding */ Program; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _defaultProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaultProgram.mjs */ "./node_modules/@pixi/core/lib/shader/defaultProgram.mjs");
/* harmony import */ var _defaultProgram2_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultProgram2.mjs */ "./node_modules/@pixi/core/lib/shader/defaultProgram2.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/core/lib/shader/utils/index.mjs");
/* harmony import */ var _utils_setPrecision_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/setPrecision.mjs */ "./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs");
/* harmony import */ var _utils_getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/getMaxFragmentPrecision.mjs */ "./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs");








let UID = 0;
const nameCache = {};
const _Program = class {
  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {
    this.extra = {};
    this.id = UID++;
    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    this.extra = extra;
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name = name.replace(/\s+/g, "-");
      if (nameCache[name]) {
        nameCache[name]++;
        name += `-${nameCache[name]}`;
      } else {
        nameCache[name] = 1;
      }
      this.vertexSrc = `#define SHADER_NAME ${name}
${this.vertexSrc}`;
      this.fragmentSrc = `#define SHADER_NAME ${name}
${this.fragmentSrc}`;
      this.vertexSrc = (0,_utils_setPrecision_mjs__WEBPACK_IMPORTED_MODULE_5__.setPrecision)(this.vertexSrc, _Program.defaultVertexPrecision, _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.HIGH);
      this.fragmentSrc = (0,_utils_setPrecision_mjs__WEBPACK_IMPORTED_MODULE_5__.setPrecision)(this.fragmentSrc, _Program.defaultFragmentPrecision, (0,_utils_getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_6__.getMaxFragmentPrecision)());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  static get defaultVertexSrc() {
    return _defaultProgram2_mjs__WEBPACK_IMPORTED_MODULE_3__["default"];
  }
  static get defaultFragmentSrc() {
    return _defaultProgram_mjs__WEBPACK_IMPORTED_MODULE_2__["default"];
  }
  static from(vertexSrc, fragmentSrc, name) {
    const key = vertexSrc + fragmentSrc;
    let program = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.ProgramCache[key];
    if (!program) {
      _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);
    }
    return program;
  }
};
let Program = _Program;
Program.defaultVertexPrecision = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.HIGH;
Program.defaultFragmentPrecision = _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.isMobile.apple.device ? _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.HIGH : _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.MEDIUM;


//# sourceMappingURL=Program.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/Shader.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/Shader.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Shader": function() { return /* binding */ Shader; }
/* harmony export */ });
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");
/* harmony import */ var _Program_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Program.mjs */ "./node_modules/@pixi/core/lib/shader/Program.mjs");
/* harmony import */ var _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UniformGroup.mjs */ "./node_modules/@pixi/core/lib/shader/UniformGroup.mjs");




class Shader {
  constructor(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new _UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_2__.UniformGroup({});
    }
    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner("disposeShader");
  }
  checkUniformExists(name, group) {
    if (group.uniforms[name]) {
      return true;
    }
    for (const i in group.uniforms) {
      const uniform = group.uniforms[i];
      if (uniform.group) {
        if (this.checkUniformExists(name, uniform)) {
          return true;
        }
      }
    }
    return false;
  }
  destroy() {
    this.uniformGroup = null;
    this.disposeRunner.emit(this);
    this.disposeRunner.destroy();
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(vertexSrc, fragmentSrc, uniforms) {
    const program = _Program_mjs__WEBPACK_IMPORTED_MODULE_1__.Program.from(vertexSrc, fragmentSrc);
    return new Shader(program, uniforms);
  }
}


//# sourceMappingURL=Shader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderSystem": function() { return /* binding */ ShaderSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/core/lib/shader/utils/index.mjs");
/* harmony import */ var _utils_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/generateProgram.mjs */ "./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs");
/* harmony import */ var _utils_generateUniformBufferSync_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/generateUniformBufferSync.mjs */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs");
/* harmony import */ var _utils_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/unsafeEvalSupported.mjs */ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs");
/* harmony import */ var _utils_generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/generateUniformsSync.mjs */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs");







let UID = 0;
const defaultSyncData = { textureCount: 0, uboCount: 0 };
class ShaderSystem {
  constructor(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID++;
  }
  systemCheck() {
    if (!(0,_utils_unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_4__.unsafeEvalSupported)()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.reset();
  }
  bind(shader, dontSync) {
    shader.disposeRunner.add(this);
    shader.uniforms.globals = this.renderer.globalUniforms;
    const program = shader.program;
    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  }
  setUniforms(uniforms) {
    const shader = this.shader.program;
    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  }
  syncUniformGroup(group, syncData) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  }
  syncUniforms(group, glProgram, syncData) {
    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  }
  createSyncGroups(group) {
    const id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = (0,_utils_generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_5__.generateUniformsSync)(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  }
  syncUniformBufferGroup(group, name) {
    const glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
  }
  createSyncBufferGroup(group, glProgram, name) {
    const { gl } = this.renderer;
    this.renderer.buffer.bind(group.buffer);
    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    let uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = (0,_utils_generateUniformBufferSync_mjs__WEBPACK_IMPORTED_MODULE_3__.generateUniformBufferSync)(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      const data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  }
  getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  }
  getGlProgram() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  }
  generateProgram(shader) {
    const gl = this.gl;
    const program = shader.program;
    const glProgram = (0,_utils_generateProgram_mjs__WEBPACK_IMPORTED_MODULE_2__.generateProgram)(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  }
  reset() {
    this.program = null;
    this.shader = null;
  }
  disposeShader(shader) {
    if (this.shader === shader) {
      this.shader = null;
    }
  }
  destroy() {
    this.renderer = null;
    this.destroyed = true;
  }
}
ShaderSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "shader"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(ShaderSystem);


//# sourceMappingURL=ShaderSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/UniformGroup.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/UniformGroup.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UniformGroup": function() { return /* binding */ UniformGroup; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Buffer.mjs */ "./node_modules/@pixi/core/lib/geometry/Buffer.mjs");



let UID = 0;
class UniformGroup {
  constructor(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer) {
      this.buffer = uniforms;
      this.buffer.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_1__.Buffer(new Float32Array(1));
        this.buffer.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BUFFER_TYPE.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  update() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  }
  add(name, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name] = new UniformGroup(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  }
  static from(uniforms, _static, _ubo) {
    return new UniformGroup(uniforms, _static, _ubo);
  }
  static uboFrom(uniforms, _static) {
    return new UniformGroup(uniforms, _static ?? true, true);
  }
}


//# sourceMappingURL=UniformGroup.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/defaultProgram.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/defaultProgram.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ defaultFragment; }
/* harmony export */ });
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";


//# sourceMappingURL=defaultProgram.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/defaultProgram2.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/defaultProgram2.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ defaultVertex; }
/* harmony export */ });
var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";


//# sourceMappingURL=defaultProgram2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkMaxIfStatementsInShader": function() { return /* binding */ checkMaxIfStatementsInShader; }
/* harmony export */ });
const fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += `if(test == ${i}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}


//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compileShader": function() { return /* binding */ compileShader; }
/* harmony export */ });
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}


//# sourceMappingURL=compileShader.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultValue": function() { return /* binding */ defaultValue; }
/* harmony export */ });
function booleanArray(size) {
  const array = new Array(size);
  for (let i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}


//# sourceMappingURL=defaultValue.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateProgram": function() { return /* binding */ generateProgram; }
/* harmony export */ });
/* harmony import */ var _GLProgram_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GLProgram.mjs */ "./node_modules/@pixi/core/lib/shader/GLProgram.mjs");
/* harmony import */ var _compileShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compileShader.mjs */ "./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs");
/* harmony import */ var _defaultValue_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaultValue.mjs */ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs");
/* harmony import */ var _getAttributeData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getAttributeData.mjs */ "./node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs");
/* harmony import */ var _getUniformData_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getUniformData.mjs */ "./node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs");
/* harmony import */ var _logProgramError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logProgramError.mjs */ "./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs");







function generateProgram(gl, program) {
  const glVertShader = (0,_compileShader_mjs__WEBPACK_IMPORTED_MODULE_1__.compileShader)(gl, gl.VERTEX_SHADER, program.vertexSrc);
  const glFragShader = (0,_compileShader_mjs__WEBPACK_IMPORTED_MODULE_1__.compileShader)(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    (0,_logProgramError_mjs__WEBPACK_IMPORTED_MODULE_5__.logProgramError)(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = (0,_getAttributeData_mjs__WEBPACK_IMPORTED_MODULE_3__.getAttributeData)(webGLProgram, gl);
  program.uniformData = (0,_getUniformData_mjs__WEBPACK_IMPORTED_MODULE_4__.getUniformData)(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    const keys = Object.keys(program.attributeData);
    keys.sort((a, b) => a > b ? 1 : -1);
    for (let i = 0; i < keys.length; i++) {
      program.attributeData[keys[i]].location = i;
      gl.bindAttribLocation(webGLProgram, i, keys[i]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program.uniformData) {
    const data = program.uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: (0,_defaultValue_mjs__WEBPACK_IMPORTED_MODULE_2__.defaultValue)(data.type, data.size)
    };
  }
  const glProgram = new _GLProgram_mjs__WEBPACK_IMPORTED_MODULE_0__.GLProgram(webGLProgram, uniformData);
  return glProgram;
}


//# sourceMappingURL=generateProgram.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createUBOElements": function() { return /* binding */ createUBOElements; },
/* harmony export */   "generateUniformBufferSync": function() { return /* binding */ generateUniformBufferSync; },
/* harmony export */   "getUBOData": function() { return /* binding */ getUBOData; }
/* harmony export */ });
/* harmony import */ var _index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.mjs */ "./node_modules/@pixi/core/lib/shader/utils/index.mjs");
/* harmony import */ var _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniformParsers.mjs */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs");
/* harmony import */ var _mapSize_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mapSize.mjs */ "./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs");




function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
const UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
};
const GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    dataLen: 0,
    dirty: 0
  }));
  let size = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  const usedUniformDatas = [];
  for (const i in uniforms) {
    if (uniformData[i]) {
      usedUniformDatas.push(uniformData[i]);
    }
  }
  usedUniformDatas.sort((a, b) => a.index - b.index);
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  const usedUniformDatas = getUBOData(group.uniforms, uniformData);
  const { uboElements, size } = createUBOElements(usedUniformDatas);
  const funcFragments = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    const uniform = group.uniforms[uboElement.data.name];
    const name = uboElement.data.name;
    let parsed = false;
    for (let j = 0; j < _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_1__.uniformParsers.length; j++) {
      const uniformParser = _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_1__.uniformParsers[j];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push(`offset = ${uboElement.offset / 4};`, _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_1__.uniformParsers[j].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        const size2 = (0,_mapSize_mjs__WEBPACK_IMPORTED_MODULE_2__.mapSize)(uboElement.data.type);
        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        const elementSize = size2 / rowSize;
        const remainder = (4 - elementSize % 4) % 4;
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
                {
                    for(var j = 0; j < ${elementSize}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${remainder};
                }

                `);
      } else {
        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${template};
                `);
      }
    }
  }
  funcFragments.push(`
       renderer.buffer.update(buffer);
    `);
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}


//# sourceMappingURL=generateUniformBufferSync.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateUniformsSync": function() { return /* binding */ generateUniformsSync; }
/* harmony export */ });
/* harmony import */ var _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniformParsers.mjs */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs");


const GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
};
const GLSL_TO_ARRAY_SETTERS = {
  float: `gl.uniform1fv(location, v)`,
  vec2: `gl.uniform2fv(location, v)`,
  vec3: `gl.uniform3fv(location, v)`,
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (const i in group.uniforms) {
    const data = uniformData[i];
    if (!data) {
      if (group.uniforms[i]?.group) {
        if (group.uniforms[i].ubo) {
          funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `);
        }
      }
      continue;
    }
    const uniform = group.uniforms[i];
    let parsed = false;
    for (let j = 0; j < _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniformParsers.length; j++) {
      if (_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniformParsers[j].test(data, uniform)) {
        funcFragments.push(_uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_0__.uniformParsers[j].code(i, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      const template = templateType[data.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}


//# sourceMappingURL=generateUniformsSync.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAttributeData": function() { return /* binding */ getAttributeData; }
/* harmony export */ });
/* harmony import */ var _mapSize_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mapSize.mjs */ "./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs");
/* harmony import */ var _mapType_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapType.mjs */ "./node_modules/@pixi/core/lib/shader/utils/mapType.mjs");



function getAttributeData(program, gl) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const type = (0,_mapType_mjs__WEBPACK_IMPORTED_MODULE_1__.mapType)(gl, attribData.type);
    const data = {
      type,
      name: attribData.name,
      size: (0,_mapSize_mjs__WEBPACK_IMPORTED_MODULE_0__.mapSize)(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}


//# sourceMappingURL=getAttributeData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getMaxFragmentPrecision": function() { return /* binding */ getMaxFragmentPrecision; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _getTestContext_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getTestContext.mjs */ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs");



let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.MEDIUM;
    const gl = (0,_getTestContext_mjs__WEBPACK_IMPORTED_MODULE_1__.getTestContext)();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.HIGH : _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}


//# sourceMappingURL=getMaxFragmentPrecision.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTestContext": function() { return /* binding */ getTestContext; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");



const unknownContext = {};
let context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context?.isContextLost()) {
    const canvas = _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.createCanvas();
    let gl;
    if (_pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.PREFER_ENV >= _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ENV.WEBGL2) {
      gl = canvas.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}


//# sourceMappingURL=getTestContext.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUniformData": function() { return /* binding */ getUniformData; }
/* harmony export */ });
/* harmony import */ var _defaultValue_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultValue.mjs */ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs");
/* harmony import */ var _mapType_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapType.mjs */ "./node_modules/@pixi/core/lib/shader/utils/mapType.mjs");



function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = (0,_mapType_mjs__WEBPACK_IMPORTED_MODULE_1__.mapType)(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: (0,_defaultValue_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultValue)(type, uniformData.size)
    };
  }
  return uniforms;
}


//# sourceMappingURL=getUniformData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkMaxIfStatementsInShader": function() { return /* reexport safe */ _checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_0__.checkMaxIfStatementsInShader; },
/* harmony export */   "compileShader": function() { return /* reexport safe */ _compileShader_mjs__WEBPACK_IMPORTED_MODULE_1__.compileShader; },
/* harmony export */   "defaultValue": function() { return /* reexport safe */ _defaultValue_mjs__WEBPACK_IMPORTED_MODULE_2__.defaultValue; },
/* harmony export */   "generateUniformsSync": function() { return /* reexport safe */ _generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_3__.generateUniformsSync; },
/* harmony export */   "getMaxFragmentPrecision": function() { return /* reexport safe */ _getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_4__.getMaxFragmentPrecision; },
/* harmony export */   "getTestContext": function() { return /* reexport safe */ _getTestContext_mjs__WEBPACK_IMPORTED_MODULE_5__.getTestContext; },
/* harmony export */   "logProgramError": function() { return /* reexport safe */ _logProgramError_mjs__WEBPACK_IMPORTED_MODULE_6__.logProgramError; },
/* harmony export */   "mapSize": function() { return /* reexport safe */ _mapSize_mjs__WEBPACK_IMPORTED_MODULE_7__.mapSize; },
/* harmony export */   "mapType": function() { return /* reexport safe */ _mapType_mjs__WEBPACK_IMPORTED_MODULE_8__.mapType; },
/* harmony export */   "setPrecision": function() { return /* reexport safe */ _setPrecision_mjs__WEBPACK_IMPORTED_MODULE_9__.setPrecision; },
/* harmony export */   "uniformParsers": function() { return /* reexport safe */ _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_10__.uniformParsers; },
/* harmony export */   "unsafeEvalSupported": function() { return /* reexport safe */ _unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_11__.unsafeEvalSupported; }
/* harmony export */ });
/* harmony import */ var _checkMaxIfStatementsInShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./checkMaxIfStatementsInShader.mjs */ "./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs");
/* harmony import */ var _compileShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compileShader.mjs */ "./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs");
/* harmony import */ var _defaultValue_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaultValue.mjs */ "./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs");
/* harmony import */ var _generateUniformsSync_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generateUniformsSync.mjs */ "./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs");
/* harmony import */ var _getMaxFragmentPrecision_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getMaxFragmentPrecision.mjs */ "./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs");
/* harmony import */ var _getTestContext_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getTestContext.mjs */ "./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs");
/* harmony import */ var _logProgramError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./logProgramError.mjs */ "./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs");
/* harmony import */ var _mapSize_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mapSize.mjs */ "./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs");
/* harmony import */ var _mapType_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mapType.mjs */ "./node_modules/@pixi/core/lib/shader/utils/mapType.mjs");
/* harmony import */ var _setPrecision_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./setPrecision.mjs */ "./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs");
/* harmony import */ var _uniformParsers_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./uniformParsers.mjs */ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs");
/* harmony import */ var _unsafeEvalSupported_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./unsafeEvalSupported.mjs */ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs");












//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "logProgramError": function() { return /* binding */ logProgramError; }
/* harmony export */ });
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}


//# sourceMappingURL=logProgramError.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapSize": function() { return /* binding */ mapSize; }
/* harmony export */ });
const GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}


//# sourceMappingURL=mapSize.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/mapType.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/mapType.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapType": function() { return /* binding */ mapType; }
/* harmony export */ });
let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}


//# sourceMappingURL=mapType.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setPrecision": function() { return /* binding */ setPrecision; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    let precision = requestedPrecision;
    if (requestedPrecision === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.HIGH && maxSupportedPrecision !== _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.HIGH) {
      precision = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.MEDIUM;
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.PRECISION.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}


//# sourceMappingURL=setPrecision.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uniformParsers": function() { return /* binding */ uniformParsers; }
/* harmony export */ });
const uniformParsers = [
  {
    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,
    code: (name) => `
            if(uv["${name}"] !== ud["${name}"].value)
            {
                ud["${name}"].value = uv["${name}"]
                gl.uniform1f(ud["${name}"].location, uv["${name}"])
            }
            `
  },
  {
    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),
    code: (name) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${name}"], t);

            if(ud["${name}"].value !== t)
            {
                ud["${name}"].value = t;
                gl.uniform1i(ud["${name}"].location, t);
; // eslint-disable-line max-len
            }`
  },
  {
    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,
    code: (name) => `
            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));
            `,
    codeUbo: (name) => `
                var ${name}_matrix = uv.${name}.toArray(true);

                data[offset] = ${name}_matrix[0];
                data[offset+1] = ${name}_matrix[1];
                data[offset+2] = ${name}_matrix[2];
        
                data[offset + 4] = ${name}_matrix[3];
                data[offset + 5] = ${name}_matrix[4];
                data[offset + 6] = ${name}_matrix[5];
        
                data[offset + 8] = ${name}_matrix[6];
                data[offset + 9] = ${name}_matrix[7];
                data[offset + 10] = ${name}_matrix[8];
            `
  },
  {
    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${name}"].location, v.x, v.y);
                }`,
    codeUbo: (name) => `
                v = uv.${name};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
  },
  {
    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);
                }
            `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
  },
  {
    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
  },
  {
    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)
                }`,
    codeUbo: (name) => `
                    v = uv.${name};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
  },
  {
    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,
    code: (name) => `
                cv = ud["${name}"].value;
                v = uv["${name}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])
                }`
  }
];


//# sourceMappingURL=uniformParsers.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unsafeEvalSupported": function() { return /* binding */ unsafeEvalSupported; }
/* harmony export */ });
let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}


//# sourceMappingURL=unsafeEvalSupported.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/startup/StartupSystem.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/startup/StartupSystem.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StartupSystem": function() { return /* binding */ StartupSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");


class StartupSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  run(options) {
    const { renderer } = this;
    renderer.runners.init.emit(renderer.options);
    if (options.hello) {
      console.log(`PixiJS ${"7.2.4"} - ${renderer.rendererLogId} - https://pixijs.com`);
    }
    renderer.resize(renderer.screen.width, renderer.screen.height);
  }
  destroy() {
  }
}
StartupSystem.defaultOptions = {
  hello: false
};
StartupSystem.extension = {
  type: [
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasRendererSystem
  ],
  name: "startup"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(StartupSystem);


//# sourceMappingURL=StartupSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/State.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/State.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "State": function() { return /* binding */ State; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
class State {
  constructor() {
    this.data = 0;
    this.blendMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND) !== value) {
      this.data ^= 1 << BLEND;
    }
  }
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET) !== value) {
      this.data ^= 1 << OFFSET;
    }
  }
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING) !== value) {
      this.data ^= 1 << CULLING;
    }
  }
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING) !== value) {
      this.data ^= 1 << WINDING;
    }
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NONE;
    this._blendMode = value;
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  static for2d() {
    const state = new State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
}


//# sourceMappingURL=State.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/StateSystem.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/StateSystem.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateSystem": function() { return /* binding */ StateSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _State_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./State.mjs */ "./node_modules/@pixi/core/lib/state/State.mjs");
/* harmony import */ var _utils_mapWebGLBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mapWebGLBlendModesToPixi.mjs */ "./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs");





const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _StateSystem = class {
  constructor() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new _State_mjs__WEBPACK_IMPORTED_MODULE_2__.State();
    this.defaultState.blend = true;
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModes = (0,_utils_mapWebGLBlendModesToPixi_mjs__WEBPACK_IMPORTED_MODULE_3__.mapWebGLBlendModesToPixi)(gl);
    this.set(this.defaultState);
    this.reset();
  }
  set(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff = diff >> 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  }
  forceState(state) {
    state = state || this.defaultState;
    for (let i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  }
  setBlend(value) {
    this.updateCheck(_StateSystem.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  setOffset(value) {
    this.updateCheck(_StateSystem.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  setCullFace(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  }
  setFrontFace(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  }
  setBlendMode(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModes[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  reset() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  }
  updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  }
  static checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  static checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  destroy() {
    this.gl = null;
  }
};
let StateSystem = _StateSystem;
StateSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "state"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(StateSystem);


//# sourceMappingURL=StateSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapWebGLBlendModesToPixi": function() { return /* binding */ mapWebGLBlendModesToPixi; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


function mapWebGLBlendModesToPixi(gl, array = []) {
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.ADD] = [gl.ONE, gl.ONE];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NONE] = [0, 0];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}


//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/system/ISystem.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/system/ISystem.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=ISystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/system/SystemManager.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/system/SystemManager.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemManager": function() { return /* binding */ SystemManager; }
/* harmony export */ });
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");



class SystemManager extends _pixi_utils__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {
  constructor() {
    super(...arguments);
    this.runners = {};
    this._systemsHash = {};
  }
  setup(config) {
    this.addRunners(...config.runners);
    const priority = (config.priority ?? []).filter((key) => config.systems[key]);
    const orderByPriority = [
      ...priority,
      ...Object.keys(config.systems).filter((key) => !priority.includes(key))
    ];
    for (const i of orderByPriority) {
      this.addSystem(config.systems[i], i);
    }
  }
  addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner(runnerId);
    });
  }
  addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  }
  emitWithCustomOptions(runner, options) {
    const systemHashKeys = Object.keys(this._systemsHash);
    runner.items.forEach((system) => {
      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);
      system[runner.name](options[systemName]);
    });
  }
  destroy() {
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = {};
  }
}


//# sourceMappingURL=SystemManager.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/systems.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/core/lib/systems.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundSystem": function() { return /* reexport safe */ _background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_0__.BackgroundSystem; },
/* harmony export */   "BatchSystem": function() { return /* reexport safe */ _batch_BatchSystem_mjs__WEBPACK_IMPORTED_MODULE_1__.BatchSystem; },
/* harmony export */   "ContextSystem": function() { return /* reexport safe */ _context_ContextSystem_mjs__WEBPACK_IMPORTED_MODULE_2__.ContextSystem; },
/* harmony export */   "FilterSystem": function() { return /* reexport safe */ _filters_FilterSystem_mjs__WEBPACK_IMPORTED_MODULE_3__.FilterSystem; },
/* harmony export */   "FramebufferSystem": function() { return /* reexport safe */ _framebuffer_FramebufferSystem_mjs__WEBPACK_IMPORTED_MODULE_4__.FramebufferSystem; },
/* harmony export */   "GenerateTextureSystem": function() { return /* reexport safe */ _renderTexture_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_11__.GenerateTextureSystem; },
/* harmony export */   "GeometrySystem": function() { return /* reexport safe */ _geometry_GeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_5__.GeometrySystem; },
/* harmony export */   "MaskSystem": function() { return /* reexport safe */ _mask_MaskSystem_mjs__WEBPACK_IMPORTED_MODULE_6__.MaskSystem; },
/* harmony export */   "PluginSystem": function() { return /* reexport safe */ _plugin_PluginSystem_mjs__WEBPACK_IMPORTED_MODULE_9__.PluginSystem; },
/* harmony export */   "ProjectionSystem": function() { return /* reexport safe */ _projection_ProjectionSystem_mjs__WEBPACK_IMPORTED_MODULE_10__.ProjectionSystem; },
/* harmony export */   "RenderTextureSystem": function() { return /* reexport safe */ _renderTexture_RenderTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_12__.RenderTextureSystem; },
/* harmony export */   "ScissorSystem": function() { return /* reexport safe */ _mask_ScissorSystem_mjs__WEBPACK_IMPORTED_MODULE_7__.ScissorSystem; },
/* harmony export */   "ShaderSystem": function() { return /* reexport safe */ _shader_ShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_13__.ShaderSystem; },
/* harmony export */   "StartupSystem": function() { return /* reexport safe */ _startup_StartupSystem_mjs__WEBPACK_IMPORTED_MODULE_14__.StartupSystem; },
/* harmony export */   "StateSystem": function() { return /* reexport safe */ _state_StateSystem_mjs__WEBPACK_IMPORTED_MODULE_15__.StateSystem; },
/* harmony export */   "StencilSystem": function() { return /* reexport safe */ _mask_StencilSystem_mjs__WEBPACK_IMPORTED_MODULE_8__.StencilSystem; },
/* harmony export */   "SystemManager": function() { return /* reexport safe */ _system_SystemManager_mjs__WEBPACK_IMPORTED_MODULE_16__.SystemManager; },
/* harmony export */   "TextureGCSystem": function() { return /* reexport safe */ _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_17__.TextureGCSystem; },
/* harmony export */   "TextureSystem": function() { return /* reexport safe */ _textures_TextureSystem_mjs__WEBPACK_IMPORTED_MODULE_18__.TextureSystem; },
/* harmony export */   "TransformFeedbackSystem": function() { return /* reexport safe */ _transformFeedback_TransformFeedbackSystem_mjs__WEBPACK_IMPORTED_MODULE_19__.TransformFeedbackSystem; },
/* harmony export */   "ViewSystem": function() { return /* reexport safe */ _view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_20__.ViewSystem; }
/* harmony export */ });
/* harmony import */ var _background_BackgroundSystem_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./background/BackgroundSystem.mjs */ "./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs");
/* harmony import */ var _batch_BatchSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./batch/BatchSystem.mjs */ "./node_modules/@pixi/core/lib/batch/BatchSystem.mjs");
/* harmony import */ var _context_ContextSystem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./context/ContextSystem.mjs */ "./node_modules/@pixi/core/lib/context/ContextSystem.mjs");
/* harmony import */ var _filters_FilterSystem_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filters/FilterSystem.mjs */ "./node_modules/@pixi/core/lib/filters/FilterSystem.mjs");
/* harmony import */ var _framebuffer_FramebufferSystem_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./framebuffer/FramebufferSystem.mjs */ "./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs");
/* harmony import */ var _geometry_GeometrySystem_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geometry/GeometrySystem.mjs */ "./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs");
/* harmony import */ var _mask_MaskSystem_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mask/MaskSystem.mjs */ "./node_modules/@pixi/core/lib/mask/MaskSystem.mjs");
/* harmony import */ var _mask_ScissorSystem_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mask/ScissorSystem.mjs */ "./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs");
/* harmony import */ var _mask_StencilSystem_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mask/StencilSystem.mjs */ "./node_modules/@pixi/core/lib/mask/StencilSystem.mjs");
/* harmony import */ var _plugin_PluginSystem_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./plugin/PluginSystem.mjs */ "./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs");
/* harmony import */ var _projection_ProjectionSystem_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./projection/ProjectionSystem.mjs */ "./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs");
/* harmony import */ var _renderTexture_GenerateTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./renderTexture/GenerateTextureSystem.mjs */ "./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs");
/* harmony import */ var _renderTexture_RenderTextureSystem_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./renderTexture/RenderTextureSystem.mjs */ "./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs");
/* harmony import */ var _shader_ShaderSystem_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./shader/ShaderSystem.mjs */ "./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs");
/* harmony import */ var _startup_StartupSystem_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./startup/StartupSystem.mjs */ "./node_modules/@pixi/core/lib/startup/StartupSystem.mjs");
/* harmony import */ var _state_StateSystem_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./state/StateSystem.mjs */ "./node_modules/@pixi/core/lib/state/StateSystem.mjs");
/* harmony import */ var _system_SystemManager_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./system/SystemManager.mjs */ "./node_modules/@pixi/core/lib/system/SystemManager.mjs");
/* harmony import */ var _textures_TextureGCSystem_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textures/TextureGCSystem.mjs */ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs");
/* harmony import */ var _textures_TextureSystem_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./textures/TextureSystem.mjs */ "./node_modules/@pixi/core/lib/textures/TextureSystem.mjs");
/* harmony import */ var _transformFeedback_TransformFeedbackSystem_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./transformFeedback/TransformFeedbackSystem.mjs */ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs");
/* harmony import */ var _view_ViewSystem_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./view/ViewSystem.mjs */ "./node_modules/@pixi/core/lib/view/ViewSystem.mjs");





















//# sourceMappingURL=systems.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/BaseTexture.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTexture": function() { return /* binding */ BaseTexture; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _resources_autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources/autoDetectResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs");
/* harmony import */ var _resources_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resources/BufferResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs");
/* harmony import */ var _resources_Resource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resources/Resource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/Resource.mjs");







const defaultBufferOptions = {
  scaleMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.NEAREST,
  format: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA,
  alphaMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.NPM
};
const _BaseTexture = class extends _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {
  constructor(resource = null, options = null) {
    super();
    options = Object.assign({}, _BaseTexture.defaultOptions, options);
    const {
      alphaMode,
      mipmap,
      anisotropicLevel,
      scaleMode,
      width,
      height,
      wrapMode,
      format,
      type,
      target,
      resolution,
      resourceOptions
    } = options;
    if (resource && !(resource instanceof _resources_Resource_mjs__WEBPACK_IMPORTED_MODULE_5__.Resource)) {
      resource = (0,_resources_autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_3__.autoDetectResource)(resource, resourceOptions);
      resource.internal = true;
    }
    this.resolution = resolution || _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.RESOLUTION;
    this.width = Math.round((width || 0) * this.resolution) / this.resolution;
    this.height = Math.round((height || 0) * this.resolution) / this.resolution;
    this._mipmap = mipmap;
    this.anisotropicLevel = anisotropicLevel;
    this._wrapMode = wrapMode;
    this._scaleMode = scaleMode;
    this.format = format;
    this.type = type;
    this.target = target;
    this.alphaMode = alphaMode;
    this.uid = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.uid)();
    this.touched = 0;
    this.isPowerOfTwo = false;
    this._refreshPOT();
    this._glTextures = {};
    this.dirtyId = 0;
    this.dirtyStyleId = 0;
    this.cacheId = null;
    this.valid = width > 0 && height > 0;
    this.textureCacheIds = [];
    this.destroyed = false;
    this.resource = null;
    this._batchEnabled = 0;
    this._batchLocation = 0;
    this.parentTextureArray = null;
    this.setResource(resource);
  }
  get realWidth() {
    return Math.round(this.width * this.resolution);
  }
  get realHeight() {
    return Math.round(this.height * this.resolution);
  }
  get mipmap() {
    return this._mipmap;
  }
  set mipmap(value) {
    if (this._mipmap !== value) {
      this._mipmap = value;
      this.dirtyStyleId++;
    }
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleMode(value) {
    if (this._scaleMode !== value) {
      this._scaleMode = value;
      this.dirtyStyleId++;
    }
  }
  get wrapMode() {
    return this._wrapMode;
  }
  set wrapMode(value) {
    if (this._wrapMode !== value) {
      this._wrapMode = value;
      this.dirtyStyleId++;
    }
  }
  setStyle(scaleMode, mipmap) {
    let dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  }
  setSize(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  }
  setRealSize(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  }
  _refreshPOT() {
    this.isPowerOfTwo = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.isPow2)(this.realWidth) && (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.isPow2)(this.realHeight);
  }
  setResolution(resolution) {
    const oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  }
  setResource(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  }
  update() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  }
  onError(event) {
    this.emit("error", this, event);
  }
  destroy() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[this.cacheId];
      delete _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    _BaseTexture.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  }
  dispose() {
    this.emit("dispose", this);
  }
  castToBaseTexture() {
    return this;
  }
  static from(source, options, strict = _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${(0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.uid)()}`;
      }
      cacheId = source._pixiId;
    }
    let baseTexture = _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
    }
    if (!baseTexture) {
      baseTexture = new _BaseTexture(source, options);
      baseTexture.cacheId = cacheId;
      _BaseTexture.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  }
  static fromBuffer(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    const resource = new _resources_BufferResource_mjs__WEBPACK_IMPORTED_MODULE_4__.BufferResource(buffer, { width, height });
    const type = buffer instanceof Float32Array ? _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT : _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE;
    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options));
  }
  static addToCache(baseTexture, id) {
    if (id) {
      if (!baseTexture.textureCacheIds.includes(id)) {
        baseTexture.textureCacheIds.push(id);
      }
      if (_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[id] && _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[id] !== baseTexture) {
        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);
      }
      _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[id] = baseTexture;
    }
  }
  static removeFromCache(baseTexture) {
    if (typeof baseTexture === "string") {
      const baseTextureFromCache = _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index > -1) {
          baseTextureFromCache.textureCacheIds.splice(index, 1);
        }
        delete _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture?.textureCacheIds) {
      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {
        delete _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.BaseTextureCache[baseTexture.textureCacheIds[i]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  }
};
let BaseTexture = _BaseTexture;
BaseTexture.defaultOptions = {
  mipmap: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MIPMAP_MODES.POW2,
  anisotropicLevel: 0,
  scaleMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.LINEAR,
  wrapMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.CLAMP,
  alphaMode: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.UNPACK,
  target: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TARGETS.TEXTURE_2D,
  format: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA,
  type: _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE
};
BaseTexture._globalBatch = 0;


//# sourceMappingURL=BaseTexture.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/GLTexture.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/GLTexture.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GLTexture": function() { return /* binding */ GLTexture; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


class GLTexture {
  constructor(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE;
    this.internalFormat = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA;
    this.samplerType = 0;
  }
}


//# sourceMappingURL=GLTexture.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/Texture.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/Texture.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Texture": function() { return /* binding */ Texture; }
/* harmony export */ });
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");
/* harmony import */ var _resources_ImageResource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resources/ImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs");
/* harmony import */ var _TextureUvs_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TextureUvs.mjs */ "./node_modules/@pixi/core/lib/textures/TextureUvs.mjs");







const DEFAULT_UVS = new _TextureUvs_mjs__WEBPACK_IMPORTED_MODULE_5__.TextureUvs();
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
class Texture extends _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {
  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
    super();
    this.noFrame = false;
    if (!frame) {
      this.noFrame = true;
      frame = new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture) {
      baseTexture = baseTexture.baseTexture;
    }
    this.baseTexture = baseTexture;
    this._frame = frame;
    this.trim = trim;
    this.valid = false;
    this._uvs = DEFAULT_UVS;
    this.uvMatrix = null;
    this.orig = orig || frame;
    this._rotate = Number(rotate || 0);
    if (rotate === true) {
      this._rotate = 2;
    } else if (this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    this.defaultAnchor = anchor ? new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Point(anchor.x, anchor.y) : new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
    this.defaultBorders = borders;
    this._updateID = 0;
    this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", this.onBaseTextureUpdated, this);
    } else if (this.noFrame) {
      if (baseTexture.valid) {
        this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      this.frame = frame;
    }
    if (this.noFrame) {
      baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
  }
  update() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  }
  onBaseTextureUpdated(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  }
  destroy(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        const { resource } = this.baseTexture;
        if (resource?.url && _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[resource.url]) {
          Texture.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture.removeFromCache(this);
    this.textureCacheIds = null;
  }
  clone() {
    const clonedFrame = this._frame.clone();
    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    const clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  }
  updateUvs() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new _TextureUvs_mjs__WEBPACK_IMPORTED_MODULE_5__.TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  }
  static from(source, options = {}, strict = _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.STRICT_TEXTURE_CACHE) {
    const isFrame = typeof source === "string";
    let cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture) {
      if (!source.cacheId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source.cacheId = `${prefix}-${(0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.uid)()}`;
        _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        const prefix = options?.pixiIdPrefix || "pixiid";
        source._pixiId = `${prefix}_${(0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.uid)()}`;
      }
      cacheId = source._pixiId;
    }
    let texture = _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
    }
    if (!texture && !(source instanceof _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture)) {
      if (!options.resolution) {
        options.resolution = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.getResolutionOfUrl)(source);
      }
      texture = new Texture(new _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture.addToCache(texture, cacheId);
    } else if (!texture && source instanceof _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture) {
      texture = new Texture(source);
      Texture.addToCache(texture, cacheId);
    }
    return texture;
  }
  static fromURL(url, options) {
    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);
    const texture = Texture.from(url, Object.assign({ resourceOptions }, options), false);
    const resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(() => Promise.resolve(texture));
  }
  static fromBuffer(buffer, width, height, options) {
    return new Texture(_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture.fromBuffer(buffer, width, height, options));
  }
  static fromLoader(source, imageUrl, name, options) {
    const baseTexture = new _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture(source, Object.assign({
      scaleMode: _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture.defaultOptions.scaleMode,
      resolution: (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.getResolutionOfUrl)(imageUrl)
    }, options));
    const { resource } = baseTexture;
    if (resource instanceof _resources_ImageResource_mjs__WEBPACK_IMPORTED_MODULE_4__.ImageResource) {
      resource.url = imageUrl;
    }
    const texture = new Texture(baseTexture);
    if (!name) {
      name = imageUrl;
    }
    _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    if (name !== imageUrl) {
      _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise((resolve) => {
      texture.baseTexture.once("loaded", () => resolve(texture));
    });
  }
  static addToCache(texture, id) {
    if (id) {
      if (!texture.textureCacheIds.includes(id)) {
        texture.textureCacheIds.push(id);
      }
      if (_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[id] && _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[id] !== texture) {
        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);
      }
      _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[id] = texture;
    }
  }
  static removeFromCache(texture) {
    if (typeof texture === "string") {
      const textureFromCache = _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[texture];
      if (textureFromCache) {
        const index = textureFromCache.textureCacheIds.indexOf(texture);
        if (index > -1) {
          textureFromCache.textureCacheIds.splice(index, 1);
        }
        delete _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture?.textureCacheIds) {
      for (let i = 0; i < texture.textureCacheIds.length; ++i) {
        if (_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[texture.textureCacheIds[i]] === texture) {
          delete _pixi_utils__WEBPACK_IMPORTED_MODULE_2__.TextureCache[texture.textureCacheIds[i]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(frame) {
    this._frame = frame;
    this.noFrame = false;
    const { x, y, width, height } = frame;
    const xNotFit = x + width > this.baseTexture.width;
    const yNotFit = y + height > this.baseTexture.height;
    if (xNotFit || yNotFit) {
      const relationship = xNotFit && yNotFit ? "and" : "or";
      const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;
      const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;
      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);
    }
    this.valid = width && height && this.baseTexture.valid;
    if (!this.trim && !this.rotate) {
      this.orig = frame;
    }
    if (this.valid) {
      this.updateUvs();
    }
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(rotate) {
    this._rotate = rotate;
    if (this.valid) {
      this.updateUvs();
    }
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    if (!Texture._EMPTY) {
      Texture._EMPTY = new Texture(new _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture());
      removeAllHandlers(Texture._EMPTY);
      removeAllHandlers(Texture._EMPTY.baseTexture);
    }
    return Texture._EMPTY;
  }
  static get WHITE() {
    if (!Texture._WHITE) {
      const canvas = _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.createCanvas(16, 16);
      const context = canvas.getContext("2d");
      canvas.width = 16;
      canvas.height = 16;
      context.fillStyle = "white";
      context.fillRect(0, 0, 16, 16);
      Texture._WHITE = new Texture(_BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture.from(canvas));
      removeAllHandlers(Texture._WHITE);
      removeAllHandlers(Texture._WHITE.baseTexture);
    }
    return Texture._WHITE;
  }
}


//# sourceMappingURL=Texture.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureGCSystem": function() { return /* binding */ TextureGCSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");



const _TextureGCSystem = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = _TextureGCSystem.defaultMaxIdle;
    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;
    this.mode = _TextureGCSystem.defaultMode;
  }
  postrender() {
    if (!this.renderer.objectRenderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.GC_MODES.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  }
  run() {
    const tm = this.renderer.texture;
    const managedTextures = tm.managedTextures;
    let wasRemoved = false;
    for (let i = 0; i < managedTextures.length; i++) {
      const texture = managedTextures[i];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      let j = 0;
      for (let i = 0; i < managedTextures.length; i++) {
        if (managedTextures[i] !== null) {
          managedTextures[j++] = managedTextures[i];
        }
      }
      managedTextures.length = j;
    }
  }
  unload(displayObject) {
    const tm = this.renderer.texture;
    const texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (let i = displayObject.children.length - 1; i >= 0; i--) {
      this.unload(displayObject.children[i]);
    }
  }
  destroy() {
    this.renderer = null;
  }
};
let TextureGCSystem = _TextureGCSystem;
TextureGCSystem.defaultMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.GC_MODES.AUTO;
TextureGCSystem.defaultMaxIdle = 60 * 60;
TextureGCSystem.defaultCheckCountMax = 60 * 10;
TextureGCSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "textureGC"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(TextureGCSystem);


//# sourceMappingURL=TextureGCSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureMatrix": function() { return /* binding */ TextureMatrix; }
/* harmony export */ });
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");


const tempMat = new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Matrix();
class TextureMatrix {
  constructor(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    this._texture = value;
    this._textureID = -1;
  }
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i = 0; i < uvs.length; i += 2) {
      const x = uvs[i];
      const y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  }
  update(forceUpdate) {
    const tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    const uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.baseTexture;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase.resolution;
    const offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}


//# sourceMappingURL=TextureMatrix.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureSystem.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureSystem.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureSystem": function() { return /* binding */ TextureSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");
/* harmony import */ var _GLTexture_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GLTexture.mjs */ "./node_modules/@pixi/core/lib/textures/GLTexture.mjs");
/* harmony import */ var _utils_mapTypeAndFormatToInternalFormat_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/mapTypeAndFormatToInternalFormat.mjs */ "./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs");







class TextureSystem {
  constructor(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_3__.BaseTexture();
    this.hasIntegerTextures = false;
  }
  contextChange() {
    const gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = (0,_utils_mapTypeAndFormatToInternalFormat_mjs__WEBPACK_IMPORTED_MODULE_5__.mapTypeAndFormatToInternalFormat)(gl);
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (let i = 0; i < maxTextures; i++) {
      this.boundTextures[i] = null;
    }
    this.emptyTextures = {};
    const emptyTexture2D = new _GLTexture_mjs__WEBPACK_IMPORTED_MODULE_4__.GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new _GLTexture_mjs__WEBPACK_IMPORTED_MODULE_4__.GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (let i = 0; i < 6; i++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.bind(null, i);
    }
  }
  bind(texture, location = 0) {
    const { gl } = this;
    texture = texture?.castToBaseTexture();
    if (texture?.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location] !== texture) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location) {
          this.currentLocation = location;
          gl.activeTexture(gl.TEXTURE0 + location);
        }
        this.updateTexture(texture);
      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {
        this.updateTextureStyle(texture);
      }
      this.boundTextures[location] = texture;
    } else {
      if (this.currentLocation !== location) {
        this.currentLocation = location;
        gl.activeTexture(gl.TEXTURE0 + location);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location] = null;
    }
  }
  reset() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (let i = 0; i < this.boundTextures.length; i++) {
      this.boundTextures[i] = this.unknownTexture;
    }
  }
  unbind(texture) {
    const { gl, boundTextures } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (let i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === this.unknownTexture) {
          this.bind(null, i);
        }
      }
    }
    for (let i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === texture) {
        if (this.currentLocation !== i) {
          gl.activeTexture(gl.TEXTURE0 + i);
          this.currentLocation = i;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i] = null;
      }
    }
  }
  ensureSamplerType(maxTextures) {
    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;
    if (!hasIntegerTextures) {
      return;
    }
    for (let i = maxTextures - 1; i >= 0; --i) {
      const tex = boundTextures[i];
      if (tex) {
        const glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SAMPLER_TYPES.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  }
  initTexture(texture) {
    const glTexture = new _GLTexture_mjs__WEBPACK_IMPORTED_MODULE_4__.GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  }
  initTextureType(texture, glTexture) {
    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;
    if (this.webGLVersion === 2 && texture.type === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  }
  updateTexture(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    const renderer = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource?.upload(renderer, texture, glTexture)) {
      if (glTexture.samplerType !== _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SAMPLER_TYPES.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      const width = texture.realWidth;
      const height = texture.realHeight;
      const gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  }
  destroyTexture(texture, skipRemove) {
    const { gl } = this;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        const i = this.managedTextures.indexOf(texture);
        if (i !== -1) {
          (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_2__.removeItems)(this.managedTextures, i, 1);
        }
      }
    }
  }
  updateTextureStyle(texture) {
    const glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource?.style(this.renderer, texture, glTexture)) {
    } else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  }
  setStyle(texture, glTexture) {
    const gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.MIPMAP_MODES.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.LINEAR) {
        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
  }
  destroy() {
    this.renderer = null;
  }
}
TextureSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.RendererSystem,
  name: "texture"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_1__.extensions.add(TextureSystem);


//# sourceMappingURL=TextureSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/TextureUvs.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/TextureUvs.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureUvs": function() { return /* binding */ TextureUvs; }
/* harmony export */ });
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");


class TextureUvs {
  constructor() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  set(frame, baseFrame, rotate) {
    const tw = baseFrame.width;
    const th = baseFrame.height;
    if (rotate) {
      const w2 = frame.width / 2 / tw;
      const h2 = frame.height / 2 / th;
      const cX = frame.x / tw + w2;
      const cY = frame.y / th + h2;
      rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.NW);
      this.x0 = cX + w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y0 = cY + h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
      rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, 2);
      this.x1 = cX + w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y1 = cY + h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
      rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, 2);
      this.x2 = cX + w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y2 = cY + h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
      rotate = _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.add(rotate, 2);
      this.x3 = cX + w2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uX(rotate);
      this.y3 = cY + h2 * _pixi_math__WEBPACK_IMPORTED_MODULE_0__.groupD8.uY(rotate);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  }
  toString() {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
  }
}


//# sourceMappingURL=TextureUvs.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractMultiResource": function() { return /* binding */ AbstractMultiResource; }
/* harmony export */ });
/* harmony import */ var _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BaseTexture.mjs */ "./node_modules/@pixi/core/lib/textures/BaseTexture.mjs");
/* harmony import */ var _autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./autoDetectResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs");
/* harmony import */ var _Resource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Resource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/Resource.mjs");




class AbstractMultiResource extends _Resource_mjs__WEBPACK_IMPORTED_MODULE_2__.Resource {
  constructor(length, options) {
    const { width, height } = options || {};
    super(width, height);
    this.items = [];
    this.itemDirtyIds = [];
    for (let i = 0; i < length; i++) {
      const partTexture = new _BaseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__.BaseTexture();
      this.items.push(partTexture);
      this.itemDirtyIds.push(-2);
    }
    this.length = length;
    this._load = null;
    this.baseTexture = null;
  }
  initFromArray(resources, options) {
    for (let i = 0; i < this.length; i++) {
      if (!resources[i]) {
        continue;
      }
      if (resources[i].castToBaseTexture) {
        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);
      } else if (resources[i] instanceof _Resource_mjs__WEBPACK_IMPORTED_MODULE_2__.Resource) {
        this.addResourceAt(resources[i], i);
      } else {
        this.addResourceAt((0,_autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_1__.autoDetectResource)(resources[i], options), i);
      }
    }
  }
  dispose() {
    for (let i = 0, len = this.length; i < len; i++) {
      this.items[i].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  }
  addResourceAt(resource, index) {
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index].setResource(resource);
    return this;
  }
  bind(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    super.bind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = baseTexture;
      this.items[i].on("update", baseTexture.update, baseTexture);
    }
  }
  unbind(baseTexture) {
    super.unbind(baseTexture);
    for (let i = 0; i < this.length; i++) {
      this.items[i].parentTextureArray = null;
      this.items[i].off("update", baseTexture.update, baseTexture);
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const resources = this.items.map((item) => item.resource).filter((item) => item);
    const promises = resources.map((item) => item.load());
    this._load = Promise.all(promises).then(() => {
      const { realWidth, realHeight } = this.items[0];
      this.resize(realWidth, realHeight);
      return Promise.resolve(this);
    });
    return this._load;
  }
}


//# sourceMappingURL=AbstractMultiResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArrayResource": function() { return /* binding */ ArrayResource; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractMultiResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs");



class ArrayResource extends _AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_1__.AbstractMultiResource {
  constructor(source, options) {
    const { width, height } = options || {};
    let urls;
    let length;
    if (Array.isArray(source)) {
      urls = source;
      length = source.length;
    } else {
      length = source;
    }
    super(length, { width, height });
    if (urls) {
      this.initFromArray(urls, options);
    }
  }
  addBaseTextureAt(baseTexture, index) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TARGETS.TEXTURE_2D_ARRAY;
  }
  upload(renderer, texture, glTexture) {
    const { length, itemDirtyIds, items } = this;
    const { gl } = renderer;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
    }
    for (let i = 0; i < length; i++) {
      const item = items[i];
      if (itemDirtyIds[i] < item.dirtyId) {
        itemDirtyIds[i] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  }
}


//# sourceMappingURL=ArrayResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseImageResource": function() { return /* binding */ BaseImageResource; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _Resource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Resource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/Resource.mjs");




class BaseImageResource extends _Resource_mjs__WEBPACK_IMPORTED_MODULE_2__.Resource {
  constructor(source) {
    const sourceAny = source;
    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    super(width, height);
    this.source = source;
    this.noSubImage = false;
  }
  static crossOrigin(element, url, crossorigin) {
    if (crossorigin === void 0 && !url.startsWith("data:")) {
      element.crossOrigin = (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.determineCrossOrigin)(url);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  }
  upload(renderer, baseTexture, glTexture, source) {
    const gl = renderer.gl;
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    source = source || this.source;
    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {
      if (source.readyState <= 1 && source.buffered.length === 0) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  }
  update() {
    if (this.destroyed) {
      return;
    }
    const source = this.source;
    const width = source.naturalWidth || source.videoWidth || source.width;
    const height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    super.update();
  }
  dispose() {
    this.source = null;
  }
}


//# sourceMappingURL=BaseImageResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BufferResource": function() { return /* binding */ BufferResource; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _Resource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Resource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/Resource.mjs");



class BufferResource extends _Resource_mjs__WEBPACK_IMPORTED_MODULE_1__.Resource {
  constructor(source, options) {
    const { width, height } = options || {};
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    super(width, height);
    this.data = source;
  }
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
  dispose() {
    this.data = null;
  }
  static test(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  }
}


//# sourceMappingURL=BufferResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasResource": function() { return /* binding */ CanvasResource; }
/* harmony export */ });
/* harmony import */ var _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs");


class CanvasResource extends _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_0__.BaseImageResource {
  constructor(source) {
    super(source);
  }
  static test(source) {
    const { OffscreenCanvas } = globalThis;
    if (OffscreenCanvas && source instanceof OffscreenCanvas) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  }
}


//# sourceMappingURL=CanvasResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CubeResource": function() { return /* binding */ CubeResource; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractMultiResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs");



const _CubeResource = class extends _AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_1__.AbstractMultiResource {
  constructor(source, options) {
    const { width, height, autoLoad, linkBaseTexture } = options || {};
    if (source && source.length !== _CubeResource.SIDES) {
      throw new Error(`Invalid length. Got ${source.length}, expected 6`);
    }
    super(6, { width, height });
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      this.items[i].target = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
    }
    this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      this.load();
    }
  }
  bind(baseTexture) {
    super.bind(baseTexture);
    baseTexture.target = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TARGETS.TEXTURE_CUBE_MAP;
  }
  addBaseTextureAt(baseTexture, index, linkBaseTexture) {
    if (linkBaseTexture === void 0) {
      linkBaseTexture = this.linkBaseTexture;
    }
    if (!this.items[index]) {
      throw new Error(`Index ${index} is out of bounds`);
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error(`CubeResource does not support copying of renderTexture.`);
      }
    } else {
      baseTexture.target = _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index] = baseTexture;
    return this;
  }
  upload(renderer, _baseTexture, glTexture) {
    const dirty = this.itemDirtyIds;
    for (let i = 0; i < _CubeResource.SIDES; i++) {
      const side = this.items[i];
      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i] = side.dirtyId;
        } else if (dirty[i] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i] = -1;
        }
      }
    }
    return true;
  }
  static test(source) {
    return Array.isArray(source) && source.length === _CubeResource.SIDES;
  }
};
let CubeResource = _CubeResource;
CubeResource.SIDES = 6;


//# sourceMappingURL=CubeResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/DepthResource.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/DepthResource.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DepthResource": function() { return /* binding */ DepthResource; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _BufferResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs");



class DepthResource extends _BufferResource_mjs__WEBPACK_IMPORTED_MODULE_1__.BufferResource {
  upload(renderer, baseTexture, glTexture) {
    const gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.UNPACK);
    const width = baseTexture.realWidth;
    const height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  }
}


//# sourceMappingURL=DepthResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageBitmapResource": function() { return /* binding */ ImageBitmapResource; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs");




class ImageBitmapResource extends _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    let baseSource;
    let url;
    if (typeof source === "string") {
      baseSource = ImageBitmapResource.EMPTY;
      url = source;
    } else {
      baseSource = source;
      url = null;
    }
    super(baseSource);
    this.url = url;
    this.crossOrigin = options.crossOrigin ?? true;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(async (resolve, reject) => {
      if (this.url === null) {
        resolve(this);
        return;
      }
      try {
        const response = await _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.fetch(this.url, {
          mode: this.crossOrigin ? "cors" : "no-cors"
        });
        if (this.destroyed)
          return;
        const imageBlob = await response.blob();
        if (this.destroyed)
          return;
        const imageBitmap = await createImageBitmap(imageBlob, {
          premultiplyAlpha: this.alphaMode === null || this.alphaMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
        if (this.destroyed)
          return;
        this.source = imageBitmap;
        this.update();
        resolve(this);
      } catch (e) {
        if (this.destroyed)
          return;
        reject(e);
        this.onError.emit(e);
      }
    });
    return this._load;
  }
  upload(renderer, baseTexture, glTexture) {
    if (!(this.source instanceof ImageBitmap)) {
      this.load();
      return false;
    }
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    return super.upload(renderer, baseTexture, glTexture);
  }
  dispose() {
    if (this.source instanceof ImageBitmap) {
      this.source.close();
    }
    super.dispose();
    this._load = null;
  }
  static test(source) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);
  }
  static get EMPTY() {
    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.createCanvas(0, 0);
    return ImageBitmapResource._EMPTY;
  }
}


//# sourceMappingURL=ImageBitmapResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageResource": function() { return /* binding */ ImageResource; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs");




class ImageResource extends _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (typeof source === "string") {
      const imageElement = new Image();
      _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    super(source);
    if (!source.complete && !!this._width && !!this._height) {
      this._width = 0;
      this._height = 0;
    }
    this.url = source.src;
    this._process = null;
    this.preserveBitmap = false;
    this.createBitmap = (options.createBitmap ?? _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    this.bitmap = null;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load(createBitmap) {
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise((resolve, reject) => {
      const source = this.source;
      this.url = source.src;
      const completed = () => {
        if (this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        this.resize(source.width, source.height);
        this._load = null;
        if (this.createBitmap) {
          resolve(this.process());
        } else {
          resolve(this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = (event) => {
          reject(event);
          this.onError.emit(event);
        };
      }
    });
    return this._load;
  }
  process() {
    const source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    const createImageBitmap = globalThis.createImageBitmap;
    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then((r) => r.blob()).then((blob) => createImageBitmap(blob, 0, 0, source.width, source.height, {
      premultiplyAlpha: this.alphaMode === null || this.alphaMode === _pixi_constants__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.UNPACK ? "premultiply" : "none"
    })).then((bitmap) => {
      if (this.destroyed) {
        return Promise.reject();
      }
      this.bitmap = bitmap;
      this.update();
      this._process = null;
      return Promise.resolve(this);
    });
    return this._process;
  }
  upload(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return super.upload(renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    super.upload(renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      let flag = true;
      const glTextures = baseTexture._glTextures;
      for (const key in glTextures) {
        const otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  }
  dispose() {
    this.source.onload = null;
    this.source.onerror = null;
    super.dispose();
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  }
  static test(source) {
    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);
  }
}


//# sourceMappingURL=ImageResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/Resource.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/Resource.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Resource": function() { return /* binding */ Resource; }
/* harmony export */ });
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");


class Resource {
  constructor(width = 0, height = 0) {
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner("setRealSize");
    this.onUpdate = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner("update");
    this.onError = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner("onError");
  }
  bind(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  }
  unbind(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  }
  resize(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(_renderer, _baseTexture, _glTexture) {
    return false;
  }
  dispose() {
  }
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  }
  static test(_source, _extension) {
    return false;
  }
}


//# sourceMappingURL=Resource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SVGResource": function() { return /* binding */ SVGResource; }
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs");




const _SVGResource = class extends _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseImageResource {
  constructor(sourceBase64, options) {
    options = options || {};
    super(_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.createCanvas());
    this._width = 0;
    this._height = 0;
    this.svg = sourceBase64;
    this.scale = options.scale || 1;
    this._overrideWidth = options.width;
    this._overrideHeight = options.height;
    this._resolve = null;
    this._crossorigin = options.crossorigin;
    this._load = null;
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    this._load = new Promise((resolve) => {
      this._resolve = () => {
        this.resize(this.source.width, this.source.height);
        resolve(this);
      };
      if (_SVGResource.SVG_XML.test(this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
      }
      this._loadSvg();
    });
    return this._load;
  }
  _loadSvg() {
    const tempImage = new Image();
    _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_2__.BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = (event) => {
      if (!this._resolve) {
        return;
      }
      tempImage.onerror = null;
      this.onError.emit(event);
    };
    tempImage.onload = () => {
      if (!this._resolve) {
        return;
      }
      const svgWidth = tempImage.width;
      const svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      let width = svgWidth * this.scale;
      let height = svgHeight * this.scale;
      if (this._overrideWidth || this._overrideHeight) {
        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;
        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      const canvas = this.source;
      canvas.width = width;
      canvas.height = height;
      canvas._pixiId = `canvas_${(0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.uid)()}`;
      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      this._resolve();
      this._resolve = null;
    };
  }
  static getSize(svgString) {
    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);
    const size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  }
  dispose() {
    super.dispose();
    this._resolve = null;
    this._crossorigin = null;
  }
  static test(source, extension) {
    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);
  }
};
let SVGResource = _SVGResource;
SVGResource.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;


//# sourceMappingURL=SVGResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VideoResource": function() { return /* binding */ VideoResource; }
/* harmony export */ });
/* harmony import */ var _pixi_ticker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/ticker */ "./node_modules/@pixi/ticker/lib/index.mjs");
/* harmony import */ var _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs");



const _VideoResource = class extends _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_1__.BaseImageResource {
  constructor(source, options) {
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      const videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      const firstSrc = source[0].src || source[0];
      _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_1__.BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (let i = 0; i < source.length; ++i) {
        const sourceElement = document.createElement("source");
        let { src, mime } = source[i];
        src = src || source[i];
        const baseSrc = src.split("?").shift().toLowerCase();
        const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    super(source);
    this.noSubImage = true;
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this._load = null;
    this._resolve = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onError = this._onError.bind(this);
    if (options.autoLoad !== false) {
      this.load();
    }
  }
  update(_deltaTime = 0) {
    if (!this.destroyed) {
      const elapsedMS = _pixi_ticker__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        super.update();
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  }
  load() {
    if (this._load) {
      return this._load;
    }
    const source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise((resolve) => {
      if (this.valid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        source.load();
      }
    });
    return this._load;
  }
  _onError(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  }
  _isSourcePlaying() {
    const source = this.source;
    return !source.paused && !source.ended && this._isSourceReady();
  }
  _isSourceReady() {
    const source = this.source;
    return source.readyState > 2;
  }
  _onPlayStart() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      _pixi_ticker__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  }
  _onPlayStop() {
    if (this._isConnectedToTicker) {
      _pixi_ticker__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  _onCanPlay() {
    const source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    const valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  }
  dispose() {
    if (this._isConnectedToTicker) {
      _pixi_ticker__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    const source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.dispose();
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        _pixi_ticker__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
        _pixi_ticker__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
    }
  }
  static test(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);
  }
};
let VideoResource = _VideoResource;
VideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
VideoResource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};


//# sourceMappingURL=VideoResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "INSTALLED": function() { return /* binding */ INSTALLED; },
/* harmony export */   "autoDetectResource": function() { return /* binding */ autoDetectResource; }
/* harmony export */ });
const INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  let extension = "";
  if (typeof source === "string") {
    const result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (let i = INSTALLED.length - 1; i >= 0; --i) {
    const ResourcePlugin = INSTALLED[i];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}


//# sourceMappingURL=autoDetectResource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/resources/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/resources/index.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractMultiResource": function() { return /* reexport safe */ _AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_11__.AbstractMultiResource; },
/* harmony export */   "ArrayResource": function() { return /* reexport safe */ _ArrayResource_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayResource; },
/* harmony export */   "BaseImageResource": function() { return /* reexport safe */ _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_9__.BaseImageResource; },
/* harmony export */   "BufferResource": function() { return /* reexport safe */ _BufferResource_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferResource; },
/* harmony export */   "CanvasResource": function() { return /* reexport safe */ _CanvasResource_mjs__WEBPACK_IMPORTED_MODULE_3__.CanvasResource; },
/* harmony export */   "CubeResource": function() { return /* reexport safe */ _CubeResource_mjs__WEBPACK_IMPORTED_MODULE_4__.CubeResource; },
/* harmony export */   "INSTALLED": function() { return /* reexport safe */ _autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_1__.INSTALLED; },
/* harmony export */   "ImageBitmapResource": function() { return /* reexport safe */ _ImageBitmapResource_mjs__WEBPACK_IMPORTED_MODULE_5__.ImageBitmapResource; },
/* harmony export */   "ImageResource": function() { return /* reexport safe */ _ImageResource_mjs__WEBPACK_IMPORTED_MODULE_6__.ImageResource; },
/* harmony export */   "Resource": function() { return /* reexport safe */ _Resource_mjs__WEBPACK_IMPORTED_MODULE_10__.Resource; },
/* harmony export */   "SVGResource": function() { return /* reexport safe */ _SVGResource_mjs__WEBPACK_IMPORTED_MODULE_7__.SVGResource; },
/* harmony export */   "VideoResource": function() { return /* reexport safe */ _VideoResource_mjs__WEBPACK_IMPORTED_MODULE_8__.VideoResource; },
/* harmony export */   "autoDetectResource": function() { return /* reexport safe */ _autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_1__.autoDetectResource; }
/* harmony export */ });
/* harmony import */ var _ArrayResource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArrayResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs");
/* harmony import */ var _autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./autoDetectResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs");
/* harmony import */ var _BufferResource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BufferResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs");
/* harmony import */ var _CanvasResource_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CanvasResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs");
/* harmony import */ var _CubeResource_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CubeResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs");
/* harmony import */ var _ImageBitmapResource_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ImageBitmapResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs");
/* harmony import */ var _ImageResource_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs");
/* harmony import */ var _SVGResource_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SVGResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs");
/* harmony import */ var _VideoResource_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VideoResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs");
/* harmony import */ var _BaseImageResource_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./BaseImageResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs");
/* harmony import */ var _Resource_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Resource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/Resource.mjs");
/* harmony import */ var _AbstractMultiResource_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./AbstractMultiResource.mjs */ "./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs");






















_autoDetectResource_mjs__WEBPACK_IMPORTED_MODULE_1__.INSTALLED.push(_ImageBitmapResource_mjs__WEBPACK_IMPORTED_MODULE_5__.ImageBitmapResource, _ImageResource_mjs__WEBPACK_IMPORTED_MODULE_6__.ImageResource, _CanvasResource_mjs__WEBPACK_IMPORTED_MODULE_3__.CanvasResource, _VideoResource_mjs__WEBPACK_IMPORTED_MODULE_8__.VideoResource, _SVGResource_mjs__WEBPACK_IMPORTED_MODULE_7__.SVGResource, _BufferResource_mjs__WEBPACK_IMPORTED_MODULE_2__.BufferResource, _CubeResource_mjs__WEBPACK_IMPORTED_MODULE_4__.CubeResource, _ArrayResource_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayResource);
//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapTypeAndFormatToInternalFormat": function() { return /* binding */ mapTypeAndFormatToInternalFormat; }
/* harmony export */ });
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");


function mapTypeAndFormatToInternalFormat(gl) {
  let table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = {
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA8,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB8,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG]: gl.RG8,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED]: gl.R8,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER]: gl.RGBA8UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB_INTEGER]: gl.RGB8UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG_INTEGER]: gl.RG8UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED_INTEGER]: gl.R8UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.ALPHA]: gl.ALPHA,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.LUMINANCE]: gl.LUMINANCE,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.BYTE]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA8_SNORM,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB8_SNORM,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG]: gl.RG8_SNORM,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED]: gl.R8_SNORM,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER]: gl.RGBA8I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB_INTEGER]: gl.RGB8I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG_INTEGER]: gl.RG8I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED_INTEGER]: gl.R8I
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER]: gl.RGBA16UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB_INTEGER]: gl.RGB16UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG_INTEGER]: gl.RG16UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED_INTEGER]: gl.R16UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.SHORT]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER]: gl.RGBA16I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB_INTEGER]: gl.RGB16I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG_INTEGER]: gl.RG16I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED_INTEGER]: gl.R16I
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_INT]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER]: gl.RGBA32UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB_INTEGER]: gl.RGB32UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG_INTEGER]: gl.RG32UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED_INTEGER]: gl.R32UI,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.INT]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER]: gl.RGBA32I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB_INTEGER]: gl.RGB32I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG_INTEGER]: gl.RG32I,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED_INTEGER]: gl.R32I
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA32F,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB32F,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG]: gl.RG32F,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED]: gl.R32F,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.HALF_FLOAT]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA16F,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB16F,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RG]: gl.RG16F,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RED]: gl.R16F
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_5_6_5]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB565
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA4
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGB5_A1
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGB10_A2,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA_INTEGER]: gl.RGB10_A2UI
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.R11F_G11F_B10F
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB9_E5
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_INT_24_8]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8
      }
    };
  } else {
    table = {
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.ALPHA]: gl.ALPHA,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.LUMINANCE]: gl.LUMINANCE,
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_5_6_5]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGB]: gl.RGB
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA
      },
      [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
        [_pixi_constants__WEBPACK_IMPORTED_MODULE_0__.FORMATS.RGBA]: gl.RGBA
      }
    };
  }
  return table;
}


//# sourceMappingURL=mapTypeAndFormatToInternalFormat.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformFeedback": function() { return /* binding */ TransformFeedback; }
/* harmony export */ });
/* harmony import */ var _pixi_runner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/runner */ "./node_modules/@pixi/runner/lib/index.mjs");


class TransformFeedback {
  constructor() {
    this._glTransformFeedbacks = {};
    this.buffers = [];
    this.disposeRunner = new _pixi_runner__WEBPACK_IMPORTED_MODULE_0__.Runner("disposeTransformFeedback");
  }
  bindBuffer(index, buffer) {
    this.buffers[index] = buffer;
  }
  destroy() {
    this.disposeRunner.emit(this, false);
  }
}


//# sourceMappingURL=TransformFeedback.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransformFeedbackSystem": function() { return /* binding */ TransformFeedbackSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");


class TransformFeedbackSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  contextChange() {
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }
  bind(transformFeedback) {
    const { gl, CONTEXT_UID } = this;
    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
  }
  unbind() {
    const { gl } = this;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(drawMode, shader) {
    const { gl, renderer } = this;
    if (shader) {
      renderer.shader.bind(shader);
    }
    gl.beginTransformFeedback(drawMode);
  }
  endTransformFeedback() {
    const { gl } = this;
    gl.endTransformFeedback();
  }
  createGLTransformFeedback(tf) {
    const { gl, renderer, CONTEXT_UID } = this;
    const glTransformFeedback = gl.createTransformFeedback();
    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
    for (let i = 0; i < tf.buffers.length; i++) {
      const buffer = tf.buffers[i];
      if (!buffer)
        continue;
      renderer.buffer.update(buffer);
      buffer._glBuffers[CONTEXT_UID].refCount++;
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    tf.disposeRunner.add(this);
    return glTransformFeedback;
  }
  disposeTransformFeedback(tf, contextLost) {
    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];
    const gl = this.gl;
    tf.disposeRunner.remove(this);
    const bufferSystem = this.renderer.buffer;
    if (bufferSystem) {
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        if (!buffer)
          continue;
        const buf = buffer._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffer, contextLost);
          }
        }
      }
    }
    if (!glTF) {
      return;
    }
    if (!contextLost) {
      gl.deleteTransformFeedback(glTF);
    }
    delete tf._glTransformFeedbacks[this.CONTEXT_UID];
  }
  destroy() {
    this.renderer = null;
  }
}
TransformFeedbackSystem.extension = {
  type: _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
  name: "transformFeedback"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(TransformFeedbackSystem);


//# sourceMappingURL=TransformFeedbackSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/utils/Quad.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/core/lib/utils/Quad.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quad": function() { return /* binding */ Quad; }
/* harmony export */ });
/* harmony import */ var _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Geometry.mjs */ "./node_modules/@pixi/core/lib/geometry/Geometry.mjs");


class Quad extends _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__.Geometry {
  constructor() {
    super();
    this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
  }
}


//# sourceMappingURL=Quad.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/utils/QuadUv.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/core/lib/utils/QuadUv.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QuadUv": function() { return /* binding */ QuadUv; }
/* harmony export */ });
/* harmony import */ var _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Buffer.mjs */ "./node_modules/@pixi/core/lib/geometry/Buffer.mjs");
/* harmony import */ var _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Geometry.mjs */ "./node_modules/@pixi/core/lib/geometry/Geometry.mjs");



class QuadUv extends _geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_1__.Geometry {
  constructor() {
    super();
    this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    this.vertexBuffer = new _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.Buffer(this.vertices);
    this.uvBuffer = new _geometry_Buffer_mjs__WEBPACK_IMPORTED_MODULE_0__.Buffer(this.uvs);
    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
  }
  map(targetTextureFrame, destinationFrame) {
    let x = 0;
    let y = 0;
    this.uvs[0] = x;
    this.uvs[1] = y;
    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y;
    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x;
    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
    x = destinationFrame.x;
    y = destinationFrame.y;
    this.vertices[0] = x;
    this.vertices[1] = y;
    this.vertices[2] = x + destinationFrame.width;
    this.vertices[3] = y;
    this.vertices[4] = x + destinationFrame.width;
    this.vertices[5] = y + destinationFrame.height;
    this.vertices[6] = x;
    this.vertices[7] = y + destinationFrame.height;
    this.invalidate();
    return this;
  }
  invalidate() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  }
}


//# sourceMappingURL=QuadUv.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/core/lib/view/ViewSystem.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/core/lib/view/ViewSystem.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewSystem": function() { return /* binding */ ViewSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ "./node_modules/@pixi/math/lib/index.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");




class ViewSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  init(options) {
    this.screen = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Rectangle(0, 0, options.width, options.height);
    this.element = options.view || _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.ADAPTER.createCanvas();
    this.resolution = options.resolution || _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.RESOLUTION;
    this.autoDensity = !!options.autoDensity;
  }
  resizeView(desiredScreenWidth, desiredScreenHeight) {
    this.element.width = Math.round(desiredScreenWidth * this.resolution);
    this.element.height = Math.round(desiredScreenHeight * this.resolution);
    const screenWidth = this.element.width / this.resolution;
    const screenHeight = this.element.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.element.style.width = `${screenWidth}px`;
      this.element.style.height = `${screenHeight}px`;
    }
    this.renderer.emit("resize", screenWidth, screenHeight);
    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
  }
  destroy(removeView) {
    if (removeView) {
      this.element.parentNode?.removeChild(this.element);
    }
    this.renderer = null;
    this.element = null;
    this.screen = null;
  }
}
ViewSystem.defaultOptions = {
  width: 800,
  height: 600,
  resolution: _pixi_settings__WEBPACK_IMPORTED_MODULE_2__.settings.RESOLUTION,
  autoDensity: false
};
ViewSystem.extension = {
  type: [
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
    _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasRendererSystem
  ],
  name: "_view"
};
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(ViewSystem);


//# sourceMappingURL=ViewSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/Bounds.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/display/lib/Bounds.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bounds": function() { return /* binding */ Bounds; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class Bounds {
  constructor() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  }
  getRectangle(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle.EMPTY;
    }
    rect = rect || new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  }
  addPoint(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  }
  addPointMatrix(matrix, point) {
    const { a, b, c, d, tx, ty } = matrix;
    const x = a * point.x + c * point.y + tx;
    const y = b * point.x + d * point.y + ty;
    this.minX = Math.min(this.minX, x);
    this.maxX = Math.max(this.maxX, x);
    this.minY = Math.min(this.minY, y);
    this.maxY = Math.max(this.maxY, y);
  }
  addQuad(vertices) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = vertices[0];
    let y = vertices[1];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[2];
    y = vertices[3];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[4];
    y = vertices[5];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = vertices[6];
    y = vertices[7];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addFrame(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  }
  addFrameMatrix(matrix, x0, y0, x1, y1) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = a * x0 + c * y0 + tx;
    let y = b * x0 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y0 + tx;
    y = b * x1 + d * y0 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x0 + c * y1 + tx;
    y = b * x0 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    x = a * x1 + c * y1 + tx;
    y = b * x1 + d * y1 + ty;
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertexData(vertexData, beginOffset, endOffset) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const x = vertexData[i];
      const y = vertexData[i + 1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addVertices(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  }
  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const rawX = vertices[i];
      const rawY = vertices[i + 1];
      const x = a * rawX + c * rawY + tx;
      const y = d * rawY + b * rawX + ty;
      minX = Math.min(minX, x - padX);
      maxX = Math.max(maxX, x + padX);
      minY = Math.min(minY, y - padY);
      maxY = Math.max(maxY, y + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  addBounds(bounds) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  }
  addBoundsMask(bounds, mask) {
    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  addBoundsMatrix(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  }
  addBoundsArea(bounds, area) {
    const _minX = bounds.minX > area.x ? bounds.minX : area.x;
    const _minY = bounds.minY > area.y ? bounds.minY : area.y;
    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      const minX = this.minX;
      const minY = this.minY;
      const maxX = this.maxX;
      const maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  }
  pad(paddingX = 0, paddingY = paddingX) {
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  }
  addFramePad(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  }
}


//# sourceMappingURL=Bounds.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/Container.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/display/lib/Container.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Container": function() { return /* binding */ Container; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _DisplayObject_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DisplayObject.mjs */ "./node_modules/@pixi/display/lib/DisplayObject.mjs");



const tempMatrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
function sortChildren(a, b) {
  if (a.zIndex === b.zIndex) {
    return a._lastSortedIndex - b._lastSortedIndex;
  }
  return a.zIndex - b.zIndex;
}
const _Container = class extends _DisplayObject_mjs__WEBPACK_IMPORTED_MODULE_1__.DisplayObject {
  constructor() {
    super();
    this.children = [];
    this.sortableChildren = _Container.defaultSortableChildren;
    this.sortDirty = false;
  }
  onChildrenChange(_length) {
  }
  addChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
    } else {
      const child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  }
  addChildAt(child, index) {
    if (index < 0 || index > this.children.length) {
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index, 0, child);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("added", this);
    this.emit("childAdded", child, this, index);
    return child;
  }
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  }
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index;
  }
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    const currentIndex = this.getChildIndex(child);
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.removeItems(this.children, currentIndex, 1);
    this.children.splice(index, 0, child);
    this.onChildrenChange(index);
  }
  getChildAt(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  }
  removeChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    } else {
      const child = children[0];
      const index = this.children.indexOf(child);
      if (index === -1)
        return null;
      child.parent = null;
      child.transform._parentID = -1;
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.removeItems(this.children, index, 1);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index);
    }
    return children[0];
  }
  removeChildAt(index) {
    const child = this.getChildAt(index);
    child.parent = null;
    child.transform._parentID = -1;
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.removeItems(this.children, index, 1);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index);
    return child;
  }
  removeChildren(beginIndex = 0, endIndex = this.children.length) {
    const begin = beginIndex;
    const end = endIndex;
    const range = end - begin;
    let removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].parent = null;
        if (removed[i].transform) {
          removed[i].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (let i = 0; i < removed.length; ++i) {
        removed[i].emit("removed", this);
        this.emit("childRemoved", removed[i], this, i);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }
  sortChildren() {
    let sortRequired = false;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      child._lastSortedIndex = i;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  }
  updateTransform() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      if (child.visible) {
        child.updateTransform();
      }
    }
  }
  calculateBounds() {
    this._bounds.clear();
    this._calculateBounds();
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
        if (maskObject) {
          maskObject.calculateBounds();
          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
        } else {
          this._bounds.addBounds(child._bounds);
        }
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(rect, skipChildrenUpdate = false) {
    const result = super.getLocalBounds(rect);
    if (!skipChildrenUpdate) {
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  }
  _calculateBounds() {
  }
  _renderWithCulling(renderer) {
    const sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    let bounds;
    let transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== _Container.prototype._render) {
      bounds = this.getBounds(true);
    }
    const projectionTransform = renderer.projection.transform;
    if (projectionTransform) {
      if (transform) {
        transform = tempMatrix.copyFrom(transform);
        transform.prepend(projectionTransform);
      } else {
        transform = projectionTransform;
      }
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer);
    } else if (this.cullArea) {
      return;
    }
    for (let i = 0, j = this.children.length; i < j; ++i) {
      const child = this.children[i];
      const childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer);
      child.cullable = childCullable;
    }
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters?.length) {
      this.renderAdvanced(renderer);
    } else if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
  }
  renderAdvanced(renderer) {
    const filters = this.filters;
    const mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (let i = 0; i < filters.length; i++) {
        if (filters[i].enabled) {
          this._enabledFilters.push(filters[i]);
        }
      }
    }
    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== _pixi_core__WEBPACK_IMPORTED_MODULE_0__.MASK_TYPES.NONE));
    if (flush) {
      renderer.batch.flush();
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (let i = 0, j = this.children.length; i < j; ++i) {
        this.children[i].render(renderer);
      }
    }
    if (flush) {
      renderer.batch.flush();
    }
    if (mask) {
      renderer.mask.pop(this);
    }
    if (filters && this._enabledFilters?.length) {
      renderer.filter.pop();
    }
  }
  _render(_renderer) {
  }
  destroy(options) {
    super.destroy();
    this.sortDirty = false;
    const destroyChildren = typeof options === "boolean" ? options : options?.children;
    const oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (let i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(value) {
    const width = this.getLocalBounds().width;
    if (width !== 0) {
      this.scale.x = value / width;
    } else {
      this.scale.x = 1;
    }
    this._width = value;
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(value) {
    const height = this.getLocalBounds().height;
    if (height !== 0) {
      this.scale.y = value / height;
    } else {
      this.scale.y = 1;
    }
    this._height = value;
  }
};
let Container = _Container;
Container.defaultSortableChildren = false;
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;


//# sourceMappingURL=Container.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/DisplayObject.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/display/lib/DisplayObject.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisplayObject": function() { return /* binding */ DisplayObject; },
/* harmony export */   "TemporaryDisplayObject": function() { return /* binding */ TemporaryDisplayObject; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds.mjs */ "./node_modules/@pixi/display/lib/Bounds.mjs");



class DisplayObject extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.EventEmitter {
  constructor() {
    super();
    this.tempDisplayObjectParent = null;
    this.transform = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Transform();
    this.alpha = 1;
    this.visible = true;
    this.renderable = true;
    this.cullable = false;
    this.cullArea = null;
    this.parent = null;
    this.worldAlpha = 1;
    this._lastSortedIndex = 0;
    this._zIndex = 0;
    this.filterArea = null;
    this.filters = null;
    this._enabledFilters = null;
    this._bounds = new _Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds();
    this._localBounds = null;
    this._boundsID = 0;
    this._boundsRect = null;
    this._localBoundsRect = null;
    this._mask = null;
    this._maskRefCount = 0;
    this._destroyed = false;
    this.isSprite = false;
    this.isMask = false;
  }
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  }
  updateTransform() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }
  getBounds(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  }
  getLocalBounds(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new _Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds();
    }
    const transformRef = this.transform;
    const parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    const worldBounds = this._bounds;
    const worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    const bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  }
  toGlobal(position, point, skipUpdate = false) {
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  }
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  }
  setParent(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  }
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
    this.position.x = x;
    this.position.y = y;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  }
  destroy(_options) {
    this.removeFromParent();
    this._destroyed = true;
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.eventMode = "auto";
    this.interactiveChildren = false;
    this.emit("destroyed");
    this.removeAllListeners();
  }
  get _tempDisplayObjectParent() {
    if (this.tempDisplayObjectParent === null) {
      this.tempDisplayObjectParent = new TemporaryDisplayObject();
    }
    return this.tempDisplayObjectParent;
  }
  enableTempParent() {
    const myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  }
  disableTempParent(cacheParent) {
    this.parent = cacheParent;
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.transform.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.transform.position.y = value;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(value) {
    this.transform.position.copyFrom(value);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(value) {
    this.transform.scale.copyFrom(value);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(value) {
    this.transform.pivot.copyFrom(value);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(value) {
    this.transform.skew.copyFrom(value);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(value) {
    this.transform.rotation = value;
  }
  get angle() {
    return this.transform.rotation * _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RAD_TO_DEG;
  }
  set angle(value) {
    this.transform.rotation = value * _pixi_core__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    if (this.parent) {
      this.parent.sortDirty = true;
    }
  }
  get worldVisible() {
    let item = this;
    do {
      if (!item.visible) {
        return false;
      }
      item = item.parent;
    } while (item);
    return true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
    }
    this._mask = value;
    if (this._mask) {
      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
      if (maskObject) {
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    }
  }
}
class TemporaryDisplayObject extends DisplayObject {
  constructor() {
    super(...arguments);
    this.sortDirty = null;
  }
}
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;


//# sourceMappingURL=DisplayObject.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/display/lib/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bounds": function() { return /* reexport safe */ _Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__.Bounds; },
/* harmony export */   "Container": function() { return /* reexport safe */ _Container_mjs__WEBPACK_IMPORTED_MODULE_2__.Container; },
/* harmony export */   "DisplayObject": function() { return /* reexport safe */ _DisplayObject_mjs__WEBPACK_IMPORTED_MODULE_3__.DisplayObject; },
/* harmony export */   "TemporaryDisplayObject": function() { return /* reexport safe */ _DisplayObject_mjs__WEBPACK_IMPORTED_MODULE_3__.TemporaryDisplayObject; }
/* harmony export */ });
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi/display/lib/settings.mjs");
/* harmony import */ var _Bounds_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds.mjs */ "./node_modules/@pixi/display/lib/Bounds.mjs");
/* harmony import */ var _Container_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Container.mjs */ "./node_modules/@pixi/display/lib/Container.mjs");
/* harmony import */ var _DisplayObject_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DisplayObject.mjs */ "./node_modules/@pixi/display/lib/DisplayObject.mjs");




//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/display/lib/settings.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/display/lib/settings.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "settings": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _Container_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Container.mjs */ "./node_modules/@pixi/display/lib/Container.mjs");




Object.defineProperties(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings, {
  SORTABLE_CHILDREN: {
    get() {
      return _Container_mjs__WEBPACK_IMPORTED_MODULE_1__.Container.defaultSortableChildren;
    },
    set(value) {
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");
      _Container_mjs__WEBPACK_IMPORTED_MODULE_1__.Container.defaultSortableChildren = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/EventBoundary.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/events/lib/EventBoundary.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventBoundary": function() { return /* binding */ EventBoundary; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventTicker.mjs */ "./node_modules/@pixi/events/lib/EventTicker.mjs");
/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FederatedMouseEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs");
/* harmony import */ var _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FederatedPointerEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs");
/* harmony import */ var _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FederatedWheelEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs");






const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
const tempLocalMapping = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
class EventBoundary {
  constructor(rootTarget) {
    this.dispatch = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.EventEmitter();
    this.moveOnAll = false;
    this.enableGlobalMoveEvents = true;
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = /* @__PURE__ */ new Map();
    this._allInteractiveElements = [];
    this._hitElements = [];
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = false;
    e.propagationImmediatelyStopped = false;
    this.propagate(e, type);
    this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e.type];
    if (mappers) {
      for (let i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
    }
  }
  hitTest(x, y) {
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);
    return invertedPath && invertedPath[0];
  }
  propagate(e, type) {
    if (!e.target) {
      return;
    }
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    for (let i = composedPath.length - 2; i >= 0; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    }
  }
  all(e, type, targets = this._allInteractiveElements) {
    if (targets.length === 0)
      return;
    e.eventPhase = e.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i = targets.length - 1; i >= 0; i--) {
      events.forEach((event) => {
        e.currentTarget = targets[i];
        this.notifyTarget(e, event);
      });
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget))
      return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive)
              this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0)
            this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget)
      this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0)
      return null;
    if (shouldReturn)
      return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_1__.EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive)
            nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(displayObject) {
    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {
      return true;
    }
    if (displayObject.eventMode === "none") {
      return true;
    }
    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {
      return true;
    }
    if (displayObject.isMask) {
      return true;
    }
    return false;
  }
  hitPruneFn(displayObject, location) {
    if (displayObject.hitArea) {
      displayObject.worldTransform.applyInverse(location, tempLocalMapping);
      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (displayObject._mask) {
      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;
      if (maskObject && !maskObject.containsPoint?.(location)) {
        return true;
      }
    }
    return false;
  }
  hitTestFn(displayObject, location) {
    if (displayObject.eventMode === "passive") {
      return false;
    }
    if (displayObject.hitArea) {
      return true;
    }
    if (displayObject.containsPoint) {
      return displayObject.containsPoint(location);
    }
    return false;
  }
  notifyTarget(e, type) {
    type = type ?? e.type;
    const handlerKey = `on${type}`;
    e.currentTarget[handlerKey]?.(e);
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key);
    if (e.eventPhase === e.AT_TARGET) {
      this.notifyListeners(e, type);
    }
  }
  mapPointerDown(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerdown");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchstart");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerMove(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      if (!e.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse)
            this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse)
        this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e.target)
          break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
  }
  mapPointerOver(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e = this.createPointerEvent(from);
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    this.dispatchEvent(e, "pointerover");
    if (isMouse)
      this.dispatchEvent(e, "mouseover");
    if (e.pointerType === "mouse")
      this.cursor = e.target?.cursor;
    const enterEvent = this.clonePointerEvent(e, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse)
        this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
    this.freeEvent(enterEvent);
  }
  mapPointerOut(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse)
        this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse)
          this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  mapPointerUp(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerup");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchend");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e.composedPath().includes(currentTarget)) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e);
  }
  mapPointerUpOutside(from) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent)) {
      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e);
  }
  mapWheel(from) {
    if (!(from instanceof _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedWheelEvent)) {
      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length; i++) {
      if (propagationPath[i].parent === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(_FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  createWheelEvent(from) {
    const event = this.allocateEvent(_FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(_FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    if (!(from instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent && to instanceof _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent))
      return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  copyMouseData(from, to) {
    if (!(from instanceof _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_2__.FederatedMouseEvent && to instanceof _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_2__.FederatedMouseEvent))
      return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = null;
    event.target = null;
    return event;
  }
  freeEvent(event) {
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (!listeners)
      return;
    if (!e.currentTarget.isInteractive())
      return;
    if ("fn" in listeners) {
      if (listeners.once)
        e.currentTarget.removeListener(type, listeners.fn, void 0, true);
      listeners.fn.call(listeners.context, e);
    } else {
      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once)
          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
        listeners[i].fn.call(listeners[i].context, e);
      }
    }
  }
}


//# sourceMappingURL=EventBoundary.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/EventSystem.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/events/lib/EventSystem.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventSystem": function() { return /* binding */ EventSystem; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventBoundary.mjs */ "./node_modules/@pixi/events/lib/EventBoundary.mjs");
/* harmony import */ var _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventTicker.mjs */ "./node_modules/@pixi/events/lib/EventTicker.mjs");
/* harmony import */ var _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FederatedPointerEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs");
/* harmony import */ var _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FederatedWheelEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs");






const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class {
  constructor(renderer) {
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    this.domElement = null;
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new _EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_1__.EventBoundary(null);
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_2__.EventsTicker.init(this);
    this.autoPreventDefault = true;
    this.eventsAdded = false;
    this.rootPointerEvent = new _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedPointerEvent(null);
    this.rootWheelEvent = new _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerUp = this.onPointerUp.bind(this);
    this.onPointerOverOut = this.onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  init(options) {
    const { view, resolution } = this.renderer;
    this.setTargetElement(view);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "auto";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  destroy() {
    this.setTargetElement(null);
    this.renderer = null;
  }
  setCursor(mode) {
    mode = mode || "default";
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursor === mode) {
      return;
    }
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  get pointer() {
    return this.rootPointerEvent;
  }
  onPointerDown(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const events = this.normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i = 0, j = events.length; i < j; i++) {
      const nativeEvent2 = events[i];
      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerMove(nativeEvent) {
    if (!this.features.move)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_2__.EventsTicker.pointerMoved();
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerUp(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onPointerOverOut(nativeEvent) {
    if (!this.features.click)
      return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")
      return;
    const normalizedEvents = this.normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  onWheel(nativeEvent) {
    if (!this.features.wheel)
      return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  setTargetElement(element) {
    this.removeEvents();
    this.domElement = element;
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_2__.EventsTicker.domElement = element;
    this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) {
      return;
    }
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_2__.EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);
      this.domElement.addEventListener("mousedown", this.onPointerDown, true);
      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.addEventListener("touchstart", this.onPointerDown, true);
      this.domElement.addEventListener("touchend", this.onPointerUp, true);
      this.domElement.addEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement) {
      return;
    }
    _EventTicker_mjs__WEBPACK_IMPORTED_MODULE_2__.EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this.onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this.onPointerUp, true);
    }
    if (this.supportsTouchEvents) {
      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);
      this.domElement.removeEventListener("touchend", this.onPointerUp, true);
      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this.eventsAdded = false;
  }
  mapPositionToPoint(point, x, y) {
    let rect;
    if (!this.domElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.domElement.width,
        height: this.domElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.domElement.getBoundingClientRect();
    }
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        if (typeof touch.button === "undefined")
          touch.button = 0;
        if (typeof touch.buttons === "undefined")
          touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined")
          touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined")
          touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined")
          touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined")
          touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined")
          touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined")
          touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined")
          touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined")
          touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined")
          touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined")
          touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined")
          touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined")
        tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined")
        tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined")
        tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined")
        tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined")
        tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined")
        tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined")
        tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined")
        tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined")
        tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined")
        tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
let EventSystem = _EventSystem;
EventSystem.extension = {
  name: "events",
  type: [
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem,
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.CanvasRendererSystem
  ]
};
EventSystem.defaultEventFeatures = {
  move: true,
  globalMove: true,
  click: true,
  wheel: true
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(EventSystem);


//# sourceMappingURL=EventSystem.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/EventTicker.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/events/lib/EventTicker.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventsTicker": function() { return /* binding */ EventsTicker; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class EventsTickerClass {
  constructor() {
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this.tickerAdded = false;
    this._pauseUpdate = true;
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  addTickerListener() {
    if (this.tickerAdded || !this.domElement) {
      return;
    }
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.add(this.tickerUpdate, this, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  }
  removeTickerListener() {
    if (!this.tickerAdded) {
      return;
    }
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  }
  pointerMoved() {
    this._didMove = true;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  tickerUpdate(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  }
}
const EventsTicker = new EventsTickerClass();


//# sourceMappingURL=EventTicker.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedEvent.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedEvent.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FederatedEvent": function() { return /* binding */ FederatedEvent; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class FederatedEvent {
  constructor(manager) {
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.composed = false;
    this.defaultPrevented = false;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.layer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
    this.page = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
}


//# sourceMappingURL=FederatedEvent.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedEventMap.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedEventMap.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=FederatedEventMap.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedEventTarget.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedEventTarget.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FederatedDisplayObject": function() { return /* binding */ FederatedDisplayObject; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _EventSystem_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventSystem.mjs */ "./node_modules/@pixi/events/lib/EventSystem.mjs");
/* harmony import */ var _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FederatedEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedEvent.mjs");





function convertEventModeToInteractiveMode(mode) {
  return mode === "dynamic" || mode === "static";
}
const FederatedDisplayObject = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: void 0,
  get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(_EventSystem_mjs__WEBPACK_IMPORTED_MODULE_2__.EventSystem.defaultEventMode);
  },
  set interactive(value) {
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.`);
    this._internalInteractive = value;
    this.eventMode = value ? "static" : "auto";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? _EventSystem_mjs__WEBPACK_IMPORTED_MODULE_2__.EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value);
    this._internalEventMode = value;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.on(type, listener, context);
  },
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context);
  },
  dispatchEvent(e) {
    if (!(e instanceof _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_3__.FederatedEvent)) {
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    e.defaultPrevented = false;
    e.path = null;
    e.target = this;
    e.manager.dispatchEvent(e);
    return !e.defaultPrevented;
  }
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.mixin(FederatedDisplayObject);


//# sourceMappingURL=FederatedEventTarget.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FederatedMouseEvent": function() { return /* binding */ FederatedMouseEvent; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FederatedEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedEvent.mjs");



class FederatedMouseEvent extends _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_1__.FederatedEvent {
  constructor() {
    super(...arguments);
    this.client = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
    this.movement = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
    this.offset = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
    this.global = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
    this.screen = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}


//# sourceMappingURL=FederatedMouseEvent.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FederatedPointerEvent": function() { return /* binding */ FederatedPointerEvent; }
/* harmony export */ });
/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FederatedMouseEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs");


class FederatedPointerEvent extends _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.height = 0;
    this.isPrimary = false;
  }
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}


//# sourceMappingURL=FederatedPointerEvent.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FederatedWheelEvent": function() { return /* binding */ FederatedWheelEvent; }
/* harmony export */ });
/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FederatedMouseEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs");


class FederatedWheelEvent extends _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_0__.FederatedMouseEvent {
  constructor() {
    super(...arguments);
    this.DOM_DELTA_PIXEL = 0;
    this.DOM_DELTA_LINE = 1;
    this.DOM_DELTA_PAGE = 2;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;


//# sourceMappingURL=FederatedWheelEvent.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/events/lib/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/events/lib/index.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventBoundary": function() { return /* reexport safe */ _EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_0__.EventBoundary; },
/* harmony export */   "EventSystem": function() { return /* reexport safe */ _EventSystem_mjs__WEBPACK_IMPORTED_MODULE_1__.EventSystem; },
/* harmony export */   "FederatedDisplayObject": function() { return /* reexport safe */ _FederatedEventTarget_mjs__WEBPACK_IMPORTED_MODULE_4__.FederatedDisplayObject; },
/* harmony export */   "FederatedEvent": function() { return /* reexport safe */ _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_2__.FederatedEvent; },
/* harmony export */   "FederatedMouseEvent": function() { return /* reexport safe */ _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_5__.FederatedMouseEvent; },
/* harmony export */   "FederatedPointerEvent": function() { return /* reexport safe */ _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_6__.FederatedPointerEvent; },
/* harmony export */   "FederatedWheelEvent": function() { return /* reexport safe */ _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_7__.FederatedWheelEvent; }
/* harmony export */ });
/* harmony import */ var _EventBoundary_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventBoundary.mjs */ "./node_modules/@pixi/events/lib/EventBoundary.mjs");
/* harmony import */ var _EventSystem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSystem.mjs */ "./node_modules/@pixi/events/lib/EventSystem.mjs");
/* harmony import */ var _FederatedEvent_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FederatedEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedEvent.mjs");
/* harmony import */ var _FederatedEventMap_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FederatedEventMap.mjs */ "./node_modules/@pixi/events/lib/FederatedEventMap.mjs");
/* harmony import */ var _FederatedEventTarget_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FederatedEventTarget.mjs */ "./node_modules/@pixi/events/lib/FederatedEventTarget.mjs");
/* harmony import */ var _FederatedMouseEvent_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./FederatedMouseEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs");
/* harmony import */ var _FederatedPointerEvent_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FederatedPointerEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs");
/* harmony import */ var _FederatedWheelEvent_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./FederatedWheelEvent.mjs */ "./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs");








//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/extensions/lib/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/extensions/lib/index.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExtensionType": function() { return /* binding */ ExtensionType; },
/* harmony export */   "extensions": function() { return /* binding */ extensions; }
/* harmony export */ });
var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Renderer"] = "renderer";
  ExtensionType2["Application"] = "application";
  ExtensionType2["RendererSystem"] = "renderer-webgl-system";
  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";
  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";
  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
const normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
  _addHandlers: {},
  _removeHandlers: {},
  _queue: {},
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    });
    return this;
  },
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type]) {
          queue[type] = queue[type] || [];
          queue[type].push(ext);
        } else {
          handlers[type](ext);
        }
      });
    });
    return this;
  },
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue = this._queue;
    if (queue[type]) {
      queue[type].forEach((ext) => onAdd(ext));
      delete queue[type];
    }
    return this;
  },
  handleByMap(type, map) {
    return this.handle(type, (extension) => {
      map[extension.name] = extension.ref;
    }, (extension) => {
      delete map[extension.name];
    });
  },
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, (extension) => {
      if (list.includes(extension.ref)) {
        return;
      }
      list.push(extension.ref);
      list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority));
    }, (extension) => {
      const index = list.indexOf(extension.ref);
      if (index !== -1) {
        list.splice(index, 1);
      }
    });
  }
};


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/extract/lib/Extract.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/extract/lib/Extract.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Extract": function() { return /* binding */ Extract; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const TEMP_RECT = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
const BYTES_PER_PIXEL = 4;
const _Extract = class {
  constructor(renderer) {
    this.renderer = renderer;
  }
  async image(target, format, quality) {
    const image = new Image();
    image.src = await this.base64(target, format, quality);
    return image;
  }
  async base64(target, format, quality) {
    const canvas = this.canvas(target);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, format, quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(format, quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    const canvasBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.CanvasRenderTarget(width, height, 1);
    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
    canvasBuffer.context.putImageData(imageData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const { pixels, width, height, flipY } = this._rawPixels(target, frame);
    if (flipY) {
      _Extract._flipY(pixels, width, height);
    }
    _Extract._unpremultiplyAlpha(pixels);
    return pixels;
  }
  _rawPixels(target, frame) {
    const renderer = this.renderer;
    if (!renderer) {
      throw new Error("The Extract has already been destroyed");
    }
    let resolution;
    let flipY = false;
    let renderTexture;
    let generated = false;
    if (target) {
      if (target instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer.generateTexture(target, {
          resolution: renderer.resolution,
          multisample: renderer.multisample
        });
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = frame ?? renderTexture.frame;
      flipY = false;
      if (!generated) {
        renderer.renderTexture.bind(renderTexture);
        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
        if (fbo.blitFramebuffer) {
          renderer.framebuffer.bind(fbo.blitFramebuffer);
        }
      }
    } else {
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width / resolution;
        frame.height = renderer.height / resolution;
      }
      flipY = true;
      renderer.renderTexture.bind();
    }
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const gl = renderer.gl;
    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (generated) {
      renderTexture?.destroy(true);
    }
    return { pixels, width, height, flipY };
  }
  destroy() {
    this.renderer = null;
  }
  static _flipY(pixels, width, height) {
    const w = width << 2;
    const h = height >> 1;
    const temp = new Uint8Array(w);
    for (let y = 0; y < h; y++) {
      const t = y * w;
      const b = (height - y - 1) * w;
      temp.set(pixels.subarray(t, t + w));
      pixels.copyWithin(t, b, b + w);
      pixels.set(temp, b);
    }
  }
  static _unpremultiplyAlpha(pixels) {
    if (pixels instanceof Uint8ClampedArray) {
      pixels = new Uint8Array(pixels.buffer);
    }
    const n = pixels.length;
    for (let i = 0; i < n; i += 4) {
      const alpha = pixels[i + 3];
      if (alpha !== 0) {
        const a = 255.001 / alpha;
        pixels[i] = pixels[i] * a + 0.5;
        pixels[i + 1] = pixels[i + 1] * a + 0.5;
        pixels[i + 2] = pixels[i + 2] * a + 0.5;
      }
    }
  }
};
let Extract = _Extract;
Extract.extension = {
  name: "extract",
  type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(Extract);


//# sourceMappingURL=Extract.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/extract/lib/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/extract/lib/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Extract": function() { return /* reexport safe */ _Extract_mjs__WEBPACK_IMPORTED_MODULE_0__.Extract; }
/* harmony export */ });
/* harmony import */ var _Extract_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extract.mjs */ "./node_modules/@pixi/extract/lib/Extract.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlphaFilter": function() { return /* binding */ AlphaFilter; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _alpha_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alpha.mjs */ "./node_modules/@pixi/filter-alpha/lib/alpha.mjs");



class AlphaFilter extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(alpha = 1) {
    super(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.defaultVertex, _alpha_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], { uAlpha: 1 });
    this.alpha = alpha;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}


//# sourceMappingURL=AlphaFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-alpha/lib/alpha.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/filter-alpha/lib/alpha.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";


//# sourceMappingURL=alpha.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-alpha/lib/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/filter-alpha/lib/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlphaFilter": function() { return /* reexport safe */ _AlphaFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.AlphaFilter; }
/* harmony export */ });
/* harmony import */ var _AlphaFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlphaFilter.mjs */ "./node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/BlurFilter.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/BlurFilter.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlurFilter": function() { return /* binding */ BlurFilter; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BlurFilterPass.mjs */ "./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs");



class BlurFilter extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(strength = 8, quality = 4, resolution = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter.defaultResolution, kernelSize = 5) {
    super();
    this._repeatEdgePixels = false;
    this.blurXFilter = new _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_1__.BlurFilterPass(true, strength, quality, resolution, kernelSize);
    this.blurYFilter = new _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_1__.BlurFilterPass(false, strength, quality, resolution, kernelSize);
    this.resolution = resolution;
    this.quality = quality;
    this.blur = strength;
    this.repeatEdgePixels = false;
  }
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(value) {
    this.blurXFilter.blur = this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value) {
    this.blurXFilter.quality = this.blurYFilter.quality = value;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(value) {
    this.blurXFilter.blur = value;
    this.updatePadding();
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(value) {
    this.blurYFilter.blur = value;
    this.updatePadding();
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(value) {
    this.blurYFilter.blendMode = value;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value) {
    this._repeatEdgePixels = value;
    this.updatePadding();
  }
}


//# sourceMappingURL=BlurFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlurFilterPass": function() { return /* binding */ BlurFilterPass; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _generateBlurFragSource_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateBlurFragSource.mjs */ "./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs");
/* harmony import */ var _generateBlurVertSource_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generateBlurVertSource.mjs */ "./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs");




class BlurFilterPass extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(horizontal, strength = 8, quality = 4, resolution = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter.defaultResolution, kernelSize = 5) {
    const vertSrc = (0,_generateBlurVertSource_mjs__WEBPACK_IMPORTED_MODULE_2__.generateBlurVertSource)(kernelSize, horizontal);
    const fragSrc = (0,_generateBlurFragSource_mjs__WEBPACK_IMPORTED_MODULE_1__.generateBlurFragSource)(kernelSize);
    super(vertSrc, fragSrc);
    this.horizontal = horizontal;
    this.resolution = resolution;
    this._quality = 0;
    this.quality = quality;
    this.blur = strength;
  }
  apply(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = filterManager.getFilterTexture();
      const renderer = filterManager.renderer;
      let flip = input;
      let flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.CLEAR);
      for (let i = 1; i < this.passes - 1; i++) {
        filterManager.bindAndClear(flip, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.CLEAR_MODES.BLIT);
        this.uniforms.uSampler = flop;
        const temp = flop;
        flop = flip;
        flip = temp;
        renderer.shader.bind(this);
        renderer.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(value) {
    this.padding = 1 + Math.abs(value) * 2;
    this.strength = value;
  }
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = value;
    this.passes = value;
  }
}


//# sourceMappingURL=BlurFilterPass.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateBlurFragSource": function() { return /* binding */ generateBlurFragSource; }
/* harmony export */ });
const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
const fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate;
  let blurLoop = "";
  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    value = i;
    if (i >= halfLength) {
      value = kernelSize - i - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}


//# sourceMappingURL=generateBlurFragSource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateBlurVertSource": function() { return /* binding */ generateBlurVertSource; }
/* harmony export */ });
const vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (let i = 0; i < kernelSize; i++) {
    let blur = template.replace("%index%", i.toString());
    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}


//# sourceMappingURL=generateBlurVertSource.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-blur/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/filter-blur/lib/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlurFilter": function() { return /* reexport safe */ _BlurFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.BlurFilter; },
/* harmony export */   "BlurFilterPass": function() { return /* reexport safe */ _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_1__.BlurFilterPass; }
/* harmony export */ });
/* harmony import */ var _BlurFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BlurFilter.mjs */ "./node_modules/@pixi/filter-blur/lib/BlurFilter.mjs");
/* harmony import */ var _BlurFilterPass_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BlurFilterPass.mjs */ "./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorMatrixFilter": function() { return /* binding */ ColorMatrixFilter; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _colorMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorMatrix.mjs */ "./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.mjs");



class ColorMatrixFilter extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor() {
    const uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    super(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.defaultFilterVertex, _colorMatrix_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], uniforms);
    this.alpha = 1;
  }
  _loadMatrix(matrix, multiply = false) {
    let newMatrix = matrix;
    if (multiply) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  }
  _multiply(out, a, b) {
    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];
    return out;
  }
  _colorMatrix(matrix) {
    const m = new Float32Array(matrix);
    m[4] /= 255;
    m[9] /= 255;
    m[14] /= 255;
    m[19] /= 255;
    return m;
  }
  brightness(b, multiply) {
    const matrix = [
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  tint(color, multiply) {
    const [r, g, b] = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(color).toArray();
    const matrix = [
      r,
      0,
      0,
      0,
      0,
      0,
      g,
      0,
      0,
      0,
      0,
      0,
      b,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  greyscale(scale, multiply) {
    const matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  blackAndWhite(multiply) {
    const matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  hue(rotation, multiply) {
    rotation = (rotation || 0) / 180 * Math.PI;
    const cosR = Math.cos(rotation);
    const sinR = Math.sin(rotation);
    const sqrt = Math.sqrt;
    const w = 1 / 3;
    const sqrW = sqrt(w);
    const a00 = cosR + (1 - cosR) * w;
    const a01 = w * (1 - cosR) - sqrW * sinR;
    const a02 = w * (1 - cosR) + sqrW * sinR;
    const a10 = w * (1 - cosR) + sqrW * sinR;
    const a11 = cosR + w * (1 - cosR);
    const a12 = w * (1 - cosR) - sqrW * sinR;
    const a20 = w * (1 - cosR) - sqrW * sinR;
    const a21 = w * (1 - cosR) + sqrW * sinR;
    const a22 = cosR + w * (1 - cosR);
    const matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  contrast(amount, multiply) {
    const v = (amount || 0) + 1;
    const o = -0.5 * (v - 1);
    const matrix = [
      v,
      0,
      0,
      0,
      o,
      0,
      v,
      0,
      0,
      o,
      0,
      0,
      v,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  saturate(amount = 0, multiply) {
    const x = amount * 2 / 3 + 1;
    const y = (x - 1) * -0.5;
    const matrix = [
      x,
      y,
      y,
      0,
      0,
      y,
      x,
      y,
      0,
      0,
      y,
      y,
      x,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(multiply) {
    const matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  sepia(multiply) {
    const matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  technicolor(multiply) {
    const matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  polaroid(multiply) {
    const matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  toBGR(multiply) {
    const matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  kodachrome(multiply) {
    const matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  browni(multiply) {
    const matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  vintage(multiply) {
    const matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  colorTone(desaturation, toned, lightColor, darkColor, multiply) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    const temp = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared;
    const [lR, lG, lB] = temp.setValue(lightColor).toArray();
    const [dR, dG, dB] = temp.setValue(darkColor).toArray();
    const matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  night(intensity, multiply) {
    intensity = intensity || 0.1;
    const matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  predator(amount, multiply) {
    const matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  lsd(multiply) {
    const matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply);
  }
  reset() {
    const matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(value) {
    this.uniforms.m = value;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
}
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;


//# sourceMappingURL=ColorMatrixFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";


//# sourceMappingURL=colorMatrix.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-color-matrix/lib/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/filter-color-matrix/lib/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorMatrixFilter": function() { return /* reexport safe */ _ColorMatrixFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.ColorMatrixFilter; }
/* harmony export */ });
/* harmony import */ var _ColorMatrixFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorMatrixFilter.mjs */ "./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisplacementFilter": function() { return /* binding */ DisplacementFilter; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _displacement_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./displacement.mjs */ "./node_modules/@pixi/filter-displacement/lib/displacement.mjs");
/* harmony import */ var _displacement2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./displacement2.mjs */ "./node_modules/@pixi/filter-displacement/lib/displacement2.mjs");




class DisplacementFilter extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(sprite, scale) {
    const maskMatrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    sprite.renderable = false;
    super(_displacement2_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _displacement_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    });
    this.maskSprite = sprite;
    this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    this.scale = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point(scale, scale);
  }
  apply(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    const wt = this.maskSprite.worldTransform;
    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(value) {
    this.uniforms.mapSampler = value;
  }
}


//# sourceMappingURL=DisplacementFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/displacement.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/displacement.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";


//# sourceMappingURL=displacement.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/displacement2.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/displacement2.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ vertex; }
/* harmony export */ });
var vertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";


//# sourceMappingURL=displacement2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-displacement/lib/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/filter-displacement/lib/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisplacementFilter": function() { return /* reexport safe */ _DisplacementFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.DisplacementFilter; }
/* harmony export */ });
/* harmony import */ var _DisplacementFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DisplacementFilter.mjs */ "./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FXAAFilter": function() { return /* binding */ FXAAFilter; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _fxaa_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fxaa.mjs */ "./node_modules/@pixi/filter-fxaa/lib/fxaa.mjs");
/* harmony import */ var _fxaa2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fxaa2.mjs */ "./node_modules/@pixi/filter-fxaa/lib/fxaa2.mjs");




class FXAAFilter extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor() {
    super(_fxaa2_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _fxaa_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);
  }
}


//# sourceMappingURL=FXAAFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/fxaa.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/fxaa.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n";


//# sourceMappingURL=fxaa.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/fxaa2.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/fxaa2.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ vertex; }
/* harmony export */ });
var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";


//# sourceMappingURL=fxaa2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-fxaa/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/filter-fxaa/lib/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FXAAFilter": function() { return /* reexport safe */ _FXAAFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.FXAAFilter; }
/* harmony export */ });
/* harmony import */ var _FXAAFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FXAAFilter.mjs */ "./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NoiseFilter": function() { return /* binding */ NoiseFilter; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _noise_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noise.mjs */ "./node_modules/@pixi/filter-noise/lib/noise.mjs");



class NoiseFilter extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Filter {
  constructor(noise = 0.5, seed = Math.random()) {
    super(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.defaultFilterVertex, _noise_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], {
      uNoise: 0,
      uSeed: 0
    });
    this.noise = noise;
    this.seed = seed;
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(value) {
    this.uniforms.uNoise = value;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(value) {
    this.uniforms.uSeed = value;
  }
}


//# sourceMappingURL=NoiseFilter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-noise/lib/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/filter-noise/lib/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NoiseFilter": function() { return /* reexport safe */ _NoiseFilter_mjs__WEBPACK_IMPORTED_MODULE_0__.NoiseFilter; }
/* harmony export */ });
/* harmony import */ var _NoiseFilter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NoiseFilter.mjs */ "./node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/filter-noise/lib/noise.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/filter-noise/lib/noise.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";


//# sourceMappingURL=noise.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/Graphics.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/Graphics.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Graphics": function() { return /* binding */ Graphics; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/graphics/lib/const.mjs");
/* harmony import */ var _GraphicsGeometry_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GraphicsGeometry.mjs */ "./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs");
/* harmony import */ var _styles_FillStyle_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./styles/FillStyle.mjs */ "./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs");
/* harmony import */ var _styles_LineStyle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles/LineStyle.mjs */ "./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/graphics/lib/utils/index.mjs");
/* harmony import */ var _utils_QuadraticUtils_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/QuadraticUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs");
/* harmony import */ var _utils_BezierUtils_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/BezierUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs");
/* harmony import */ var _utils_ArcUtils_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/ArcUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs");











const DEFAULT_SHADERS = {};
const _Graphics = class extends _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container {
  constructor(geometry = null) {
    super();
    this.shader = null;
    this.pluginName = "batch";
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this._fillStyle = new _styles_FillStyle_mjs__WEBPACK_IMPORTED_MODULE_4__.FillStyle();
    this._lineStyle = new _styles_LineStyle_mjs__WEBPACK_IMPORTED_MODULE_5__.LineStyle();
    this._matrix = null;
    this._holeMode = false;
    this.state = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
    this._geometry = geometry || new _GraphicsGeometry_mjs__WEBPACK_IMPORTED_MODULE_3__.GraphicsGeometry();
    this._geometry.refCount++;
    this._transformID = -1;
    this._tintColor = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);
    this.blendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL;
  }
  get geometry() {
    return this._geometry;
  }
  clone() {
    this.finishPoly();
    return new _Graphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    const defaultLineStyleOptions = {
      width: 0,
      texture: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE,
      color: options?.texture ? 16777215 : 0,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: _const_mjs__WEBPACK_IMPORTED_MODULE_2__.LINE_CAP.BUTT,
      join: _const_mjs__WEBPACK_IMPORTED_MODULE_2__.LINE_JOIN.MITER,
      miterLimit: 10
    };
    options = Object.assign(defaultLineStyleOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Polygon();
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x, y) {
    this.startPoly();
    this.currentPath.points[0] = x;
    this.currentPath.points[1] = y;
    return this;
  }
  lineTo(x, y) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points = this.currentPath.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  }
  _initCurve(x = 0, y = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x, y];
      }
    } else {
      this.moveTo(x, y);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    _utils_QuadraticUtils_mjs__WEBPACK_IMPORTED_MODULE_7__.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    _utils_BezierUtils_mjs__WEBPACK_IMPORTED_MODULE_8__.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points;
    const result = _utils_ArcUtils_mjs__WEBPACK_IMPORTED_MODULE_9__.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += _pixi_core__WEBPACK_IMPORTED_MODULE_0__.PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += _pixi_core__WEBPACK_IMPORTED_MODULE_0__.PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX);
      const yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps) {
      } else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    _utils_ArcUtils_mjs__WEBPACK_IMPORTED_MODULE_9__.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  }
  beginFill(color = 0, alpha) {
    return this.beginTextureFill({ texture: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE, color, alpha });
  }
  normalizeColor(options) {
    const temp = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(options.color ?? 0);
    options.color = temp.toNumber();
    options.alpha ?? (options.alpha = temp.alpha);
  }
  beginTextureFill(options) {
    const defaultOptions = {
      texture: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE,
      color: 16777215,
      matrix: null
    };
    options = Object.assign(defaultOptions, options);
    this.normalizeColor(options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x, y, width, height) {
    return this.drawShape(new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(x, y, width, height));
  }
  drawRoundedRect(x, y, width, height, radius) {
    return this.drawShape(new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RoundedRectangle(x, y, width, height, radius));
  }
  drawCircle(x, y, radius) {
    return this.drawShape(new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Circle(x, y, radius));
  }
  drawEllipse(x, y, width, height) {
    return this.drawShape(new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ellipse(x, y, width, height));
  }
  drawPolygon(...path) {
    let points;
    let closeStroke = true;
    const poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    const shape = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    geometry.updateBatches();
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i = 0; i < len; i++) {
      const gI = geometry.batches[i];
      const color = gI.style.color;
      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      const indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      const batch = {
        vertexData,
        blendMode,
        indices,
        uvs,
        _batchRGB: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(color).toRgbArray(),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  }
  _renderBatched(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i = 0, l = this.batches.length; i < l; i++) {
      const batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer) {
    const shader = this._resolveDirectShader(renderer);
    const geometry = this._geometry;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (let i = 0, l = drawCalls.length; i < l; i++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
    }
  }
  _renderDrawCallDirect(renderer, drawCall) {
    const { texArray, type, size, start } = drawCall;
    const groupTextureCount = texArray.count;
    for (let j = 0; j < groupTextureCount; j++) {
      renderer.texture.bind(texArray.elements[j], j);
    }
    renderer.geometry.draw(type, size, start);
  }
  _resolveDirectShader(renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        const { maxTextures } = renderer.plugins[pluginName];
        const sampleValues = new Int32Array(maxTextures);
        for (let i = 0; i < maxTextures; i++) {
          sampleValues[i] = i;
        }
        const uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix(),
          default: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        const program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);
    return this._geometry.containsPoint(_Graphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this._tintColor.toNumber();
      for (let i = 0; i < this.batches.length; i++) {
        const batch = this.batches[i];
        batch._tintRGB = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i = 0; i < data.length; i += 2) {
      const x = data[i];
      const y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx;
      vertexData[count++] = d * y + b * x + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
};
let Graphics = _Graphics;
Graphics.curves = _const_mjs__WEBPACK_IMPORTED_MODULE_2__.curves;
Graphics._TEMP_POINT = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();


//# sourceMappingURL=Graphics.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/GraphicsData.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/GraphicsData.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphicsData": function() { return /* binding */ GraphicsData; }
/* harmony export */ });
class GraphicsData {
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  clone() {
    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  }
}


//# sourceMappingURL=GraphicsData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphicsGeometry": function() { return /* binding */ GraphicsGeometry; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _GraphicsData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GraphicsData.mjs */ "./node_modules/@pixi/graphics/lib/GraphicsData.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/graphics/lib/utils/index.mjs");
/* harmony import */ var _utils_BatchPart_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/BatchPart.mjs */ "./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs");
/* harmony import */ var _utils_buildPoly_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/buildPoly.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs");
/* harmony import */ var _utils_buildLine_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/buildLine.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildLine.mjs");








const tmpPoint = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
const _GraphicsGeometry = class extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchGeometry {
  constructor() {
    super();
    this.closePointEps = 1e-4;
    this.boundsPadding = 0;
    this.uvsFloat32 = null;
    this.indicesUint16 = null;
    this.batchable = false;
    this.points = [];
    this.colors = [];
    this.uvs = [];
    this.indices = [];
    this.textureIds = [];
    this.graphicsData = [];
    this.drawCalls = [];
    this.batchDirty = -1;
    this.batches = [];
    this.dirty = 0;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.shapeIndex = 0;
    this._bounds = new _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Bounds();
    this.boundsDirty = -1;
  }
  get bounds() {
    this.updateBatches();
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (let i = 0; i < this.batches.length; i++) {
      const batchPart = this.batches[i];
      batchPart.reset();
      _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new _GraphicsData_mjs__WEBPACK_IMPORTED_MODULE_2__.GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new _GraphicsData_mjs__WEBPACK_IMPORTED_MODULE_2__.GraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i = 0; i < graphicsData.length; ++i) {
      const data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i2 = 0; i2 < data.holes.length; i2++) {
              const hole = data.holes[i2];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updateBatches() {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    const uvs = this.uvs;
    const graphicsData = this.graphicsData;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      const data = graphicsData[i];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      const command = _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (let j = 0; j < 2; j++) {
        const style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const index2 = this.indices.length;
        const attribIndex = this.points.length / 2;
        nextTexture.wrapMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.REPEAT;
        if (j === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        const size = this.points.length / 2 - attribIndex;
        if (size === 0)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index2, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.BATCH_POOL.pop() || new _utils_BatchPart_mjs__WEBPACK_IMPORTED_MODULE_4__.BatchPart();
          batchPart.begin(style, index2, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    const index = this.indices.length;
    const attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    const need32 = attrib > 65535;
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {
      this.indicesUint16.set(this.indices);
    } else {
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  }
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  }
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i = 0, l = this.graphicsData.length; i < l; i++) {
      const data = this.graphicsData[i];
      const fill = data.fillStyle;
      const line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  packBatches() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    const batches = this.batches;
    for (let i = 0, l = batches.length; i < l; i++) {
      const batch = batches[i];
      for (let j = 0; j < batch.size; j++) {
        const index = batch.start + j;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    const batches = this.batches;
    for (let i = 0; i < batches.length; i++) {
      if (batches[i].style.native) {
        return false;
      }
    }
    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;
  }
  buildDrawCalls() {
    let TICK = ++_pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture._globalBatch;
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    const colors = this.colors;
    const textureIds = this.textureIds;
    let currentGroup = _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchDrawCall();
      currentGroup.texArray = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLES;
    let textureCount = 0;
    let currentTexture = null;
    let textureId = 0;
    let native = false;
    let drawMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLES;
    let index = 0;
    this.drawCalls.push(currentGroup);
    for (let i = 0; i < this.batches.length; i++) {
      const data = this.batches[i];
      const maxTextures = 8;
      const style = data.style;
      const nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? _pixi_core__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.LINES : _pixi_core__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = maxTextures;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === maxTextures) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchDrawCall();
                currentGroup.texArray = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture._globalBatch = TICK;
    this.packAttributes();
  }
  packAttributes() {
    const verts = this.points;
    const uvs = this.uvs;
    const colors = this.colors;
    const textureIds = this.textureIds;
    const glPoints = new ArrayBuffer(verts.length * 3 * 4);
    const f32 = new Float32Array(glPoints);
    const u32 = new Uint32Array(glPoints);
    let p = 0;
    for (let i = 0; i < verts.length / 2; i++) {
      f32[p++] = verts[i * 2];
      f32[p++] = verts[i * 2 + 1];
      f32[p++] = uvs[i * 2];
      f32[p++] = uvs[i * 2 + 1];
      u32[p++] = colors[i];
      f32[p++] = textureIds[i];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  }
  processFill(data) {
    if (data.holes.length) {
      _utils_buildPoly_mjs__WEBPACK_IMPORTED_MODULE_5__.buildPoly.triangulate(data, this);
    } else {
      const command = _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  }
  processLine(data) {
    (0,_utils_buildLine_mjs__WEBPACK_IMPORTED_MODULE_6__.buildLine)(data, this);
    for (let i = 0; i < data.holes.length; i++) {
      (0,_utils_buildLine_mjs__WEBPACK_IMPORTED_MODULE_6__.buildLine)(data.holes[i], this);
    }
  }
  processHoles(holes) {
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      const command = _utils_index_mjs__WEBPACK_IMPORTED_MODULE_3__.FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  calculateBounds() {
    const bounds = this._bounds;
    bounds.clear();
    bounds.addVertexData(this.points, 0, this.points.length);
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  transformPoints(points, matrix) {
    for (let i = 0; i < points.length / 2; i++) {
      const x = points[i * 2];
      const y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  }
  addColors(colors, color, alpha, size, offset = 0) {
    const bgr = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(color).toLittleEndianNumber();
    const result = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(bgr).toPremultiplied(alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (let i = 0; i < size; i++) {
      colors[offset + i] = result;
    }
  }
  addTextureIds(textureIds, id, size, offset = 0) {
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (let i = 0; i < size; i++) {
      textureIds[offset + i] = id;
    }
  }
  addUvs(verts, uvs, texture, start, size, matrix = null) {
    let index = 0;
    const uvsStart = uvs.length;
    const frame = texture.frame;
    while (index < size) {
      let x = verts[(start + index) * 2];
      let y = verts[(start + index) * 2 + 1];
      if (matrix) {
        const nx = matrix.a * x + matrix.c * y + matrix.tx;
        y = matrix.b * x + matrix.d * y + matrix.ty;
        x = nx;
      }
      index++;
      uvs.push(x / frame.width, y / frame.height);
    }
    const baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  }
  adjustUvs(uvs, texture, start, size) {
    const baseTexture = texture.baseTexture;
    const eps = 1e-6;
    const finish = start + size * 2;
    const frame = texture.frame;
    const scaleX = frame.width / baseTexture.width;
    const scaleY = frame.height / baseTexture.height;
    let offsetX = frame.x / frame.width;
    let offsetY = frame.y / frame.height;
    let minX = Math.floor(uvs[start] + eps);
    let minY = Math.floor(uvs[start + 1] + eps);
    for (let i = start + 2; i < finish; i += 2) {
      minX = Math.min(minX, Math.floor(uvs[i] + eps));
      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (let i = start; i < finish; i += 2) {
      uvs[i] = (uvs[i] + offsetX) * scaleX;
      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
    }
  }
};
let GraphicsGeometry = _GraphicsGeometry;
GraphicsGeometry.BATCHABLE_SIZE = 100;


//# sourceMappingURL=GraphicsGeometry.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/const.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/const.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GRAPHICS_CURVES": function() { return /* binding */ GRAPHICS_CURVES; },
/* harmony export */   "LINE_CAP": function() { return /* binding */ LINE_CAP; },
/* harmony export */   "LINE_JOIN": function() { return /* binding */ LINE_JOIN; },
/* harmony export */   "curves": function() { return /* binding */ curves; }
/* harmony export */ });
var LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
  return LINE_JOIN2;
})(LINE_JOIN || {});
var LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
  return LINE_CAP2;
})(LINE_CAP || {});
const curves = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(length, defaultSegments = 20) {
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    let result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
const GRAPHICS_CURVES = curves;


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillStyle": function() { return /* reexport safe */ _styles_FillStyle_mjs__WEBPACK_IMPORTED_MODULE_5__.FillStyle; },
/* harmony export */   "GRAPHICS_CURVES": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_1__.GRAPHICS_CURVES; },
/* harmony export */   "Graphics": function() { return /* reexport safe */ _Graphics_mjs__WEBPACK_IMPORTED_MODULE_2__.Graphics; },
/* harmony export */   "GraphicsData": function() { return /* reexport safe */ _GraphicsData_mjs__WEBPACK_IMPORTED_MODULE_3__.GraphicsData; },
/* harmony export */   "GraphicsGeometry": function() { return /* reexport safe */ _GraphicsGeometry_mjs__WEBPACK_IMPORTED_MODULE_4__.GraphicsGeometry; },
/* harmony export */   "LINE_CAP": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_CAP; },
/* harmony export */   "LINE_JOIN": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN; },
/* harmony export */   "LineStyle": function() { return /* reexport safe */ _styles_LineStyle_mjs__WEBPACK_IMPORTED_MODULE_6__.LineStyle; },
/* harmony export */   "curves": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_1__.curves; },
/* harmony export */   "graphicsUtils": function() { return /* binding */ graphicsUtils; }
/* harmony export */ });
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/graphics/lib/utils/index.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/graphics/lib/const.mjs");
/* harmony import */ var _Graphics_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Graphics.mjs */ "./node_modules/@pixi/graphics/lib/Graphics.mjs");
/* harmony import */ var _GraphicsData_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GraphicsData.mjs */ "./node_modules/@pixi/graphics/lib/GraphicsData.mjs");
/* harmony import */ var _GraphicsGeometry_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GraphicsGeometry.mjs */ "./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs");
/* harmony import */ var _styles_FillStyle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles/FillStyle.mjs */ "./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs");
/* harmony import */ var _styles_LineStyle_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./styles/LineStyle.mjs */ "./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs");
/* harmony import */ var _utils_buildPoly_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/buildPoly.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs");
/* harmony import */ var _utils_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/buildCircle.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs");
/* harmony import */ var _utils_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/buildRectangle.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs");
/* harmony import */ var _utils_buildRoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/buildRoundedRectangle.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs");
/* harmony import */ var _utils_buildLine_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/buildLine.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildLine.mjs");
/* harmony import */ var _utils_ArcUtils_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/ArcUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs");
/* harmony import */ var _utils_BezierUtils_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/BezierUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs");
/* harmony import */ var _utils_QuadraticUtils_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/QuadraticUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs");
/* harmony import */ var _utils_BatchPart_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/BatchPart.mjs */ "./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs");

















const graphicsUtils = {
  buildPoly: _utils_buildPoly_mjs__WEBPACK_IMPORTED_MODULE_7__.buildPoly,
  buildCircle: _utils_buildCircle_mjs__WEBPACK_IMPORTED_MODULE_8__.buildCircle,
  buildRectangle: _utils_buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_9__.buildRectangle,
  buildRoundedRectangle: _utils_buildRoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_10__.buildRoundedRectangle,
  buildLine: _utils_buildLine_mjs__WEBPACK_IMPORTED_MODULE_11__.buildLine,
  ArcUtils: _utils_ArcUtils_mjs__WEBPACK_IMPORTED_MODULE_12__.ArcUtils,
  BezierUtils: _utils_BezierUtils_mjs__WEBPACK_IMPORTED_MODULE_13__.BezierUtils,
  QuadraticUtils: _utils_QuadraticUtils_mjs__WEBPACK_IMPORTED_MODULE_14__.QuadraticUtils,
  BatchPart: _utils_BatchPart_mjs__WEBPACK_IMPORTED_MODULE_15__.BatchPart,
  FILL_COMMANDS: _utils_index_mjs__WEBPACK_IMPORTED_MODULE_0__.FILL_COMMANDS,
  BATCH_POOL: _utils_index_mjs__WEBPACK_IMPORTED_MODULE_0__.BATCH_POOL,
  DRAW_CALL_POOL: _utils_index_mjs__WEBPACK_IMPORTED_MODULE_0__.DRAW_CALL_POOL
};


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillStyle": function() { return /* binding */ FillStyle; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class FillStyle {
  constructor() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  clone() {
    const obj = new FillStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
  }
}


//# sourceMappingURL=FillStyle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineStyle": function() { return /* binding */ LineStyle; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/graphics/lib/const.mjs");
/* harmony import */ var _FillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FillStyle.mjs */ "./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs");



class LineStyle extends _FillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.FillStyle {
  constructor() {
    super(...arguments);
    this.width = 0;
    this.alignment = 0.5;
    this.native = false;
    this.cap = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.LINE_CAP.BUTT;
    this.join = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.LINE_JOIN.MITER;
    this.miterLimit = 10;
  }
  clone() {
    const obj = new LineStyle();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  }
  reset() {
    super.reset();
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  }
}


//# sourceMappingURL=LineStyle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArcUtils": function() { return /* binding */ ArcUtils; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/graphics/lib/const.mjs");



class ArcUtils {
  static curveTo(x1, y1, x2, y2, radius, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const a1 = fromY - y1;
    const b1 = fromX - x1;
    const a2 = y2 - y1;
    const b2 = x2 - x1;
    const mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    const dd = a1 * a1 + b1 * b1;
    const cc = a2 * a2 + b2 * b2;
    const tt = a1 * a2 + b1 * b2;
    const k1 = radius * Math.sqrt(dd) / mm;
    const k2 = radius * Math.sqrt(cc) / mm;
    const j1 = k1 * tt / dd;
    const j2 = k2 * tt / cc;
    const cx = k1 * b2 + k2 * b1;
    const cy = k1 * a2 + k2 * a1;
    const px = b1 * (k2 + j1);
    const py = a1 * (k2 + j1);
    const qx = b2 * (k1 + j2);
    const qy = a2 * (k1 + j2);
    const startAngle = Math.atan2(py - cy, px - cx);
    const endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  }
  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    const sweep = endAngle - startAngle;
    const n = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / _pixi_core__WEBPACK_IMPORTED_MODULE_0__.PI_2) * 40);
    const theta = sweep / (n * 2);
    const theta2 = theta * 2;
    const cTheta = Math.cos(theta);
    const sTheta = Math.sin(theta);
    const segMinus = n - 1;
    const remainder = segMinus % 1 / segMinus;
    for (let i = 0; i <= segMinus; ++i) {
      const real = i + remainder * i;
      const angle = theta + startAngle + theta2 * real;
      const c = Math.cos(angle);
      const s = -Math.sin(angle);
      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
    }
  }
}


//# sourceMappingURL=ArcUtils.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchPart": function() { return /* binding */ BatchPart; }
/* harmony export */ });
class BatchPart {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  }
}


//# sourceMappingURL=BatchPart.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BezierUtils": function() { return /* binding */ BezierUtils; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/graphics/lib/const.mjs");


class BezierUtils {
  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    const n = 10;
    let result = 0;
    let t = 0;
    let t2 = 0;
    let t3 = 0;
    let nt = 0;
    let nt2 = 0;
    let nt3 = 0;
    let x = 0;
    let y = 0;
    let dx = 0;
    let dy = 0;
    let prevX = fromX;
    let prevY = fromY;
    for (let i = 1; i <= n; ++i) {
      t = i / n;
      t2 = t * t;
      t3 = t2 * t;
      nt = 1 - t;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
      dx = prevX - x;
      dy = prevY - y;
      prevX = x;
      prevY = y;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  }
  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    points.length -= 2;
    const n = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    let dt = 0;
    let dt2 = 0;
    let dt3 = 0;
    let t2 = 0;
    let t3 = 0;
    points.push(fromX, fromY);
    for (let i = 1, j = 0; i <= n; ++i) {
      j = i / n;
      dt = 1 - j;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j * j;
      t3 = t2 * j;
      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  }
}


//# sourceMappingURL=BezierUtils.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QuadraticUtils": function() { return /* binding */ QuadraticUtils; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/graphics/lib/const.mjs");


class QuadraticUtils {
  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
    const ax = fromX - 2 * cpX + toX;
    const ay = fromY - 2 * cpY + toY;
    const bx = 2 * cpX - 2 * fromX;
    const by = 2 * cpY - 2 * fromY;
    const a = 4 * (ax * ax + ay * ay);
    const b = 4 * (ax * bx + ay * by);
    const c = bx * bx + by * by;
    const s = 2 * Math.sqrt(a + b + c);
    const a2 = Math.sqrt(a);
    const a32 = 2 * a * a2;
    const c2 = 2 * Math.sqrt(c);
    const ba = b / a2;
    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
  }
  static curveTo(cpX, cpY, toX, toY, points) {
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    const n = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    let xa = 0;
    let ya = 0;
    for (let i = 1; i <= n; ++i) {
      const j = i / n;
      xa = fromX + (cpX - fromX) * j;
      ya = fromY + (cpY - fromY) * j;
      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
    }
  }
}


//# sourceMappingURL=QuadraticUtils.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildCircle": function() { return /* binding */ buildCircle; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const buildCircle = {
  build(graphicsData) {
    const points = graphicsData.points;
    let x;
    let y;
    let dx;
    let dy;
    let rx;
    let ry;
    if (graphicsData.type === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.ELIP) {
      const ellipse = graphicsData.shape;
      x = ellipse.x;
      y = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      const roundedRect = graphicsData.shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
      points.length = 0;
      return;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m;
    if (m === 0) {
      return;
    }
    if (n === 0) {
      points.length = 8;
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y - dy;
      return;
    }
    let j1 = 0;
    let j2 = n * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m;
    {
      const x0 = dx + rx;
      const y0 = dy;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      if (dy) {
        const y2 = y - y0;
        points[j3++] = x2;
        points[j3++] = y2;
        points[--j4] = y2;
        points[--j4] = x1;
      }
    }
    for (let i = 1; i < n; i++) {
      const a = Math.PI / 2 * (i / n);
      const x0 = dx + Math.cos(a) * rx;
      const y0 = dy + Math.sin(a) * ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x2;
      points[j3++] = x2;
      points[j3++] = y2;
      points[--j4] = y2;
      points[--j4] = x1;
    }
    {
      const x0 = dx;
      const y0 = dy + ry;
      const x1 = x + x0;
      const x2 = x - x0;
      const y1 = y + y0;
      const y2 = y - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x2;
        points[j1++] = y1;
        points[--j4] = y2;
        points[--j4] = x2;
      }
    }
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length === 0) {
      return;
    }
    let vertPos = verts.length / 2;
    const center = vertPos;
    let x;
    let y;
    if (graphicsData.type !== _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.RREC) {
      const circle = graphicsData.shape;
      x = circle.x;
      y = circle.y;
    } else {
      const roundedRect = graphicsData.shape;
      x = roundedRect.x + roundedRect.width / 2;
      y = roundedRect.y + roundedRect.height / 2;
    }
    const matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
    vertPos++;
    verts.push(points[0], points[1]);
    for (let i = 2; i < points.length; i += 2) {
      verts.push(points[i], points[i + 1]);
      indices.push(vertPos++, center, vertPos);
    }
    indices.push(center + 1, center, vertPos);
  }
};


//# sourceMappingURL=buildCircle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildLine.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildLine.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildLine": function() { return /* binding */ buildLine; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/graphics/lib/const.mjs");



function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy, eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy, sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy, ex, ey);
  } else {
    verts.push(sx, sy, cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);
    }
    verts.push(ex, ey, cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  const shape = graphicsData.shape;
  let points = graphicsData.points || shape.points.slice();
  const eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = graphicsData.lineStyle;
  const firstPoint = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point(points[0], points[1]);
  const lastPoint = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = shape.type !== _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLY || shape.closeStroke;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = graphicsGeometry.points;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpx = -(y0 - y1);
  let perpy = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  const ratio = style.alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (dot >= 0) {
        if (style.join === _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.ROUND) {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);
      }
      continue;
    }
    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pdist <= smallerInsideDiagonalSq;
    let join = style.join;
    if (join === _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {
      join = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.BEVEL;
    }
    if (insideMiterOk) {
      switch (join) {
        case _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.MITER: {
          verts.push(imx, imy, omx, omy);
          break;
        }
        case _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.BEVEL: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          indexCount += 2;
          break;
        }
        case _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.ROUND: {
          if (clockwise) {
            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
          } else {
            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);
          }
          break;
        }
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      switch (join) {
        case _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.MITER: {
          if (clockwise) {
            verts.push(omx, omy, omx, omy);
          } else {
            verts.push(imx, imy, imx, imy);
          }
          indexCount += 2;
          break;
        }
        case _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_JOIN.ROUND: {
          if (clockwise) {
            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
          } else {
            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
          }
          break;
        }
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === _const_mjs__WEBPACK_IMPORTED_MODULE_1__.LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  const indices = graphicsGeometry.indices;
  const eps2 = _const_mjs__WEBPACK_IMPORTED_MODULE_1__.curves.epsilon * _const_mjs__WEBPACK_IMPORTED_MODULE_1__.curves.epsilon;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  let i = 0;
  const shape = graphicsData.shape;
  const points = graphicsData.points || shape.points;
  const closedShape = shape.type !== _pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLY || shape.closeStroke;
  if (points.length === 0)
    return;
  const verts = graphicsGeometry.points;
  const indices = graphicsGeometry.indices;
  const length = points.length / 2;
  const startIndex = verts.length / 2;
  let currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts.push(points[i * 2], points[i * 2 + 1]);
    indices.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}


//# sourceMappingURL=buildLine.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildPoly": function() { return /* binding */ buildPoly; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


function fixOrientation(points, hole = false) {
  const m = points.length;
  if (m < 6) {
    return;
  }
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area > 0 || hole && area <= 0) {
    const n = m / 2;
    for (let i = n + n % 2; i < m; i += 2) {
      const i1 = m - i - 2;
      const i2 = m - i - 1;
      const i3 = i;
      const i4 = i + 1;
      [points[i1], points[i3]] = [points[i3], points[i1]];
      [points[i2], points[i4]] = [points[i4], points[i2]];
    }
  }
}
const buildPoly = {
  build(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate(graphicsData, graphicsGeometry) {
    let points = graphicsData.points;
    const holes = graphicsData.holes;
    const verts = graphicsGeometry.points;
    const indices = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      const holeArray = [];
      for (let i = 0; i < holes.length; i++) {
        const hole = holes[i];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      const triangles = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.earcut(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      const vertPos = verts.length / 2;
      for (let i = 0; i < triangles.length; i += 3) {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i + 1] + vertPos);
        indices.push(triangles[i + 2] + vertPos);
      }
      for (let i = 0; i < points.length; i++) {
        verts.push(points[i]);
      }
    }
  }
};


//# sourceMappingURL=buildPoly.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildRectangle": function() { return /* binding */ buildRectangle; }
/* harmony export */ });
const buildRectangle = {
  build(graphicsData) {
    const rectData = graphicsData.shape;
    const x = rectData.x;
    const y = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points = graphicsData.points;
    points.length = 0;
    if (!(width >= 0 && height >= 0)) {
      return;
    }
    points.push(x, y, x + width, y, x + width, y + height, x, y + height);
  },
  triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points;
    const verts = graphicsGeometry.points;
    if (points.length === 0) {
      return;
    }
    const vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};


//# sourceMappingURL=buildRectangle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildRoundedRectangle": function() { return /* binding */ buildRoundedRectangle; }
/* harmony export */ });
/* harmony import */ var _buildCircle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buildCircle.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs");


const buildRoundedRectangle = {
  build(graphicsData) {
    _buildCircle_mjs__WEBPACK_IMPORTED_MODULE_0__.buildCircle.build(graphicsData);
  },
  triangulate(graphicsData, graphicsGeometry) {
    _buildCircle_mjs__WEBPACK_IMPORTED_MODULE_0__.buildCircle.triangulate(graphicsData, graphicsGeometry);
  }
};


//# sourceMappingURL=buildRoundedRectangle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/graphics/lib/utils/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/graphics/lib/utils/index.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArcUtils": function() { return /* reexport safe */ _ArcUtils_mjs__WEBPACK_IMPORTED_MODULE_5__.ArcUtils; },
/* harmony export */   "BATCH_POOL": function() { return /* binding */ BATCH_POOL; },
/* harmony export */   "BatchPart": function() { return /* reexport safe */ _BatchPart_mjs__WEBPACK_IMPORTED_MODULE_6__.BatchPart; },
/* harmony export */   "BezierUtils": function() { return /* reexport safe */ _BezierUtils_mjs__WEBPACK_IMPORTED_MODULE_7__.BezierUtils; },
/* harmony export */   "DRAW_CALL_POOL": function() { return /* binding */ DRAW_CALL_POOL; },
/* harmony export */   "FILL_COMMANDS": function() { return /* binding */ FILL_COMMANDS; },
/* harmony export */   "QuadraticUtils": function() { return /* reexport safe */ _QuadraticUtils_mjs__WEBPACK_IMPORTED_MODULE_9__.QuadraticUtils; },
/* harmony export */   "buildCircle": function() { return /* reexport safe */ _buildCircle_mjs__WEBPACK_IMPORTED_MODULE_1__.buildCircle; },
/* harmony export */   "buildLine": function() { return /* reexport safe */ _buildLine_mjs__WEBPACK_IMPORTED_MODULE_8__.buildLine; },
/* harmony export */   "buildPoly": function() { return /* reexport safe */ _buildPoly_mjs__WEBPACK_IMPORTED_MODULE_2__.buildPoly; },
/* harmony export */   "buildRectangle": function() { return /* reexport safe */ _buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_3__.buildRectangle; },
/* harmony export */   "buildRoundedRectangle": function() { return /* reexport safe */ _buildRoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_4__.buildRoundedRectangle; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _buildCircle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buildCircle.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs");
/* harmony import */ var _buildPoly_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buildPoly.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs");
/* harmony import */ var _buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./buildRectangle.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs");
/* harmony import */ var _buildRoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./buildRoundedRectangle.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs");
/* harmony import */ var _ArcUtils_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ArcUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs");
/* harmony import */ var _BatchPart_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BatchPart.mjs */ "./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs");
/* harmony import */ var _BezierUtils_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BezierUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs");
/* harmony import */ var _buildLine_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./buildLine.mjs */ "./node_modules/@pixi/graphics/lib/utils/buildLine.mjs");
/* harmony import */ var _QuadraticUtils_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./QuadraticUtils.mjs */ "./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs");















const FILL_COMMANDS = {
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLY]: _buildPoly_mjs__WEBPACK_IMPORTED_MODULE_2__.buildPoly,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRC]: _buildCircle_mjs__WEBPACK_IMPORTED_MODULE_1__.buildCircle,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.ELIP]: _buildCircle_mjs__WEBPACK_IMPORTED_MODULE_1__.buildCircle,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.RECT]: _buildRectangle_mjs__WEBPACK_IMPORTED_MODULE_3__.buildRectangle,
  [_pixi_core__WEBPACK_IMPORTED_MODULE_0__.SHAPES.RREC]: _buildRoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_4__.buildRoundedRectangle
};
const BATCH_POOL = [];
const DRAW_CALL_POOL = [];


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/IPoint.mjs":
/*!************************************************!*\
  !*** ./node_modules/@pixi/math/lib/IPoint.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=IPoint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/IPointData.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/math/lib/IPointData.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=IPointData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/Matrix.mjs":
/*!************************************************!*\
  !*** ./node_modules/@pixi/math/lib/Matrix.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix": function() { return /* binding */ Matrix; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/math/lib/const.mjs");
/* harmony import */ var _Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point.mjs */ "./node_modules/@pixi/math/lib/Point.mjs");



class Matrix {
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  set(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  apply(pos, newPos) {
    newPos = newPos || new _Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  }
  applyInverse(pos, newPos) {
    newPos = newPos || new _Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();
    const id = 1 / (this.a * this.d + this.c * -this.b);
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  }
  translate(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  }
  scale(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  }
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  decompose(transform) {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(_const_mjs__WEBPACK_IMPORTED_MODULE_0__.PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
    return transform;
  }
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  toString() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  static get IDENTITY() {
    return new Matrix();
  }
  static get TEMP_MATRIX() {
    return new Matrix();
  }
}


//# sourceMappingURL=Matrix.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/ObservablePoint.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/ObservablePoint.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObservablePoint": function() { return /* binding */ ObservablePoint; }
/* harmony export */ });
class ObservablePoint {
  constructor(cb, scope, x = 0, y = 0) {
    this._x = x;
    this._y = y;
    this.cb = cb;
    this.scope = scope;
  }
  clone(cb = this.cb, scope = this.scope) {
    return new ObservablePoint(cb, scope, this._x, this._y);
  }
  set(x = 0, y = x) {
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyFrom(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this.cb.call(this.scope);
    }
    return this;
  }
  copyTo(p) {
    p.set(this._x, this._y);
    return p;
  }
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
  toString() {
    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this.cb.call(this.scope);
    }
  }
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this.cb.call(this.scope);
    }
  }
}


//# sourceMappingURL=ObservablePoint.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/Point.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/math/lib/Point.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Point": function() { return /* binding */ Point; }
/* harmony export */ });
class Point {
  constructor(x = 0, y = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p) {
    this.set(p.x, p.y);
    return this;
  }
  copyTo(p) {
    p.set(this.x, this.y);
    return p;
  }
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  set(x = 0, y = x) {
    this.x = x;
    this.y = y;
    return this;
  }
  toString() {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
  }
}


//# sourceMappingURL=Point.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/Transform.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/math/lib/Transform.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transform": function() { return /* binding */ Transform; }
/* harmony export */ });
/* harmony import */ var _Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix.mjs */ "./node_modules/@pixi/math/lib/Matrix.mjs");
/* harmony import */ var _ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObservablePoint.mjs */ "./node_modules/@pixi/math/lib/ObservablePoint.mjs");



const _Transform = class {
  constructor() {
    this.worldTransform = new _Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.localTransform = new _Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.position = new _ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new _ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new _ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new _ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  }
  toString() {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  updateLocalTransform() {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  }
  updateTransform(parentTransform) {
    const lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      const pt = parentTransform.worldTransform;
      const wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  }
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this._localID++;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this.updateSkew();
    }
  }
};
let Transform = _Transform;
Transform.IDENTITY = new _Transform();


//# sourceMappingURL=Transform.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/const.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/math/lib/const.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEG_TO_RAD": function() { return /* binding */ DEG_TO_RAD; },
/* harmony export */   "PI_2": function() { return /* binding */ PI_2; },
/* harmony export */   "RAD_TO_DEG": function() { return /* binding */ RAD_TO_DEG; },
/* harmony export */   "SHAPES": function() { return /* binding */ SHAPES; }
/* harmony export */ });
const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
var SHAPES = /* @__PURE__ */ ((SHAPES2) => {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
  return SHAPES2;
})(SHAPES || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/groupD8.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/math/lib/groupD8.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "groupD8": function() { return /* binding */ groupD8; }
/* harmony export */ });
/* harmony import */ var _Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix.mjs */ "./node_modules/@pixi/math/lib/Matrix.mjs");


const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j = 0; j < 16; j++) {
      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (let k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new _Matrix_mjs__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (ind) => ux[ind],
  uY: (ind) => uy[ind],
  vX: (ind) => vx[ind],
  vY: (ind) => vy[ind],
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  rotate180: (rotation) => rotation ^ 4,
  isVertical: (rotation) => (rotation & 3) === 2,
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};


//# sourceMappingURL=groupD8.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/math/lib/index.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": function() { return /* reexport safe */ _shapes_Circle_mjs__WEBPACK_IMPORTED_MODULE_0__.Circle; },
/* harmony export */   "DEG_TO_RAD": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_12__.DEG_TO_RAD; },
/* harmony export */   "Ellipse": function() { return /* reexport safe */ _shapes_Ellipse_mjs__WEBPACK_IMPORTED_MODULE_1__.Ellipse; },
/* harmony export */   "Matrix": function() { return /* reexport safe */ _Matrix_mjs__WEBPACK_IMPORTED_MODULE_8__.Matrix; },
/* harmony export */   "ObservablePoint": function() { return /* reexport safe */ _ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_9__.ObservablePoint; },
/* harmony export */   "PI_2": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_12__.PI_2; },
/* harmony export */   "Point": function() { return /* reexport safe */ _Point_mjs__WEBPACK_IMPORTED_MODULE_10__.Point; },
/* harmony export */   "Polygon": function() { return /* reexport safe */ _shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon; },
/* harmony export */   "RAD_TO_DEG": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_12__.RAD_TO_DEG; },
/* harmony export */   "Rectangle": function() { return /* reexport safe */ _shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_3__.Rectangle; },
/* harmony export */   "RoundedRectangle": function() { return /* reexport safe */ _shapes_RoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_4__.RoundedRectangle; },
/* harmony export */   "SHAPES": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_12__.SHAPES; },
/* harmony export */   "Transform": function() { return /* reexport safe */ _Transform_mjs__WEBPACK_IMPORTED_MODULE_11__.Transform; },
/* harmony export */   "groupD8": function() { return /* reexport safe */ _groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__.groupD8; }
/* harmony export */ });
/* harmony import */ var _shapes_Circle_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes/Circle.mjs */ "./node_modules/@pixi/math/lib/shapes/Circle.mjs");
/* harmony import */ var _shapes_Ellipse_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shapes/Ellipse.mjs */ "./node_modules/@pixi/math/lib/shapes/Ellipse.mjs");
/* harmony import */ var _shapes_Polygon_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shapes/Polygon.mjs */ "./node_modules/@pixi/math/lib/shapes/Polygon.mjs");
/* harmony import */ var _shapes_Rectangle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shapes/Rectangle.mjs */ "./node_modules/@pixi/math/lib/shapes/Rectangle.mjs");
/* harmony import */ var _shapes_RoundedRectangle_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shapes/RoundedRectangle.mjs */ "./node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs");
/* harmony import */ var _groupD8_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./groupD8.mjs */ "./node_modules/@pixi/math/lib/groupD8.mjs");
/* harmony import */ var _IPoint_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./IPoint.mjs */ "./node_modules/@pixi/math/lib/IPoint.mjs");
/* harmony import */ var _IPointData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IPointData.mjs */ "./node_modules/@pixi/math/lib/IPointData.mjs");
/* harmony import */ var _Matrix_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Matrix.mjs */ "./node_modules/@pixi/math/lib/Matrix.mjs");
/* harmony import */ var _ObservablePoint_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ObservablePoint.mjs */ "./node_modules/@pixi/math/lib/ObservablePoint.mjs");
/* harmony import */ var _Point_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Point.mjs */ "./node_modules/@pixi/math/lib/Point.mjs");
/* harmony import */ var _Transform_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Transform.mjs */ "./node_modules/@pixi/math/lib/Transform.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/math/lib/const.mjs");













//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Circle.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Circle.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Circle": function() { return /* binding */ Circle; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/math/lib/const.mjs");
/* harmony import */ var _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rectangle.mjs */ "./node_modules/@pixi/math/lib/shapes/Rectangle.mjs");



class Circle {
  constructor(x = 0, y = 0, radius = 0) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.type = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRC;
  }
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  contains(x, y) {
    if (this.radius <= 0) {
      return false;
    }
    const r2 = this.radius * this.radius;
    let dx = this.x - x;
    let dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  getBounds() {
    return new _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }
  toString() {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}


//# sourceMappingURL=Circle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Ellipse.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Ellipse.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ellipse": function() { return /* binding */ Ellipse; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/math/lib/const.mjs");
/* harmony import */ var _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rectangle.mjs */ "./node_modules/@pixi/math/lib/shapes/Rectangle.mjs");



class Ellipse {
  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
    this.x = x;
    this.y = y;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.SHAPES.ELIP;
  }
  clone() {
    return new Ellipse(this.x, this.y, this.width, this.height);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    let normx = (x - this.x) / this.width;
    let normy = (y - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  getBounds() {
    return new _Rectangle_mjs__WEBPACK_IMPORTED_MODULE_1__.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }
  toString() {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}


//# sourceMappingURL=Ellipse.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Polygon.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Polygon.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Polygon": function() { return /* binding */ Polygon; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/math/lib/const.mjs");


class Polygon {
  constructor(...points) {
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p = [];
      for (let i = 0, il = flat.length; i < il; i++) {
        p.push(flat[i].x, flat[i].y);
      }
      flat = p;
    }
    this.points = flat;
    this.type = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLY;
    this.closeStroke = true;
  }
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  }
  contains(x, y) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i = 0, j = length - 1; i < length; j = i++) {
      const xi = this.points[i * 2];
      const yi = this.points[i * 2 + 1];
      const xj = this.points[j * 2];
      const yj = this.points[j * 2 + 1];
      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  toString() {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
}


//# sourceMappingURL=Polygon.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/Rectangle.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/Rectangle.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rectangle": function() { return /* binding */ Rectangle; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/math/lib/const.mjs");
/* harmony import */ var _Point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Point.mjs */ "./node_modules/@pixi/math/lib/Point.mjs");



const tempPoints = [new _Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(), new _Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(), new _Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(), new _Point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point()];
class Rectangle {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = Number(x);
    this.y = Number(y);
    this.width = Number(width);
    this.height = Number(height);
    this.type = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.SHAPES.RECT;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  copyTo(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s * (lb.y - lt.y);
    const ny = s * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s * (lt.y - rt.y);
    const my = s * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  toString() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}


//# sourceMappingURL=Rectangle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoundedRectangle": function() { return /* binding */ RoundedRectangle; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/math/lib/const.mjs");


class RoundedRectangle {
  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.SHAPES.RREC;
  }
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.x + this.width) {
      if (y >= this.y && y <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return true;
        }
        let dx = x - (this.x + radius);
        let dy = y - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  toString() {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}


//# sourceMappingURL=RoundedRectangle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NineSlicePlane": function() { return /* binding */ NineSlicePlane; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _SimplePlane_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SimplePlane.mjs */ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs");



const DEFAULT_BORDER_SIZE = 10;
class NineSlicePlane extends _SimplePlane_mjs__WEBPACK_IMPORTED_MODULE_1__.SimplePlane {
  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    super(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE, 4, 4);
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    this._width = this._origWidth;
    this._height = this._origHeight;
    this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;
    this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;
    this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;
    this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;
    this.texture = texture;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  updateHorizontalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  }
  updateVerticalVertices() {
    const vertices = this.vertices;
    const scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  }
  _getMinScale() {
    const w = this._leftWidth + this._rightWidth;
    const scaleW = this._width > w ? 1 : this._width / w;
    const h = this._topHeight + this._bottomHeight;
    const scaleH = this._height > h ? 1 : this._height / h;
    const scale = Math.min(scaleW, scaleH);
    return scale;
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this._refresh();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this._refresh();
  }
  get leftWidth() {
    return this._leftWidth;
  }
  set leftWidth(value) {
    this._leftWidth = value;
    this._refresh();
  }
  get rightWidth() {
    return this._rightWidth;
  }
  set rightWidth(value) {
    this._rightWidth = value;
    this._refresh();
  }
  get topHeight() {
    return this._topHeight;
  }
  set topHeight(value) {
    this._topHeight = value;
    this._refresh();
  }
  get bottomHeight() {
    return this._bottomHeight;
  }
  set bottomHeight(value) {
    this._bottomHeight = value;
    this._refresh();
  }
  _refresh() {
    const texture = this.texture;
    const uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    const _uvw = 1 / this._origWidth;
    const _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  }
}


//# sourceMappingURL=NineSlicePlane.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleMesh": function() { return /* binding */ SimpleMesh; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.mjs");



class SimpleMesh extends _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh {
  constructor(texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY, vertices, uvs, indices, drawMode) {
    const geometry = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__.MeshGeometry(vertices, uvs, indices);
    geometry.getBuffer("aVertexPosition").static = false;
    const meshMaterial = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__.MeshMaterial(texture);
    super(geometry, meshMaterial, null, drawMode);
    this.autoUpdate = true;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer);
  }
}


//# sourceMappingURL=SimpleMesh.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimplePlane": function() { return /* binding */ SimplePlane; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.mjs");
/* harmony import */ var _geometry_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry/PlaneGeometry.mjs */ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs");




class SimplePlane extends _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh {
  constructor(texture, verticesX, verticesY) {
    const planeGeometry = new _geometry_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    const meshMaterial = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__.MeshMaterial(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.WHITE);
    super(planeGeometry, meshMaterial);
    this.texture = texture;
    this.autoResize = true;
  }
  textureUpdated() {
    this._textureID = this.shader.texture._updateID;
    const geometry = this.geometry;
    const { width, height } = this.shader.texture;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  }
  set texture(value) {
    if (this.shader.texture === value) {
      return;
    }
    this.shader.texture = value;
    this._textureID = -1;
    if (value.baseTexture.valid) {
      this.textureUpdated();
    } else {
      value.once("update", this.textureUpdated, this);
    }
  }
  get texture() {
    return this.shader.texture;
  }
  _render(renderer) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    super._render(renderer);
  }
  destroy(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    super.destroy(options);
  }
}


//# sourceMappingURL=SimplePlane.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleRope": function() { return /* binding */ SimpleRope; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.mjs");
/* harmony import */ var _geometry_RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry/RopeGeometry.mjs */ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs");




class SimpleRope extends _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh {
  constructor(texture, points, textureScale = 0) {
    const ropeGeometry = new _geometry_RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.RopeGeometry(texture.height, points, textureScale);
    const meshMaterial = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_1__.MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.REPEAT;
    }
    super(ropeGeometry, meshMaterial);
    this.autoUpdate = true;
  }
  _render(renderer) {
    const geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    super._render(renderer);
  }
}


//# sourceMappingURL=SimpleRope.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlaneGeometry": function() { return /* binding */ PlaneGeometry; }
/* harmony export */ });
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.mjs");


class PlaneGeometry extends _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry {
  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
    super();
    this.segWidth = segWidth;
    this.segHeight = segHeight;
    this.width = width;
    this.height = height;
    this.build();
  }
  build() {
    const total = this.segWidth * this.segHeight;
    const verts = [];
    const uvs = [];
    const indices = [];
    const segmentsX = this.segWidth - 1;
    const segmentsY = this.segHeight - 1;
    const sizeX = this.width / segmentsX;
    const sizeY = this.height / segmentsY;
    for (let i = 0; i < total; i++) {
      const x = i % this.segWidth;
      const y = i / this.segWidth | 0;
      verts.push(x * sizeX, y * sizeY);
      uvs.push(x / segmentsX, y / segmentsY);
    }
    const totalSub = segmentsX * segmentsY;
    for (let i = 0; i < totalSub; i++) {
      const xpos = i % segmentsX;
      const ypos = i / segmentsX | 0;
      const value = ypos * this.segWidth + xpos;
      const value2 = ypos * this.segWidth + xpos + 1;
      const value3 = (ypos + 1) * this.segWidth + xpos;
      const value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  }
}


//# sourceMappingURL=PlaneGeometry.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RopeGeometry": function() { return /* binding */ RopeGeometry; }
/* harmony export */ });
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.mjs");


class RopeGeometry extends _pixi_mesh__WEBPACK_IMPORTED_MODULE_0__.MeshGeometry {
  constructor(width = 200, points, textureScale = 0) {
    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
    this.points = points;
    this._width = width;
    this.textureScale = textureScale;
    this.build();
  }
  get width() {
    return this._width;
  }
  build() {
    const points = this.points;
    if (!points)
      return;
    const vertexBuffer = this.getBuffer("aVertexPosition");
    const uvBuffer = this.getBuffer("aTextureCoord");
    const indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    const uvs = uvBuffer.data;
    const indices = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    let amount = 0;
    let prev = points[0];
    const textureWidth = this._width * this.textureScale;
    const total = points.length;
    for (let i = 0; i < total; i++) {
      const index = i * 4;
      if (this.textureScale > 0) {
        const dx = prev.x - points[i].x;
        const dy = prev.y - points[i].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        prev = points[i];
        amount += distance / textureWidth;
      } else {
        amount = i / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    let indexCount = 0;
    for (let i = 0; i < total - 1; i++) {
      const index = i * 2;
      indices[indexCount++] = index;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 2;
      indices[indexCount++] = index + 1;
      indices[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  }
  updateVertices() {
    const points = this.points;
    if (points.length < 1) {
      return;
    }
    let lastPoint = points[0];
    let nextPoint;
    let perpX = 0;
    let perpY = 0;
    const vertices = this.buffers[0].data;
    const total = points.length;
    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
    for (let i = 0; i < total; i++) {
      const point = points[i];
      const index = i * 4;
      if (i < points.length - 1) {
        nextPoint = points[i + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      let ratio = (1 - i / (total - 1)) * 10;
      if (ratio > 1) {
        ratio = 1;
      }
      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      if (perpLength < 1e-6) {
        perpX = 0;
        perpY = 0;
      } else {
        perpX /= perpLength;
        perpY /= perpLength;
        perpX *= halfWidth;
        perpY *= halfWidth;
      }
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  }
  update() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  }
}


//# sourceMappingURL=RopeGeometry.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh-extras/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/mesh-extras/lib/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NineSlicePlane": function() { return /* reexport safe */ _NineSlicePlane_mjs__WEBPACK_IMPORTED_MODULE_2__.NineSlicePlane; },
/* harmony export */   "PlaneGeometry": function() { return /* reexport safe */ _geometry_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry; },
/* harmony export */   "RopeGeometry": function() { return /* reexport safe */ _geometry_RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__.RopeGeometry; },
/* harmony export */   "SimpleMesh": function() { return /* reexport safe */ _SimpleMesh_mjs__WEBPACK_IMPORTED_MODULE_3__.SimpleMesh; },
/* harmony export */   "SimplePlane": function() { return /* reexport safe */ _SimplePlane_mjs__WEBPACK_IMPORTED_MODULE_4__.SimplePlane; },
/* harmony export */   "SimpleRope": function() { return /* reexport safe */ _SimpleRope_mjs__WEBPACK_IMPORTED_MODULE_5__.SimpleRope; }
/* harmony export */ });
/* harmony import */ var _geometry_PlaneGeometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry/PlaneGeometry.mjs */ "./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs");
/* harmony import */ var _geometry_RopeGeometry_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry/RopeGeometry.mjs */ "./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs");
/* harmony import */ var _NineSlicePlane_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NineSlicePlane.mjs */ "./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs");
/* harmony import */ var _SimpleMesh_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SimpleMesh.mjs */ "./node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs");
/* harmony import */ var _SimplePlane_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimplePlane.mjs */ "./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs");
/* harmony import */ var _SimpleRope_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SimpleRope.mjs */ "./node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs");






//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/Mesh.mjs":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/Mesh.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mesh": function() { return /* binding */ Mesh; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _MeshBatchUvs_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MeshBatchUvs.mjs */ "./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs");




const tempPoint = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
const tempPolygon = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Polygon();
const _Mesh = class extends _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container {
  constructor(geometry, shader, state, drawMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLES) {
    super();
    this.geometry = geometry;
    this.shader = shader;
    this.state = state || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
    this.drawMode = drawMode;
    this.start = 0;
    this.size = 0;
    this.uvs = null;
    this.indices = null;
    this.vertexData = new Float32Array(1);
    this.vertexDirty = -1;
    this._transformID = -1;
    this._roundPixels = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ROUND_PIXELS;
    this.batchUvs = null;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    if (this._geometry === value) {
      return;
    }
    if (this._geometry) {
      this._geometry.refCount--;
      if (this._geometry.refCount === 0) {
        this._geometry.dispose();
      }
    }
    this._geometry = value;
    if (this._geometry) {
      this._geometry.refCount++;
    }
    this.vertexDirty = -1;
  }
  get uvBuffer() {
    return this.geometry.buffers[1];
  }
  get verticesBuffer() {
    return this.geometry.buffers[0];
  }
  set material(value) {
    this.shader = value;
  }
  get material() {
    return this.shader;
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get tint() {
    return "tint" in this.shader ? this.shader.tint : null;
  }
  set tint(value) {
    this.shader.tint = value;
  }
  get tintValue() {
    return this.shader.tintValue;
  }
  get texture() {
    return "texture" in this.shader ? this.shader.texture : null;
  }
  set texture(value) {
    this.shader.texture = value;
  }
  _render(renderer) {
    const vertices = this.geometry.buffers[0].data;
    const shader = this.shader;
    if (shader.batchable && this.drawMode === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  }
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  _renderToBatch(renderer) {
    const geometry = this.geometry;
    const shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    const pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  }
  calculateVertices() {
    const geometry = this.geometry;
    const verticesBuffer = geometry.buffers[0];
    const vertices = verticesBuffer.data;
    const vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    for (let i = 0; i < vertexData.length / 2; i++) {
      const x = vertices[i * 2];
      const y = vertices[i * 2 + 1];
      vertexData[i * 2] = a * x + c * y + tx;
      vertexData[i * 2 + 1] = b * x + d * y + ty;
    }
    if (this._roundPixels) {
      const resolution = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
    this.vertexDirty = vertexDirtyId;
  }
  calculateUvs() {
    const geomUvs = this.geometry.buffers[1];
    const shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new _MeshBatchUvs_mjs__WEBPACK_IMPORTED_MODULE_2__.MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }
  containsPoint(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    const vertices = this.geometry.getBuffer("aVertexPosition").data;
    const points = tempPolygon.points;
    const indices = this.geometry.getIndex().data;
    const len = indices.length;
    const step = this.drawMode === 4 ? 3 : 1;
    for (let i = 0; i + 2 < len; i += step) {
      const ind0 = indices[i] * 2;
      const ind1 = indices[i + 1] * 2;
      const ind2 = indices[i + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  }
};
let Mesh = _Mesh;
Mesh.BATCHABLE_SIZE = 100;


//# sourceMappingURL=Mesh.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshBatchUvs": function() { return /* binding */ MeshBatchUvs; }
/* harmony export */ });
class MeshBatchUvs {
  constructor(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  update(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    const data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  }
}


//# sourceMappingURL=MeshBatchUvs.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/MeshGeometry.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/MeshGeometry.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshGeometry": function() { return /* binding */ MeshGeometry; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class MeshGeometry extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Geometry {
  constructor(vertices, uvs, index) {
    super();
    const verticesBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(vertices);
    const uvsBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(uvs, true);
    const indexBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(index, true, true);
    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT).addIndex(indexBuffer);
    this._updateId = -1;
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}


//# sourceMappingURL=MeshGeometry.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/MeshMaterial.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/MeshMaterial.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshMaterial": function() { return /* binding */ MeshMaterial; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _shader_mesh_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shader/mesh.mjs */ "./node_modules/@pixi/mesh/lib/shader/mesh.mjs");
/* harmony import */ var _shader_mesh2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shader/mesh2.mjs */ "./node_modules/@pixi/mesh/lib/shader/mesh2.mjs");




class MeshMaterial extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader {
  constructor(uSampler, options) {
    const uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    super(options.program || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Program.from(_shader_mesh2_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _shader_mesh_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]), uniforms);
    this._colorDirty = false;
    this.uvMatrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TextureMatrix(uSampler);
    this.batchable = options.program === void 0;
    this.pluginName = options.pluginName;
    this._tintColor = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color(options.tint);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
    this.alpha = options.alpha;
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(value) {
    if (this.uniforms.uSampler !== value) {
      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {
        this._colorDirty = true;
      }
      this.uniforms.uSampler = value;
      this.uvMatrix.texture = value;
    }
  }
  set alpha(value) {
    if (value === this._alpha)
      return;
    this._alpha = value;
    this._colorDirty = true;
  }
  get alpha() {
    return this._alpha;
  }
  set tint(value) {
    if (value === this.tint)
      return;
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
    this._colorDirty = true;
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = false;
      const baseTexture = this.texture.baseTexture;
      const applyToChannels = baseTexture.alphaMode;
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  }
}


//# sourceMappingURL=MeshMaterial.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/index.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mesh": function() { return /* reexport safe */ _Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__.Mesh; },
/* harmony export */   "MeshBatchUvs": function() { return /* reexport safe */ _MeshBatchUvs_mjs__WEBPACK_IMPORTED_MODULE_1__.MeshBatchUvs; },
/* harmony export */   "MeshGeometry": function() { return /* reexport safe */ _MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__.MeshGeometry; },
/* harmony export */   "MeshMaterial": function() { return /* reexport safe */ _MeshMaterial_mjs__WEBPACK_IMPORTED_MODULE_3__.MeshMaterial; }
/* harmony export */ });
/* harmony import */ var _Mesh_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mesh.mjs */ "./node_modules/@pixi/mesh/lib/Mesh.mjs");
/* harmony import */ var _MeshBatchUvs_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MeshBatchUvs.mjs */ "./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs");
/* harmony import */ var _MeshGeometry_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MeshGeometry.mjs */ "./node_modules/@pixi/mesh/lib/MeshGeometry.mjs");
/* harmony import */ var _MeshMaterial_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MeshMaterial.mjs */ "./node_modules/@pixi/mesh/lib/MeshMaterial.mjs");




//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/shader/mesh.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/shader/mesh.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";


//# sourceMappingURL=mesh.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mesh/lib/shader/mesh2.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/mesh/lib/shader/mesh2.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ vertex; }
/* harmony export */ });
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";


//# sourceMappingURL=mesh2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CacheData": function() { return /* binding */ CacheData; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.mjs");




const _tempMatrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._cacheAsBitmap = false;
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._cacheData = null;
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._cacheAsBitmapResolution = null;
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._cacheAsBitmapMultisample = null;
class CacheData {
  constructor() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
}
Object.defineProperties(_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      let data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  const bounds = this.getLocalBounds(null, true).clone();
  if (this.filters?.length) {
    const padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION);
  const cachedRenderTexture = renderer.renderTexture.current;
  const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  const cachedProjectionTransform = renderer.projection.transform;
  const renderTexture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample
  });
  const textureCacheId = `cacheAsBitmap_${_pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.addToCache(renderTexture, textureCacheId);
  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new _pixi_sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData?.sprite) {
    return;
  }
  const bounds = this.getLocalBounds(null, true);
  const cacheAlpha = this.alpha;
  this.alpha = 1;
  const cachedRenderTarget = renderer.canvasContext.activeContext;
  const cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION);
  const renderTexture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.RenderTexture.create({ width: bounds.width, height: bounds.height });
  const textureCacheId = `cacheAsBitmap_${_pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.uid()}`;
  this._cacheData.textureCacheId = textureCacheId;
  _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.addToCache(renderTexture, textureCacheId);
  const m = _tempMatrix;
  this.transform.localTransform.copyTo(m);
  m.invert();
  m.tx -= bounds.x;
  m.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });
  renderer.canvasContext.activeContext = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  const cachedSprite = new _pixi_sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");


_pixi_display__WEBPACK_IMPORTED_MODULE_0__.DisplayObject.prototype.name = null;
_pixi_display__WEBPACK_IMPORTED_MODULE_0__.Container.prototype.getChildByName = function getChildByName(name, deep) {
  for (let i = 0, j = this.children.length; i < j; i++) {
    if (this.children[i].name === name) {
      return this.children[i];
    }
  }
  if (deep) {
    for (let i = 0, j = this.children.length; i < j; i++) {
      const child = this.children[i];
      if (!child.getChildByName) {
        continue;
      }
      const target = child.getChildByName(name, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/mixin-get-global-position/lib/index.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@pixi/mixin-get-global-position/lib/index.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");



_pixi_display__WEBPACK_IMPORTED_MODULE_1__.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point(), skipUpdate = false) {
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParticleBuffer": function() { return /* binding */ ParticleBuffer; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


class ParticleBuffer {
  constructor(properties, dynamicPropertyFlags, size) {
    this.geometry = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (let i = 0; i < properties.length; ++i) {
      let property = properties[i];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  initBuffers() {
    const geometry = this.geometry;
    let dynamicOffset = 0;
    this.indexBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(this.dynamicData, false, false);
    let staticOffset = 0;
    this.staticStride = 0;
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Buffer(this.staticData, true, false);
    for (let i = 0; i < this.dynamicProperties.length; ++i) {
      const property = this.dynamicProperties[i];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (let i = 0; i < this.staticProperties.length; ++i) {
      const property = this.staticProperties[i];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  }
  uploadDynamic(children, startIndex, amount) {
    for (let i = 0; i < this.dynamicProperties.length; i++) {
      const property = this.dynamicProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(children, startIndex, amount) {
    for (let i = 0; i < this.staticProperties.length; i++) {
      const property = this.staticProperties[i];
      property.uploadFunction(children, startIndex, amount, property.type === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  }
}


//# sourceMappingURL=ParticleBuffer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/ParticleContainer.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/ParticleContainer.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParticleContainer": function() { return /* binding */ ParticleContainer; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");



class ParticleContainer extends _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container {
  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {
    super();
    const maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    this._properties = [false, true, false, false, false];
    this._maxSize = maxSize;
    this._batchSize = batchSize;
    this._buffers = null;
    this._bufferUpdateIDs = [];
    this._updateID = 0;
    this.interactiveChildren = false;
    this.blendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL;
    this.autoResize = autoResize;
    this.roundPixels = true;
    this.baseTexture = null;
    this.setProperties(properties);
    this._tintColor = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color(0);
    this.tintRgb = new Float32Array(3);
    this.tint = 16777215;
  }
  setProperties(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  }
  updateTransform() {
    this.displayObjectUpdateTransform();
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintColor.toRgbArray(this.tintRgb);
  }
  render(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", () => this.onChildrenChange(0));
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  }
  onChildrenChange(smallestChildIndex) {
    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  }
  dispose() {
    if (this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
    }
  }
  destroy(options) {
    super.destroy(options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  }
}


//# sourceMappingURL=ParticleContainer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParticleRenderer": function() { return /* binding */ ParticleRenderer; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _ParticleBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ParticleBuffer.mjs */ "./node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs");
/* harmony import */ var _particles_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./particles.mjs */ "./node_modules/@pixi/particle-container/lib/particles.mjs");
/* harmony import */ var _particles2_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./particles2.mjs */ "./node_modules/@pixi/particle-container/lib/particles2.mjs");





class ParticleRenderer extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    this.shader = null;
    this.properties = null;
    this.tempMatrix = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
    this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TYPES.UNSIGNED_BYTE,
        uploadFunction: this.uploadTint,
        offset: 0
      }
    ];
    this.shader = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader.from(_particles2_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], _particles_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], {});
    this.state = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
  }
  render(container) {
    const children = container.children;
    const maxSize = container._maxSize;
    const batchSize = container._batchSize;
    const renderer = this.renderer;
    let totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    let buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    const baseTexture = children[0]._texture.baseTexture;
    const premultiplied = baseTexture.alphaMode > 0;
    this.state.blendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.correctBlendMode(container.blendMode, premultiplied);
    renderer.state.set(this.state);
    const gl = renderer.gl;
    const m = container.worldTransform.copyTo(this.tempMatrix);
    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m.toArray(true);
    this.shader.uniforms.uColor = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    let updateStatic = false;
    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
      let amount = totalChildren - i;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      const buffer = buffers[j];
      buffer.uploadDynamic(children, i, amount);
      const bid = container._bufferUpdateIDs[j] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i, amount);
      }
      renderer.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  }
  generateBuffers(container) {
    const buffers = [];
    const size = container._maxSize;
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    for (let i = 0; i < size; i += batchSize) {
      buffers.push(new _ParticleBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  }
  _generateOneMoreBuffer(container) {
    const batchSize = container._batchSize;
    const dynamicPropertyFlags = container._properties;
    return new _ParticleBuffer_mjs__WEBPACK_IMPORTED_MODULE_1__.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  }
  uploadVertices(children, startIndex, amount, array, stride, offset) {
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const texture = sprite._texture;
      const sx = sprite.scale.x;
      const sy = sprite.scale.y;
      const trim = texture.trim;
      const orig = texture.orig;
      if (trim) {
        w1 = trim.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim.width;
        h1 = trim.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  }
  uploadPosition(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spritePosition = children[startIndex + i].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  }
  uploadRotation(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; i++) {
      const spriteRotation = children[startIndex + i].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  }
  uploadUvs(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const textureUvs = children[startIndex + i]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  }
  uploadTint(children, startIndex, amount, array, stride, offset) {
    for (let i = 0; i < amount; ++i) {
      const sprite = children[startIndex + i];
      const result = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);
      array[offset] = result;
      array[offset + stride] = result;
      array[offset + stride * 2] = result;
      array[offset + stride * 3] = result;
      offset += stride * 4;
    }
  }
  destroy() {
    super.destroy();
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  }
}
ParticleRenderer.extension = {
  name: "particle",
  type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererPlugin
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(ParticleRenderer);


//# sourceMappingURL=ParticleRenderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/index.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParticleContainer": function() { return /* reexport safe */ _ParticleContainer_mjs__WEBPACK_IMPORTED_MODULE_0__.ParticleContainer; },
/* harmony export */   "ParticleRenderer": function() { return /* reexport safe */ _ParticleRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__.ParticleRenderer; }
/* harmony export */ });
/* harmony import */ var _ParticleContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParticleContainer.mjs */ "./node_modules/@pixi/particle-container/lib/ParticleContainer.mjs");
/* harmony import */ var _ParticleRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ParticleRenderer.mjs */ "./node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/particles.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/particles.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragment; }
/* harmony export */ });
var fragment = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";


//# sourceMappingURL=particles.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/particle-container/lib/particles2.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/particle-container/lib/particles2.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ vertex; }
/* harmony export */ });
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";


//# sourceMappingURL=particles2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/BasePrepare.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/BasePrepare.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasePrepare": function() { return /* binding */ BasePrepare; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.mjs");
/* harmony import */ var _CountLimiter_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CountLimiter.mjs */ "./node_modules/@pixi/prepare/lib/CountLimiter.mjs");





function findMultipleBaseTextures(item, queue) {
  let result = false;
  if (item?._textures?.length) {
    for (let i = 0; i < item._textures.length; i++) {
      if (item._textures[i] instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture) {
        const baseTexture = item._textures[i].baseTexture;
        if (!queue.includes(baseTexture)) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture) {
    const texture = item.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture) {
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_2__.Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_2__.TextStyle) {
    const font = item.toFontString();
    _pixi_text__WEBPACK_IMPORTED_MODULE_2__.TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_2__.Text) {
    if (!queue.includes(item.style)) {
      queue.push(item.style);
    }
    if (!queue.includes(item)) {
      queue.push(item);
    }
    const texture = item._texture.baseTexture;
    if (!queue.includes(texture)) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_2__.TextStyle) {
    if (!queue.includes(item)) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
const _BasePrepare = class {
  constructor(renderer) {
    this.limiter = new _CountLimiter_mjs__WEBPACK_IMPORTED_MODULE_3__.CountLimiter(_BasePrepare.uploadsPerFrame);
    this.renderer = renderer;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = () => {
      if (!this.queue) {
        return;
      }
      this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  upload(item) {
    return new Promise((resolve) => {
      if (item) {
        this.add(item);
      }
      if (this.queue.length) {
        this.completes.push(resolve);
        if (!this.ticking) {
          this.ticking = true;
          _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.addOnce(this.tick, this, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.UPDATE_PRIORITY.UTILITY);
        }
      } else {
        resolve();
      }
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      const item = this.queue[0];
      let uploaded = false;
      if (item && !item._destroyed) {
        for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
          if (this.uploadHooks[i](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      const completes = this.completes.slice(0);
      this.completes.length = 0;
      for (let i = 0, len = completes.length; i < len; i++) {
        completes[i]();
      }
    } else {
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.addOnce(this.tick, this, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.UPDATE_PRIORITY.UTILITY);
    }
  }
  registerFindHook(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  }
  registerUploadHook(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  }
  add(item) {
    for (let i = 0, len = this.addHooks.length; i < len; i++) {
      if (this.addHooks[i](item, this.queue)) {
        break;
      }
    }
    if (item instanceof _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container) {
      for (let i = item.children.length - 1; i >= 0; i--) {
        this.add(item.children[i]);
      }
    }
    return this;
  }
  destroy() {
    if (this.ticking) {
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  }
};
let BasePrepare = _BasePrepare;
BasePrepare.uploadsPerFrame = 4;


//# sourceMappingURL=BasePrepare.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/CountLimiter.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/CountLimiter.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CountLimiter": function() { return /* binding */ CountLimiter; }
/* harmony export */ });
class CountLimiter {
  constructor(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}


//# sourceMappingURL=CountLimiter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/Prepare.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/Prepare.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Prepare": function() { return /* binding */ Prepare; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/index.mjs");
/* harmony import */ var _BasePrepare_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BasePrepare.mjs */ "./node_modules/@pixi/prepare/lib/BasePrepare.mjs");




function uploadBaseTextures(renderer, item) {
  if (item instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics)) {
    return false;
  }
  const { geometry } = item;
  item.finishPoly();
  geometry.updateBatches();
  const { batches } = geometry;
  for (let i = 0; i < batches.length; i++) {
    const { texture } = batches[i].style;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof _pixi_graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
class Prepare extends _BasePrepare_mjs__WEBPACK_IMPORTED_MODULE_2__.BasePrepare {
  constructor(renderer) {
    super(renderer);
    this.uploadHookHelper = this.renderer;
    this.registerFindHook(findGraphics);
    this.registerUploadHook(uploadBaseTextures);
    this.registerUploadHook(uploadGraphics);
  }
}
Prepare.extension = {
  name: "prepare",
  type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererSystem
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(Prepare);


//# sourceMappingURL=Prepare.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/TimeLimiter.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/TimeLimiter.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeLimiter": function() { return /* binding */ TimeLimiter; }
/* harmony export */ });
class TimeLimiter {
  constructor(maxMilliseconds) {
    this.maxMilliseconds = maxMilliseconds;
    this.frameStart = 0;
  }
  beginFrame() {
    this.frameStart = Date.now();
  }
  allowedToUpload() {
    return Date.now() - this.frameStart < this.maxMilliseconds;
  }
}


//# sourceMappingURL=TimeLimiter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasePrepare": function() { return /* reexport safe */ _BasePrepare_mjs__WEBPACK_IMPORTED_MODULE_1__.BasePrepare; },
/* harmony export */   "CountLimiter": function() { return /* reexport safe */ _CountLimiter_mjs__WEBPACK_IMPORTED_MODULE_2__.CountLimiter; },
/* harmony export */   "Prepare": function() { return /* reexport safe */ _Prepare_mjs__WEBPACK_IMPORTED_MODULE_3__.Prepare; },
/* harmony export */   "TimeLimiter": function() { return /* reexport safe */ _TimeLimiter_mjs__WEBPACK_IMPORTED_MODULE_4__.TimeLimiter; }
/* harmony export */ });
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi/prepare/lib/settings.mjs");
/* harmony import */ var _BasePrepare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BasePrepare.mjs */ "./node_modules/@pixi/prepare/lib/BasePrepare.mjs");
/* harmony import */ var _CountLimiter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CountLimiter.mjs */ "./node_modules/@pixi/prepare/lib/CountLimiter.mjs");
/* harmony import */ var _Prepare_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Prepare.mjs */ "./node_modules/@pixi/prepare/lib/Prepare.mjs");
/* harmony import */ var _TimeLimiter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TimeLimiter.mjs */ "./node_modules/@pixi/prepare/lib/TimeLimiter.mjs");





//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/prepare/lib/settings.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/prepare/lib/settings.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "settings": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _BasePrepare_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BasePrepare.mjs */ "./node_modules/@pixi/prepare/lib/BasePrepare.mjs");




Object.defineProperties(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings, {
  UPLOADS_PER_FRAME: {
    get() {
      return _BasePrepare_mjs__WEBPACK_IMPORTED_MODULE_1__.BasePrepare.uploadsPerFrame;
    },
    set(value) {
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");
      _BasePrepare_mjs__WEBPACK_IMPORTED_MODULE_1__.BasePrepare.uploadsPerFrame = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/runner/lib/Runner.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/runner/lib/Runner.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Runner": function() { return /* binding */ Runner; }
/* harmony export */ });
class Runner {
  constructor(name) {
    this.items = [];
    this._name = name;
    this._aliasCount = 0;
  }
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    const { name, items } = this;
    this._aliasCount++;
    for (let i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  }
  ensureNonAliasedItems() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  }
  add(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index, 1);
    }
    return this;
  }
  contains(item) {
    return this.items.includes(item);
  }
  removeAll() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  }
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});


//# sourceMappingURL=Runner.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/runner/lib/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/runner/lib/index.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Runner": function() { return /* reexport safe */ _Runner_mjs__WEBPACK_IMPORTED_MODULE_0__.Runner; }
/* harmony export */ });
/* harmony import */ var _Runner_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Runner.mjs */ "./node_modules/@pixi/runner/lib/Runner.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/ICanvas.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/ICanvas.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=ICanvas.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=ICanvasRenderingContext2D.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/adapter.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/adapter.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserAdapter": function() { return /* binding */ BrowserAdapter; }
/* harmony export */ });
const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};


//# sourceMappingURL=adapter.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserAdapter": function() { return /* reexport safe */ _adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.BrowserAdapter; },
/* harmony export */   "isMobile": function() { return /* reexport safe */ _utils_isMobile_mjs__WEBPACK_IMPORTED_MODULE_4__.isMobile; },
/* harmony export */   "settings": function() { return /* reexport safe */ _settings_mjs__WEBPACK_IMPORTED_MODULE_3__.settings; }
/* harmony export */ });
/* harmony import */ var _adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.mjs */ "./node_modules/@pixi/settings/lib/adapter.mjs");
/* harmony import */ var _ICanvas_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ICanvas.mjs */ "./node_modules/@pixi/settings/lib/ICanvas.mjs");
/* harmony import */ var _ICanvasRenderingContext2D_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ICanvasRenderingContext2D.mjs */ "./node_modules/@pixi/settings/lib/ICanvasRenderingContext2D.mjs");
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi/settings/lib/settings.mjs");
/* harmony import */ var _utils_isMobile_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/isMobile.mjs */ "./node_modules/@pixi/settings/lib/utils/isMobile.mjs");





//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/settings.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/settings.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "settings": function() { return /* binding */ settings; }
/* harmony export */ });
/* harmony import */ var _adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.mjs */ "./node_modules/@pixi/settings/lib/adapter.mjs");


const settings = {
  ADAPTER: _adapter_mjs__WEBPACK_IMPORTED_MODULE_0__.BrowserAdapter,
  RESOLUTION: 1,
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};


//# sourceMappingURL=settings.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/settings/lib/utils/isMobile.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/settings/lib/utils/isMobile.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isMobile": function() { return /* binding */ isMobile; }
/* harmony export */ });
/* harmony import */ var ismobilejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ismobilejs */ "./node_modules/ismobilejs/esm/index.js");


const isMobileCall = ismobilejs__WEBPACK_IMPORTED_MODULE_0__["default"]["default"] ?? ismobilejs__WEBPACK_IMPORTED_MODULE_0__["default"];
const isMobile = isMobileCall(globalThis.navigator);


//# sourceMappingURL=isMobile.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimatedSprite": function() { return /* binding */ AnimatedSprite; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.mjs");



class AnimatedSprite extends _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite {
  constructor(textures, autoUpdate = true) {
    super(textures[0] instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture ? textures[0] : textures[0].texture);
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = 1;
    this.loop = true;
    this.updateAnchor = false;
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
  }
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.add(this.update, this, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  update(deltaTime) {
    if (!this._playing) {
      return;
    }
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign;
        this._currentTime += sign;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  }
  updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  destroy(options) {
    this.stop();
    super.destroy(options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  static fromFrames(frames) {
    const textures = [];
    for (let i = 0; i < frames.length; ++i) {
      textures.push(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.from(frames[i]));
    }
    return new AnimatedSprite(textures);
  }
  static fromImages(images) {
    const textures = [];
    for (let i = 0; i < images.length; ++i) {
      textures.push(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.from(images[i]));
    }
    return new AnimatedSprite(textures);
  }
  get totalFrames() {
    return this._textures.length;
  }
  get textures() {
    return this._textures;
  }
  set textures(value) {
    if (value[0] instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture) {
      this._textures = value;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i = 0; i < value.length; i++) {
        this._textures.push(value[i].texture);
        this._durations.push(value[i].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this.updateTexture();
  }
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value) {
    if (value < 0 || value > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  }
  get playing() {
    return this._playing;
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}


//# sourceMappingURL=AnimatedSprite.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-animated/lib/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/sprite-animated/lib/index.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimatedSprite": function() { return /* reexport safe */ _AnimatedSprite_mjs__WEBPACK_IMPORTED_MODULE_0__.AnimatedSprite; }
/* harmony export */ });
/* harmony import */ var _AnimatedSprite_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedSprite.mjs */ "./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TilingSprite": function() { return /* binding */ TilingSprite; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.mjs");



const tempPoint = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
class TilingSprite extends _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite {
  constructor(texture, width = 100, height = 100) {
    super(texture);
    this.tileTransform = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Transform();
    this._width = width;
    this._height = height;
    this.uvMatrix = this.texture.uvMatrix || new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.TextureMatrix(texture);
    this.pluginName = "tilingSprite";
    this.uvRespectAnchor = false;
  }
  get clampMargin() {
    return this.uvMatrix.clampMargin;
  }
  set clampMargin(value) {
    this.uvMatrix.clampMargin = value;
    this.uvMatrix.update(true);
  }
  get tileScale() {
    return this.tileTransform.scale;
  }
  set tileScale(value) {
    this.tileTransform.scale.copyFrom(value);
  }
  get tilePosition() {
    return this.tileTransform.position;
  }
  set tilePosition(value) {
    this.tileTransform.position.copyFrom(value);
  }
  _onTextureUpdate() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  }
  _render(renderer) {
    const texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const minX = this._width * -this._anchor._x;
    const minY = this._height * -this._anchor._y;
    const maxX = this._width * (1 - this._anchor._x);
    const maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._width;
    const height = this._height;
    const x1 = -width * this.anchor._x;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      const y1 = -height * this.anchor._y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this.tileTransform = null;
    this.uvMatrix = null;
  }
  static from(source, options) {
    const texture = source instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture ? source : _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
  }
}


//# sourceMappingURL=TilingSprite.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TilingSpriteRenderer": function() { return /* binding */ TilingSpriteRenderer; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _sprite_tiling_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprite-tiling.mjs */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs");
/* harmony import */ var _sprite_tiling2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sprite-tiling2.mjs */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs");
/* harmony import */ var _sprite_tiling_fallback_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sprite-tiling-fallback.mjs */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs");
/* harmony import */ var _sprite_tiling_fallback2_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sprite-tiling-fallback2.mjs */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs");
/* harmony import */ var _sprite_tiling_simple_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sprite-tiling-simple.mjs */ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs");







const tempMat = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Matrix();
class TilingSpriteRenderer extends _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ObjectRenderer {
  constructor(renderer) {
    super(renderer);
    renderer.runners.contextChange.add(this);
    this.quad = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.QuadUv();
    this.state = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.State.for2d();
  }
  contextChange() {
    const renderer = this.renderer;
    const uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader.from(_sprite_tiling_fallback2_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _sprite_tiling_simple_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], uniforms);
    this.shader = renderer.context.webGLVersion > 1 ? _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader.from(_sprite_tiling2_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], _sprite_tiling_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], uniforms) : _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Shader.from(_sprite_tiling_fallback2_mjs__WEBPACK_IMPORTED_MODULE_4__["default"], _sprite_tiling_fallback_mjs__WEBPACK_IMPORTED_MODULE_3__["default"], uniforms);
  }
  render(ts) {
    const renderer = this.renderer;
    const quad = this.quad;
    let vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    const tex = ts._texture;
    const baseTex = tex.baseTexture;
    const premultiplied = baseTex.alphaMode > 0;
    const lt = ts.tileTransform.localTransform;
    const uv = ts.uvMatrix;
    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
        if (baseTex.wrapMode === _pixi_core__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.CLAMP) {
          baseTex.wrapMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== _pixi_core__WEBPACK_IMPORTED_MODULE_0__.WRAP_MODES.CLAMP;
      }
    }
    const shader = isSimple ? this.simpleShader : this.shader;
    const w = tex.width;
    const h = tex.height;
    const W = ts._width;
    const H = ts._height;
    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer.shader.bind(shader);
    renderer.geometry.bind(quad);
    this.state.blendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.correctBlendMode(ts.blendMode, premultiplied);
    renderer.state.set(this.state);
    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }
}
TilingSpriteRenderer.extension = {
  name: "tilingSprite",
  type: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.RendererPlugin
};
_pixi_core__WEBPACK_IMPORTED_MODULE_0__.extensions.add(TilingSpriteRenderer);


//# sourceMappingURL=TilingSpriteRenderer.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TilingSprite": function() { return /* reexport safe */ _TilingSprite_mjs__WEBPACK_IMPORTED_MODULE_0__.TilingSprite; },
/* harmony export */   "TilingSpriteRenderer": function() { return /* reexport safe */ _TilingSpriteRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__.TilingSpriteRenderer; }
/* harmony export */ });
/* harmony import */ var _TilingSprite_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TilingSprite.mjs */ "./node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs");
/* harmony import */ var _TilingSpriteRenderer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TilingSpriteRenderer.mjs */ "./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ gl1FragmentSrc; }
/* harmony export */ });
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";


//# sourceMappingURL=sprite-tiling-fallback.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ gl1VertexSrc; }
/* harmony export */ });
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";


//# sourceMappingURL=sprite-tiling-fallback2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ fragmentSimpleSrc; }
/* harmony export */ });
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";


//# sourceMappingURL=sprite-tiling-simple.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ gl2FragmentSrc; }
/* harmony export */ });
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";


//# sourceMappingURL=sprite-tiling.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ gl2VertexSrc; }
/* harmony export */ });
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";


//# sourceMappingURL=sprite-tiling2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite/lib/Sprite.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/sprite/lib/Sprite.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sprite": function() { return /* binding */ Sprite; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");



const tempPoint = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
class Sprite extends _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container {
  constructor(texture) {
    super();
    this._anchor = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    this._texture = null;
    this._width = 0;
    this._height = 0;
    this._tintColor = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);
    this._tintRGB = null;
    this.tint = 16777215;
    this.blendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL;
    this._cachedTint = 16777215;
    this.uvs = null;
    this.texture = texture || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY;
    this.vertexData = new Float32Array(8);
    this.vertexTrimmedData = null;
    this._transformID = -1;
    this._textureID = -1;
    this._transformTrimmedID = -1;
    this._textureTrimmedID = -1;
    this.indices = indices;
    this.pluginName = "batch";
    this.isSprite = true;
    this._roundPixels = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ROUND_PIXELS;
  }
  _onTextureUpdate() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  }
  _onAnchorUpdate() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  }
  calculateVertices() {
    const texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const vertexData = this.vertexData;
    const trim = texture.trim;
    const orig = texture.orig;
    const anchor = this._anchor;
    let w0 = 0;
    let w1 = 0;
    let h0 = 0;
    let h1 = 0;
    if (trim) {
      w1 = trim.x - anchor._x * orig.width;
      w0 = w1 + trim.width;
      h1 = trim.y - anchor._y * orig.height;
      h0 = h1 + trim.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
    if (this._roundPixels) {
      const resolution = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION;
      for (let i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;
      }
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    const texture = this._texture;
    const vertexData = this.vertexTrimmedData;
    const orig = texture.orig;
    const anchor = this._anchor;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const w1 = -anchor._x * orig.width;
    const w0 = w1 + orig.width;
    const h1 = -anchor._y * orig.height;
    const h0 = h1 + orig.height;
    vertexData[0] = a * w1 + c * h1 + tx;
    vertexData[1] = d * h1 + b * w1 + ty;
    vertexData[2] = a * w0 + c * h1 + tx;
    vertexData[3] = d * h1 + b * w0 + ty;
    vertexData[4] = a * w0 + c * h0 + tx;
    vertexData[5] = d * h0 + b * w0 + ty;
    vertexData[6] = a * w1 + c * h0 + tx;
    vertexData[7] = d * h0 + b * w1 + ty;
  }
  _render(renderer) {
    this.calculateVertices();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  }
  _calculateBounds() {
    const trim = this._texture.trim;
    const orig = this._texture.orig;
    if (!trim || trim.width === orig.width && trim.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  }
  getLocalBounds(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return super.getLocalBounds.call(this, rect);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, tempPoint);
    const width = this._texture.orig.width;
    const height = this._texture.orig.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {
        return true;
      }
    }
    return false;
  }
  destroy(options) {
    super.destroy(options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  }
  static from(source, options) {
    const texture = source instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture ? source : _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.from(source, options);
    return new Sprite(texture);
  }
  set roundPixels(value) {
    if (this._roundPixels !== value) {
      this._transformID = -1;
    }
    this._roundPixels = value;
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    const s = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    const s = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor.copyFrom(value);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    this._tintColor.setValue(value);
    this._tintRGB = this._tintColor.toLittleEndianNumber();
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate, this);
    }
    this._texture = value || _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY;
    this._cachedTint = 16777215;
    this._textureID = -1;
    this._textureTrimmedID = -1;
    if (value) {
      if (value.baseTexture.valid) {
        this._onTextureUpdate();
      } else {
        value.once("update", this._onTextureUpdate, this);
      }
    }
  }
}


//# sourceMappingURL=Sprite.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/sprite/lib/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/sprite/lib/index.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sprite": function() { return /* reexport safe */ _Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__.Sprite; }
/* harmony export */ });
/* harmony import */ var _Sprite_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite.mjs */ "./node_modules/@pixi/sprite/lib/Sprite.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spritesheet": function() { return /* binding */ Spritesheet; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const _Spritesheet = class {
  constructor(texture, data, resolutionFilename = null) {
    this.linkedSheets = [];
    this._texture = texture instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture ? texture : null;
    this.baseTexture = texture instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  _updateResolution(resolutionFilename = null) {
    const { scale } = this.data.meta;
    let resolution = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = parseFloat(scale ?? "1");
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  }
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i = this._frameKeys[frameIndex];
      const data = this._frames[i];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i] = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);
        _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.addToCache(this.textures[i], i);
      }
      frameIndex++;
    }
  }
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i = 0; i < animations[animName].length; i++) {
        const frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  destroy(destroyBase = false) {
    for (const i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
    this.linkedSheets = [];
  }
};
let Spritesheet = _Spritesheet;
Spritesheet.BATCH_SIZE = 1e3;


//# sourceMappingURL=Spritesheet.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/spritesheet/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/spritesheet/lib/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Spritesheet": function() { return /* reexport safe */ _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_0__.Spritesheet; },
/* harmony export */   "spritesheetAsset": function() { return /* reexport safe */ _spritesheetAsset_mjs__WEBPACK_IMPORTED_MODULE_1__.spritesheetAsset; }
/* harmony export */ });
/* harmony import */ var _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Spritesheet.mjs */ "./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs");
/* harmony import */ var _spritesheetAsset_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./spritesheetAsset.mjs */ "./node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spritesheetAsset": function() { return /* binding */ spritesheetAsset; }
/* harmony export */ });
/* harmony import */ var _pixi_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Spritesheet.mjs */ "./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs");




const validImages = ["jpg", "png", "jpeg", "avif", "webp"];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = _pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.Asset,
  cache: {
    test: (asset) => asset instanceof _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_2__.Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  resolver: {
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(_pixi_core__WEBPACK_IMPORTED_MODULE_1__.settings.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  loader: {
    name: "spritesheetLoader",
    extension: {
      type: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.LoadParser,
      priority: _pixi_assets__WEBPACK_IMPORTED_MODULE_0__.LoaderParserPriority.Normal
    },
    async testParse(asset, options) {
      return _pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      let basePath = _pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let imagePath = basePath + asset.meta.image;
      imagePath = (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_0__.copySearchParams)(imagePath, options.src);
      const assets = await loader.load([imagePath]);
      const texture = assets[imagePath];
      const spritesheet = new _Spritesheet_mjs__WEBPACK_IMPORTED_MODULE_2__.Spritesheet(texture.baseTexture, asset, options.src);
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if (options.data?.ignoreMultiPack) {
            continue;
          }
          itemUrl = (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_0__.copySearchParams)(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    unload(spritesheet) {
      spritesheet.destroy(true);
    }
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_1__.extensions.add(spritesheetAsset);


//# sourceMappingURL=spritesheetAsset.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitmapFont": function() { return /* binding */ BitmapFont; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.mjs");
/* harmony import */ var _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BitmapFontData.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs");
/* harmony import */ var _formats_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formats/index.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/index.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/index.mjs");
/* harmony import */ var _utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/resolveCharacters.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs");
/* harmony import */ var _utils_drawGlyph_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/drawGlyph.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs");
/* harmony import */ var _utils_extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/extractCharCode.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs");









const _BitmapFont = class {
  constructor(data, textures, ownsTextures) {
    const [info] = data.info;
    const [common] = data.common;
    const [page] = data.page;
    const [distanceField] = data.distanceField;
    const res = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.getResolutionOfUrl(page.file);
    const pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (let i = 0; i < data.page.length; i++) {
      const { id, file } = data.page[i];
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
      if (distanceField?.fieldType && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;
        pageTextures[id].baseTexture.mipmap = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.MIPMAP_MODES.OFF;
      }
    }
    for (let i = 0; i < data.char.length; i++) {
      const { id, page: page2 } = data.char[i];
      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];
      x /= res;
      y /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      const rect = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture(pageTextures[page2].baseTexture, rect),
        page: page2
      };
    }
    for (let i = 0; i < data.kerning.length; i++) {
      let { first, second, amount } = data.kerning[i];
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField?.distanceRange;
    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
  }
  destroy() {
    for (const id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (const id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  }
  static install(data, textures, ownsTextures) {
    let fontData;
    if (data instanceof _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_2__.BitmapFontData) {
      fontData = data;
    } else {
      const format = (0,_formats_index_mjs__WEBPACK_IMPORTED_MODULE_3__.autoDetectFormat)(data);
      if (!format) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format.parse(data);
    }
    if (textures instanceof _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture) {
      textures = [textures];
    }
    const font = new _BitmapFont(fontData, textures, ownsTextures);
    _BitmapFont.available[font.font] = font;
    return font;
  }
  static uninstall(name) {
    const font = _BitmapFont.available[name];
    if (!font) {
      throw new Error(`No font found named '${name}'`);
    }
    font.destroy();
    delete _BitmapFont.available[name];
  }
  static from(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    const {
      chars,
      padding,
      resolution,
      textureWidth,
      textureHeight,
      ...baseOptions
    } = Object.assign({}, _BitmapFont.defaultOptions, options);
    const charsList = (0,_utils_resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_5__.resolveCharacters)(chars);
    const style = textStyle instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_1__.TextStyle ? textStyle : new _pixi_text__WEBPACK_IMPORTED_MODULE_1__.TextStyle(textStyle);
    const lineWidth = textureWidth;
    const fontData = new _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_2__.BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    let positionX = 0;
    let positionY = 0;
    let canvas;
    let context;
    let baseTexture;
    let maxCharHeight = 0;
    const baseTextures = [];
    const textures = [];
    for (let i = 0; i < charsList.length; i++) {
      if (!canvas) {
        canvas = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.createCanvas();
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context = canvas.getContext("2d");
        baseTexture = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BaseTexture(canvas, { resolution, ...baseOptions });
        baseTextures.push(baseTexture);
        textures.push(new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      const character = charsList[i];
      const metrics = _pixi_text__WEBPACK_IMPORTED_MODULE_1__.TextMetrics.measureText(character, style, false, canvas);
      const width = metrics.width;
      const height = Math.ceil(metrics.height);
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        canvas = null;
        context = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        if (positionX === 0) {
          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
        }
        --i;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      (0,_utils_drawGlyph_mjs__WEBPACK_IMPORTED_MODULE_6__.drawGlyph)(canvas, context, metrics, positionX, positionY, resolution, style);
      const id = (0,_utils_extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_7__.extractCharCode)(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (let i = 0, len = charsList.length; i < len; i++) {
      const first = charsList[i];
      for (let j = 0; j < len; j++) {
        const second = charsList[j];
        const c1 = context.measureText(first).width;
        const c2 = context.measureText(second).width;
        const total = context.measureText(first + second).width;
        const amount = total - (c1 + c2);
        if (amount) {
          fontData.kerning.push({
            first: (0,_utils_extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_7__.extractCharCode)(first),
            second: (0,_utils_extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_7__.extractCharCode)(second),
            amount
          });
        }
      }
    }
    const font = new _BitmapFont(fontData, textures, true);
    if (_BitmapFont.available[name] !== void 0) {
      _BitmapFont.uninstall(name);
    }
    _BitmapFont.available[name] = font;
    return font;
  }
};
let BitmapFont = _BitmapFont;
BitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];
BitmapFont.NUMERIC = [["0", "9"]];
BitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
BitmapFont.ASCII = [[" ", "~"]];
BitmapFont.defaultOptions = {
  resolution: 1,
  textureWidth: 512,
  textureHeight: 512,
  padding: 4,
  chars: _BitmapFont.ALPHANUMERIC
};
BitmapFont.available = {};


//# sourceMappingURL=BitmapFont.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitmapFontData": function() { return /* binding */ BitmapFontData; }
/* harmony export */ });
class BitmapFontData {
  constructor() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
}


//# sourceMappingURL=BitmapFontData.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapText.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapText.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitmapText": function() { return /* binding */ BitmapText; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.mjs");
/* harmony import */ var _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BitmapFont.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs");
/* harmony import */ var _shader_msdf_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shader/msdf.mjs */ "./node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs");
/* harmony import */ var _shader_msdf2_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shader/msdf2.mjs */ "./node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs");
/* harmony import */ var _utils_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/index.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/index.mjs");
/* harmony import */ var _utils_splitTextToCharacters_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/splitTextToCharacters.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs");
/* harmony import */ var _utils_extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/extractCharCode.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs");










const pageMeshDataDefaultPageMeshData = [];
const pageMeshDataMSDFPageMeshData = [];
const charRenderDataPool = [];
const _BitmapText = class extends _pixi_display__WEBPACK_IMPORTED_MODULE_1__.Container {
  constructor(text, style = {}) {
    super();
    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);
    if (!_BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFont.available[fontName]) {
      throw new Error(`Missing BitmapFont "${fontName}"`);
    }
    this._activePagesMeshData = [];
    this._textWidth = 0;
    this._textHeight = 0;
    this._align = align;
    this._tintColor = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color(tint);
    this._font = void 0;
    this._fontName = fontName;
    this._fontSize = fontSize;
    this.text = text;
    this._maxWidth = maxWidth;
    this._maxLineHeight = 0;
    this._letterSpacing = letterSpacing;
    this._anchor = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ObservablePoint(() => {
      this.dirty = true;
    }, this, 0, 0);
    this._roundPixels = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ROUND_PIXELS;
    this.dirty = true;
    this._resolution = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION;
    this._autoResolution = true;
    this._textureCache = {};
  }
  updateText() {
    const data = _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFont.available[this._fontName];
    const fontSize = this.fontSize;
    const scale = fontSize / data.size;
    const pos = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point();
    const chars = [];
    const lineWidths = [];
    const lineSpaces = [];
    const text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    const charsInput = (0,_utils_splitTextToCharacters_mjs__WEBPACK_IMPORTED_MODULE_7__.splitTextToCharacters)(text);
    const maxWidth = this._maxWidth * data.size / fontSize;
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    let prevCharCode = null;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    let line = 0;
    let lastBreakPos = -1;
    let lastBreakWidth = 0;
    let spacesRemoved = 0;
    let maxLineHeight = 0;
    let spaceCount = 0;
    for (let i = 0; i < charsInput.length; i++) {
      const char = charsInput[i];
      const charCode = (0,_utils_extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_8__.extractCharCode)(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      const charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      const charRenderData = charRenderDataPool.pop() || {
        texture: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);
      charRenderData.position.y = Math.round(pos.y + charData.yOffset);
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    const lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    const lineAlignOffsets = [];
    for (let i = 0; i <= line; i++) {
      let alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    const lenChars = chars.length;
    const pagesMeshData = {};
    const newPagesMeshData = [];
    const activePagesMeshData = this._activePagesMeshData;
    pageMeshDataPool.push(...activePagesMeshData);
    for (let i = 0; i < lenChars; i++) {
      const texture = chars[i].texture;
      const baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        let pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          const geometry = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_2__.MeshGeometry();
          let material;
          let meshBlendMode;
          if (data.distanceFieldType === "none") {
            material = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_2__.MeshMaterial(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY);
            meshBlendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL;
          } else {
            material = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_2__.MeshMaterial(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY, { program: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Program.from(_shader_msdf2_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], _shader_msdf_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]), uniforms: { uFWidth: 0 } });
            meshBlendMode = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.BLEND_MODES.NORMAL_NPM;
          }
          const mesh = new _pixi_mesh__WEBPACK_IMPORTED_MODULE_2__.Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        const { _textureCache } = this;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tintColor.value;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (let i = 0; i < activePagesMeshData.length; i++) {
      if (!newPagesMeshData.includes(activePagesMeshData[i])) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (let i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      const total = pageMeshData.total;
      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < _pixi_mesh__WEBPACK_IMPORTED_MODULE_2__.Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        const total2 = pageMeshData.total;
        const vertices = pageMeshData.vertices;
        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {
          vertices[i2] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (let i = 0; i < lenChars; i++) {
      const char = chars[i];
      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      const xPos = offset * scale;
      const yPos = char.position.y * scale;
      const texture = char.texture;
      const pageMesh = pagesMeshData[texture.baseTexture.uid];
      const textureFrame = texture.frame;
      const textureUvs = texture._uvs;
      const index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (const i in pagesMeshData) {
      const pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        let vertexCount = 0;
        const anchorOffsetX = this._textWidth * this.anchor.x;
        const anchorOffsetY = this._textHeight * this.anchor.y;
        for (let i2 = 0; i2 < pageMeshData.total; i2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      const indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (let i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
    this._font = data;
    this.dirty = false;
  }
  updateTransform() {
    this.validate();
    this.containerUpdateTransform();
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    const { distanceFieldRange, distanceFieldType, size } = _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFont.available[this._fontName];
    if (distanceFieldType !== "none") {
      const { a, b, c, d } = this.worldTransform;
      const dx = Math.sqrt(a * a + b * b);
      const dy = Math.sqrt(c * c + d * d);
      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      const fontScale = this.fontSize / size;
      const resolution = renderer._view.resolution;
      for (const mesh of this._activePagesMeshData) {
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
      }
    }
    super._render(renderer);
  }
  getLocalBounds() {
    this.validate();
    return super.getLocalBounds();
  }
  validate() {
    const font = _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFont.available[this._fontName];
    if (!font) {
      throw new Error(`Missing BitmapFont "${this._fontName}"`);
    }
    if (this._font !== font) {
      this.dirty = true;
    }
    if (this.dirty) {
      this.updateText();
    }
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(value) {
    if (this.tint === value)
      return;
    this._tintColor.setValue(value);
    for (let i = 0; i < this._activePagesMeshData.length; i++) {
      this._activePagesMeshData[i].mesh.tint = value;
    }
  }
  get align() {
    return this._align;
  }
  set align(value) {
    if (this._align !== value) {
      this._align = value;
      this.dirty = true;
    }
  }
  get fontName() {
    return this._fontName;
  }
  set fontName(value) {
    if (!_BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFont.available[value]) {
      throw new Error(`Missing BitmapFont "${value}"`);
    }
    if (this._fontName !== value) {
      this._fontName = value;
      this.dirty = true;
    }
  }
  get fontSize() {
    return this._fontSize ?? _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFont.available[this._fontName].size;
  }
  set fontSize(value) {
    if (this._fontSize !== value) {
      this._fontSize = value;
      this.dirty = true;
    }
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    if (typeof value === "number") {
      this._anchor.set(value);
    } else {
      this._anchor.copyFrom(value);
    }
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    if (this._maxWidth === value) {
      return;
    }
    this._maxWidth = value;
    this.dirty = true;
  }
  get maxLineHeight() {
    this.validate();
    return this._maxLineHeight;
  }
  get textWidth() {
    this.validate();
    return this._textWidth;
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value) {
    if (this._letterSpacing !== value) {
      this._letterSpacing = value;
      this.dirty = true;
    }
  }
  get roundPixels() {
    return this._roundPixels;
  }
  set roundPixels(value) {
    if (value !== this._roundPixels) {
      this._roundPixels = value;
      this.dirty = true;
    }
  }
  get textHeight() {
    this.validate();
    return this._textHeight;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  destroy(options) {
    const { _textureCache } = this;
    const data = _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_3__.BitmapFont.available[this._fontName];
    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    pageMeshDataPool.push(...this._activePagesMeshData);
    for (const pageMeshData of this._activePagesMeshData) {
      this.removeChild(pageMeshData.mesh);
    }
    this._activePagesMeshData = [];
    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {
      page.mesh.texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY;
    });
    for (const id in _textureCache) {
      const texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._font = null;
    this._tintColor = null;
    this._textureCache = null;
    super.destroy(options);
  }
};
let BitmapText = _BitmapText;
BitmapText.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0
};


//# sourceMappingURL=BitmapText.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=BitmapTextStyle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextFormat": function() { return /* binding */ TextFormat; }
/* harmony export */ });
/* harmony import */ var _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BitmapFontData.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs");


class TextFormat {
  static test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  }
  static parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i in items) {
      const name = items[i].match(/^[a-z]+/gm)[0];
      const attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i2 in attributeList) {
        const split = attributeList[i2].split("=");
        const key = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    const font = new _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_0__.BitmapFontData();
    rawData.info.forEach((info) => font.info.push({
      face: info.face,
      size: parseInt(info.size, 10)
    }));
    rawData.common.forEach((common) => font.common.push({
      lineHeight: parseInt(common.lineHeight, 10)
    }));
    rawData.page.forEach((page) => font.page.push({
      id: parseInt(page.id, 10),
      file: page.file
    }));
    rawData.char.forEach((char) => font.char.push({
      id: parseInt(char.id, 10),
      page: parseInt(char.page, 10),
      x: parseInt(char.x, 10),
      y: parseInt(char.y, 10),
      width: parseInt(char.width, 10),
      height: parseInt(char.height, 10),
      xoffset: parseInt(char.xoffset, 10),
      yoffset: parseInt(char.yoffset, 10),
      xadvance: parseInt(char.xadvance, 10)
    }));
    rawData.kerning.forEach((kerning) => font.kerning.push({
      first: parseInt(kerning.first, 10),
      second: parseInt(kerning.second, 10),
      amount: parseInt(kerning.amount, 10)
    }));
    rawData.distanceField.forEach((df) => font.distanceField.push({
      distanceRange: parseInt(df.distanceRange, 10),
      fieldType: df.fieldType
    }));
    return font;
  }
}


//# sourceMappingURL=TextFormat.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XMLFormat": function() { return /* binding */ XMLFormat; }
/* harmony export */ });
/* harmony import */ var _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../BitmapFontData.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs");


class XMLFormat {
  static test(data) {
    const xml = data;
    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }
  static parse(xml) {
    const data = new _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_0__.BitmapFontData();
    const info = xml.getElementsByTagName("info");
    const common = xml.getElementsByTagName("common");
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    const distanceField = xml.getElementsByTagName("distanceField");
    for (let i = 0; i < info.length; i++) {
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    }
    for (let i = 0; i < common.length; i++) {
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    }
    for (let i = 0; i < page.length; i++) {
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    for (let i = 0; i < char.length; i++) {
      const letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (let i = 0; i < kerning.length; i++) {
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    }
    for (let i = 0; i < distanceField.length; i++) {
      data.distanceField.push({
        fieldType: distanceField[i].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  }
}


//# sourceMappingURL=XMLFormat.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XMLStringFormat": function() { return /* binding */ XMLStringFormat; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XMLFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs");



class XMLStringFormat {
  static test(data) {
    if (typeof data === "string" && data.includes("<font>")) {
      return _XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.XMLFormat.test(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.parseXML(data));
    }
    return false;
  }
  static parse(xmlTxt) {
    return _XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.XMLFormat.parse(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.parseXML(xmlTxt));
  }
}


//# sourceMappingURL=XMLStringFormat.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/formats/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/formats/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextFormat": function() { return /* reexport safe */ _TextFormat_mjs__WEBPACK_IMPORTED_MODULE_0__.TextFormat; },
/* harmony export */   "XMLFormat": function() { return /* reexport safe */ _XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.XMLFormat; },
/* harmony export */   "XMLStringFormat": function() { return /* reexport safe */ _XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_2__.XMLStringFormat; },
/* harmony export */   "autoDetectFormat": function() { return /* binding */ autoDetectFormat; }
/* harmony export */ });
/* harmony import */ var _TextFormat_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs");
/* harmony import */ var _XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XMLFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs");
/* harmony import */ var _XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XMLStringFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs");







const formats = [
  _TextFormat_mjs__WEBPACK_IMPORTED_MODULE_0__.TextFormat,
  _XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_1__.XMLFormat,
  _XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_2__.XMLStringFormat
];
function autoDetectFormat(data) {
  for (let i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitmapFont": function() { return /* reexport safe */ _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_0__.BitmapFont; },
/* harmony export */   "BitmapFontData": function() { return /* reexport safe */ _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_1__.BitmapFontData; },
/* harmony export */   "BitmapText": function() { return /* reexport safe */ _BitmapText_mjs__WEBPACK_IMPORTED_MODULE_2__.BitmapText; },
/* harmony export */   "TextFormat": function() { return /* reexport safe */ _formats_TextFormat_mjs__WEBPACK_IMPORTED_MODULE_6__.TextFormat; },
/* harmony export */   "XMLFormat": function() { return /* reexport safe */ _formats_XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_7__.XMLFormat; },
/* harmony export */   "XMLStringFormat": function() { return /* reexport safe */ _formats_XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_8__.XMLStringFormat; },
/* harmony export */   "autoDetectFormat": function() { return /* reexport safe */ _formats_index_mjs__WEBPACK_IMPORTED_MODULE_4__.autoDetectFormat; },
/* harmony export */   "loadBitmapFont": function() { return /* reexport safe */ _loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_5__.loadBitmapFont; }
/* harmony export */ });
/* harmony import */ var _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BitmapFont.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs");
/* harmony import */ var _BitmapFontData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BitmapFontData.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs");
/* harmony import */ var _BitmapText_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BitmapText.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapText.mjs");
/* harmony import */ var _BitmapTextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BitmapTextStyle.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapTextStyle.mjs");
/* harmony import */ var _formats_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formats/index.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/index.mjs");
/* harmony import */ var _loadBitmapFont_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loadBitmapFont.mjs */ "./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs");
/* harmony import */ var _formats_TextFormat_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formats/TextFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs");
/* harmony import */ var _formats_XMLFormat_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./formats/XMLFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs");
/* harmony import */ var _formats_XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./formats/XMLStringFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs");









//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadBitmapFont": function() { return /* binding */ loadBitmapFont; }
/* harmony export */ });
/* harmony import */ var _pixi_assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BitmapFont.mjs */ "./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs");
/* harmony import */ var _formats_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formats/index.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/index.mjs");
/* harmony import */ var _formats_TextFormat_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formats/TextFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs");
/* harmony import */ var _formats_XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formats/XMLStringFormat.mjs */ "./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs");







const validExtensions = [".xml", ".fnt"];
const loadBitmapFont = {
  extension: {
    type: _pixi_core__WEBPACK_IMPORTED_MODULE_1__.ExtensionType.LoadParser,
    priority: _pixi_assets__WEBPACK_IMPORTED_MODULE_0__.LoaderParserPriority.Normal
  },
  name: "loadBitmapFont",
  test(url) {
    return validExtensions.includes(_pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.path.extname(url).toLowerCase());
  },
  async testParse(data) {
    return _formats_TextFormat_mjs__WEBPACK_IMPORTED_MODULE_4__.TextFormat.test(data) || _formats_XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_5__.XMLStringFormat.test(data);
  },
  async parse(asset, data, loader) {
    const fontData = _formats_TextFormat_mjs__WEBPACK_IMPORTED_MODULE_4__.TextFormat.test(asset) ? _formats_TextFormat_mjs__WEBPACK_IMPORTED_MODULE_4__.TextFormat.parse(asset) : _formats_XMLStringFormat_mjs__WEBPACK_IMPORTED_MODULE_5__.XMLStringFormat.parse(asset);
    const { src } = data;
    const { page: pages } = fontData;
    const textureUrls = [];
    for (let i = 0; i < pages.length; ++i) {
      const pageFile = pages[i].file;
      let imagePath = _pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.path.join(_pixi_core__WEBPACK_IMPORTED_MODULE_1__.utils.path.dirname(src), pageFile);
      imagePath = (0,_pixi_assets__WEBPACK_IMPORTED_MODULE_0__.copySearchParams)(imagePath, src);
      textureUrls.push(imagePath);
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url) => loadedTextures[url]);
    return _BitmapFont_mjs__WEBPACK_IMPORTED_MODULE_2__.BitmapFont.install(fontData, textures, true);
  },
  async load(url, _options) {
    const response = await _pixi_core__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.fetch(url);
    return response.text();
  },
  unload(bitmapFont) {
    bitmapFont.destroy();
  }
};
_pixi_core__WEBPACK_IMPORTED_MODULE_1__.extensions.add(loadBitmapFont);


//# sourceMappingURL=loadBitmapFont.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ msdfFrag; }
/* harmony export */ });
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n";


//# sourceMappingURL=msdf.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ msdfVert; }
/* harmony export */ });
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";


//# sourceMappingURL=msdf2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "drawGlyph": function() { return /* binding */ drawGlyph; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _generateFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateFillStyle.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs");



function drawGlyph(canvas, context, metrics, x, y, resolution, style) {
  const char = metrics.text;
  const fontProperties = metrics.fontProperties;
  context.translate(x, y);
  context.scale(resolution, resolution);
  const tx = style.strokeThickness / 2;
  const ty = -(style.strokeThickness / 2);
  context.font = style.toFontString();
  context.lineWidth = style.strokeThickness;
  context.textBaseline = style.textBaseline;
  context.lineJoin = style.lineJoin;
  context.miterLimit = style.miterLimit;
  context.fillStyle = (0,_generateFillStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.generateFillStyle)(canvas, context, style, resolution, [char], metrics);
  context.strokeStyle = style.stroke;
  if (style.dropShadow) {
    const dropShadowColor = style.dropShadowColor;
    const dropShadowBlur = style.dropShadowBlur * resolution;
    const dropShadowDistance = style.dropShadowDistance * resolution;
    context.shadowColor = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
    context.shadowBlur = dropShadowBlur;
    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context.shadowColor = "black";
    context.shadowBlur = 0;
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "rgba(0, 0, 0, 0)";
}


//# sourceMappingURL=drawGlyph.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extractCharCode": function() { return /* binding */ extractCharCode; }
/* harmony export */ });
function extractCharCode(str) {
  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);
}


//# sourceMappingURL=extractCharCode.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateFillStyle": function() { return /* binding */ generateFillStyle; }
/* harmony export */ });
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.mjs");


function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
  const fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  let gradient;
  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  const padding = style.padding || 0;
  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  const fill = fillStyle.slice();
  const fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    const lengthPlus1 = fill.length + 1;
    for (let i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === _pixi_text__WEBPACK_IMPORTED_MODULE_0__.TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
    let lastIterationStop = 0;
    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    const gradStopLineHeight = textHeight / height;
    for (let i = 0; i < lines.length; i++) {
      const thisLineTop = metrics.lineHeight * i;
      for (let j = 0; j < fill.length; j++) {
        let lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        let clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
    const totalIterations = fill.length + 1;
    let currentIteration = 1;
    for (let i = 0; i < fill.length; i++) {
      let stop;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}


//# sourceMappingURL=generateFillStyle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "drawGlyph": function() { return /* reexport safe */ _drawGlyph_mjs__WEBPACK_IMPORTED_MODULE_0__.drawGlyph; },
/* harmony export */   "extractCharCode": function() { return /* reexport safe */ _extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_1__.extractCharCode; },
/* harmony export */   "generateFillStyle": function() { return /* reexport safe */ _generateFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__.generateFillStyle; },
/* harmony export */   "resolveCharacters": function() { return /* reexport safe */ _resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_3__.resolveCharacters; },
/* harmony export */   "splitTextToCharacters": function() { return /* reexport safe */ _splitTextToCharacters_mjs__WEBPACK_IMPORTED_MODULE_4__.splitTextToCharacters; }
/* harmony export */ });
/* harmony import */ var _drawGlyph_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawGlyph.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs");
/* harmony import */ var _extractCharCode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extractCharCode.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs");
/* harmony import */ var _generateFillStyle_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generateFillStyle.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs");
/* harmony import */ var _resolveCharacters_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolveCharacters.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs");
/* harmony import */ var _splitTextToCharacters_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./splitTextToCharacters.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs");





//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "resolveCharacters": function() { return /* binding */ resolveCharacters; }
/* harmony export */ });
/* harmony import */ var _splitTextToCharacters_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./splitTextToCharacters.mjs */ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs");


function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i = 0, j = chars.length; i < j; i++) {
    const item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {
        result.push(String.fromCharCode(i2));
      }
    } else {
      result.push(...(0,_splitTextToCharacters_mjs__WEBPACK_IMPORTED_MODULE_0__.splitTextToCharacters)(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}


//# sourceMappingURL=resolveCharacters.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitTextToCharacters": function() { return /* binding */ splitTextToCharacters; }
/* harmony export */ });
function splitTextToCharacters(text) {
  return Array.from ? Array.from(text) : text.split("");
}


//# sourceMappingURL=splitTextToCharacters.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-html/lib/HTMLText.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/text-html/lib/HTMLText.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTMLText": function() { return /* binding */ HTMLText; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.mjs");
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.mjs");
/* harmony import */ var _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HTMLTextStyle.mjs */ "./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs");





const _HTMLText = class extends _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite {
  constructor(text = "", style = {}) {
    super(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.EMPTY);
    this._text = null;
    this._style = null;
    this._autoResolution = true;
    this._loading = false;
    this.localStyleID = -1;
    this.dirty = false;
    this.ownsStyle = false;
    const image = new Image();
    const texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.from(image, {
      scaleMode: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.SCALE_MODE,
      resourceOptions: {
        autoLoad: false
      }
    });
    texture.orig = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
    texture.trim = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
    this.texture = texture;
    const nssvg = "http://www.w3.org/2000/svg";
    const nsxhtml = "http://www.w3.org/1999/xhtml";
    const svgRoot = document.createElementNS(nssvg, "svg");
    const foreignObject = document.createElementNS(nssvg, "foreignObject");
    const domElement = document.createElementNS(nsxhtml, "div");
    const styleElement = document.createElementNS(nsxhtml, "style");
    foreignObject.setAttribute("width", "10000");
    foreignObject.setAttribute("height", "10000");
    foreignObject.style.overflow = "hidden";
    svgRoot.appendChild(foreignObject);
    this.maxWidth = _HTMLText.defaultMaxWidth;
    this.maxHeight = _HTMLText.defaultMaxHeight;
    this._domElement = domElement;
    this._styleElement = styleElement;
    this._svgRoot = svgRoot;
    this._foreignObject = foreignObject;
    this._foreignObject.appendChild(styleElement);
    this._foreignObject.appendChild(domElement);
    this._image = image;
    this._loadImage = new Image();
    this._autoResolution = _HTMLText.defaultAutoResolution;
    this._resolution = _HTMLText.defaultResolution ?? _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION;
    this.text = text;
    this.style = style;
  }
  measureText(overrides) {
    const { text, style, resolution } = Object.assign({
      text: this._text,
      style: this._style,
      resolution: this._resolution
    }, overrides);
    Object.assign(this._domElement, {
      innerHTML: text,
      style: style.toCSS(resolution)
    });
    this._styleElement.textContent = style.toGlobalCSS();
    document.body.appendChild(this._svgRoot);
    const contentBounds = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));
    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));
    this._svgRoot.setAttribute("width", contentWidth.toString());
    this._svgRoot.setAttribute("height", contentHeight.toString());
    if (text !== this._text) {
      this._domElement.innerHTML = this._text;
    }
    if (style !== this._style) {
      Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });
      this._styleElement.textContent = this._style?.toGlobalCSS();
    }
    return {
      width: contentWidth + style.padding * 2,
      height: contentHeight + style.padding * 2
    };
  }
  async updateText(respectDirty = true) {
    const { style, _image: image, _loadImage: loadImage } = this;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    const { width, height } = this.measureText();
    image.width = loadImage.width = Math.ceil(Math.max(1, width));
    image.height = loadImage.height = Math.ceil(Math.max(1, height));
    if (!this._loading) {
      this._loading = true;
      await new Promise((resolve) => {
        loadImage.onload = async () => {
          await style.onBeforeDraw();
          this._loading = false;
          image.src = loadImage.src;
          loadImage.onload = null;
          loadImage.src = "";
          this.updateTexture();
          resolve();
        };
        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);
        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
      });
    }
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style, texture, _image: image, resolution } = this;
    const { padding } = style;
    const { baseTexture } = texture;
    texture.trim.width = texture._frame.width = image.width / resolution;
    texture.trim.height = texture._frame.height = image.height / resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(image.width, image.height, resolution);
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  _renderCanvas(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._renderCanvas(renderer);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds(rect);
  }
  _calculateBounds() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _onStyleChange() {
    this.dirty = true;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);
    super.destroy(options);
    const forceClear = null;
    if (this.ownsStyle) {
      this._style?.cleanFonts();
    }
    this._style = forceClear;
    this._svgRoot?.remove();
    this._svgRoot = forceClear;
    this._domElement?.remove();
    this._domElement = forceClear;
    this._foreignObject?.remove();
    this._foreignObject = forceClear;
    this._styleElement?.remove();
    this._styleElement = forceClear;
    this._loadImage.src = "";
    this._loadImage.onload = null;
    this._loadImage = forceClear;
    this._image.src = "";
    this._image = forceClear;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._image.width / this.resolution;
  }
  set width(value) {
    this.updateText(true);
    const s = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._image.width / this.resolution;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._image.height / this.resolution;
  }
  set height(value) {
    this.updateText(true);
    const s = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._image.height / this.resolution;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    if (this._style === style) {
      return;
    }
    style = style || {};
    if (style instanceof _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.HTMLTextStyle) {
      this.ownsStyle = false;
      this._style = style;
    } else if (style instanceof _pixi_text__WEBPACK_IMPORTED_MODULE_2__.TextStyle) {
      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");
      this.ownsStyle = true;
      this._style = _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.HTMLTextStyle.from(style);
    } else {
      this.ownsStyle = true;
      this._style = new _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.HTMLTextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === "" || text === null || text === void 0 ? " " : text);
    text = this.sanitiseText(text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
  sanitiseText(text) {
    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");
  }
};
let HTMLText = _HTMLText;
HTMLText.defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
HTMLText.defaultMaxWidth = 2024;
HTMLText.defaultMaxHeight = 2024;
HTMLText.defaultAutoResolution = true;


//# sourceMappingURL=HTMLText.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTMLTextStyle": function() { return /* binding */ HTMLTextStyle; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.mjs");



const _HTMLTextStyle = class extends _pixi_text__WEBPACK_IMPORTED_MODULE_1__.TextStyle {
  constructor() {
    super(...arguments);
    this._fonts = [];
    this._overrides = [];
    this._stylesheet = "";
    this.fontsDirty = false;
  }
  static from(originalStyle) {
    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));
  }
  cleanFonts() {
    if (this._fonts.length > 0) {
      this._fonts.forEach((font) => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        if (font.refs === 0) {
          if (font.fontFace) {
            document.fonts.delete(font.fontFace);
          }
          delete _HTMLTextStyle.availableFonts[font.originalUrl];
        }
      });
      this.fontFamily = "Arial";
      this._fonts.length = 0;
      this.styleID++;
      this.fontsDirty = true;
    }
  }
  loadFont(url, options = {}) {
    const { availableFonts } = _HTMLTextStyle;
    if (availableFonts[url]) {
      const font = availableFonts[url];
      this._fonts.push(font);
      font.refs++;
      this.styleID++;
      this.fontsDirty = true;
      return Promise.resolve();
    }
    return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {
      const src = URL.createObjectURL(blob);
      const reader = new FileReader();
      reader.onload = () => resolve([src, reader.result]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    })).then(async ([src, dataSrc]) => {
      const font = Object.assign({
        family: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.basename(url, _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.path.extname(url)),
        weight: "normal",
        style: "normal",
        src,
        dataSrc,
        refs: 1,
        originalUrl: url,
        fontFace: null
      }, options);
      availableFonts[url] = font;
      this._fonts.push(font);
      this.styleID++;
      const fontFace = new FontFace(font.family, `url(${font.src})`, {
        weight: font.weight,
        style: font.style
      });
      font.fontFace = fontFace;
      await fontFace.load();
      document.fonts.add(fontFace);
      await document.fonts.ready;
      this.styleID++;
      this.fontsDirty = true;
    });
  }
  addOverride(...value) {
    const toAdd = value.filter((v) => !this._overrides.includes(v));
    if (toAdd.length > 0) {
      this._overrides.push(...toAdd);
      this.styleID++;
    }
  }
  removeOverride(...value) {
    const toRemove = value.filter((v) => this._overrides.includes(v));
    if (toRemove.length > 0) {
      this._overrides = this._overrides.filter((v) => !toRemove.includes(v));
      this.styleID++;
    }
  }
  toCSS(scale) {
    return [
      `transform: scale(${scale})`,
      `transform-origin: top left`,
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],
      ...this.wordWrap ? [
        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
        `max-width: ${this.wordWrapWidth}px`
      ] : [],
      ...this.strokeThickness ? [
        `-webkit-text-stroke-width: ${this.strokeThickness}px`,
        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        `text-stroke-width: ${this.strokeThickness}px`,
        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
        "paint-order: stroke"
      ] : [],
      ...this.dropShadow ? [this.dropShadowToCSS()] : [],
      ...this._overrides
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style}; 
            }`, this._stylesheet);
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(value) {
    if (this._stylesheet !== value) {
      this._stylesheet = value;
      this.styleID++;
    }
  }
  normalizeColor(color) {
    if (Array.isArray(color)) {
      color = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.rgb2hex(color);
    }
    if (typeof color === "number") {
      return _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.hex2string(color);
    }
    return color;
  }
  dropShadowToCSS() {
    let color = this.normalizeColor(this.dropShadowColor);
    const alpha = this.dropShadowAlpha;
    const x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);
    const y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    if (color.startsWith("#") && alpha < 1) {
      color += (alpha * 255 | 0).toString(16).padStart(2, "0");
    }
    const position = `${x}px ${y}px`;
    if (this.dropShadowBlur > 0) {
      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;
    }
    return `text-shadow: ${position} ${color}`;
  }
  reset() {
    Object.assign(this, _HTMLTextStyle.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: prevFontsDirty } = this;
    this.fontsDirty = false;
    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {
      return new Promise((resolve) => setTimeout(resolve, 100));
    }
    return Promise.resolve();
  }
  get isSafari() {
    const { userAgent } = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(userAgent);
  }
  set fillGradientStops(_value) {
    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(_value) {
    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(_value) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(_value) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(_value) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(_value) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(_value) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
let HTMLTextStyle = _HTMLTextStyle;
HTMLTextStyle.availableFonts = {};
HTMLTextStyle.defaultOptions = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  whiteSpace: "normal",
  wordWrap: false,
  wordWrapWidth: 100
};


//# sourceMappingURL=HTMLTextStyle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text-html/lib/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/text-html/lib/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HTMLText": function() { return /* reexport safe */ _HTMLText_mjs__WEBPACK_IMPORTED_MODULE_0__.HTMLText; },
/* harmony export */   "HTMLTextStyle": function() { return /* reexport safe */ _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__.HTMLTextStyle; }
/* harmony export */ });
/* harmony import */ var _HTMLText_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HTMLText.mjs */ "./node_modules/@pixi/text-html/lib/HTMLText.mjs");
/* harmony import */ var _HTMLTextStyle_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HTMLTextStyle.mjs */ "./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs");


//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/Text.mjs":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/text/lib/Text.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Text": function() { return /* binding */ Text; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/text/lib/const.mjs");
/* harmony import */ var _TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextMetrics.mjs */ "./node_modules/@pixi/text/lib/TextMetrics.mjs");
/* harmony import */ var _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextStyle.mjs */ "./node_modules/@pixi/text/lib/TextStyle.mjs");






const defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
const _Text = class extends _pixi_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite {
  constructor(text, style, canvas) {
    let ownCanvas = false;
    if (!canvas) {
      canvas = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.createCanvas();
      ownCanvas = true;
    }
    canvas.width = 3;
    canvas.height = 3;
    const texture = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Texture.from(canvas);
    texture.orig = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
    texture.trim = new _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
    super(texture);
    this._ownCanvas = ownCanvas;
    this.canvas = canvas;
    this.context = canvas.getContext("2d", {
      willReadFrequently: true
    });
    this._resolution = _Text.defaultResolution ?? _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION;
    this._autoResolution = _Text.defaultAutoResolution;
    this._text = null;
    this._style = null;
    this._styleListener = null;
    this._font = "";
    this.text = text;
    this.style = style;
    this.localStyleID = -1;
  }
  static get experimentalLetterSpacing() {
    return _TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.TextMetrics.experimentalLetterSpacing;
  }
  static set experimentalLetterSpacing(value) {
    _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
    _TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.TextMetrics.experimentalLetterSpacing = value;
  }
  updateText(respectDirty) {
    const style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    const context = this.context;
    const measured = _TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    const width = measured.width;
    const height = measured.height;
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context.scale(this._resolution, this._resolution);
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context.font = this._font;
    context.lineWidth = style.strokeThickness;
    context.textBaseline = style.textBaseline;
    context.lineJoin = style.lineJoin;
    context.miterLimit = style.miterLimit;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i = 0; i < passesCount; ++i) {
      const isShadowPass = style.dropShadow && i === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context.fillStyle = "black";
        context.strokeStyle = "black";
        const dropShadowColor = style.dropShadowColor;
        const dropShadowBlur = style.dropShadowBlur * this._resolution;
        const dropShadowDistance = style.dropShadowDistance * this._resolution;
        context.shadowColor = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
        context.shadowBlur = dropShadowBlur;
        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context.fillStyle = this._generateFillStyle(style, lines, measured);
        context.strokeStyle = style.stroke;
        context.shadowColor = "black";
        context.shadowBlur = 0;
        context.shadowOffsetX = 0;
        context.shadowOffsetY = 0;
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (let i2 = 0; i2 < lines.length; i2++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i2];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  }
  drawLetterSpacing(text, x, y, isStroke = false) {
    const style = this._style;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.TextMetrics.experimentalLetterSpacing) {
        this.context.letterSpacing = `${letterSpacing}px`;
        this.context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        this.context.letterSpacing = "0px";
        this.context.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        this.context.strokeText(text, x, y);
      } else {
        this.context.fillText(text, x, y);
      }
      return;
    }
    let currentPosition = x;
    const stringArray = _TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_3__.TextMetrics.graphemeSegmenter(text);
    let previousWidth = this.context.measureText(text).width;
    let currentWidth = 0;
    for (let i = 0; i < stringArray.length; ++i) {
      const currentChar = stringArray[i];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y);
      } else {
        this.context.fillText(currentChar, currentPosition, y);
      }
      let textStr = "";
      for (let j = i + 1; j < stringArray.length; ++j) {
        textStr += stringArray[j];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
  updateTexture() {
    const canvas = this.canvas;
    if (this._style.trim) {
      const trimmed = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.trimCanvas(canvas);
      if (trimmed.data) {
        canvas.width = trimmed.width;
        canvas.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    const texture = this._texture;
    const style = this._style;
    const padding = style.trim ? 0 : style.padding;
    const baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
    texture.updateUvs();
    this.dirty = false;
  }
  _render(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    super._render(renderer);
  }
  updateTransform() {
    this.updateText(true);
    super.updateTransform();
  }
  getBounds(skipUpdate, rect) {
    this.updateText(true);
    if (this._textureID === -1) {
      skipUpdate = false;
    }
    return super.getBounds(skipUpdate, rect);
  }
  getLocalBounds(rect) {
    this.updateText(true);
    return super.getLocalBounds.call(this, rect);
  }
  _calculateBounds() {
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  }
  _generateFillStyle(style, lines, metrics) {
    const fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    let gradient;
    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    const padding = style.padding || 0;
    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    const fill = fillStyle.slice();
    const fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      const lengthPlus1 = fill.length + 1;
      for (let i = 1; i < lengthPlus1; ++i) {
        fillGradientStops.push(i / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === _const_mjs__WEBPACK_IMPORTED_MODULE_2__.TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (let i = 0; i < lines.length; i++) {
        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;
        const thisLineTop = metrics.lineHeight * i;
        let thisLineGradientStart = thisLineTop;
        if (i > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        const thisLineBottom = thisLineTop + textHeight;
        const nextLineTop = metrics.lineHeight * (i + 1);
        let thisLineGradientEnd = thisLineBottom;
        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (let j = 0; j < fill.length; j++) {
          let lineStop = 0;
          if (typeof fillGradientStops[j] === "number") {
            lineStop = fillGradientStops[j];
          } else {
            lineStop = j / fill.length;
          }
          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      const totalIterations = fill.length + 1;
      let currentIteration = 1;
      for (let i = 0; i < fill.length; i++) {
        let stop;
        if (typeof fillGradientStops[i] === "number") {
          stop = fillGradientStops[i];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i]);
        currentIteration++;
      }
    }
    return gradient;
  }
  destroy(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    super.destroy(options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  }
  get width() {
    this.updateText(true);
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this.updateText(true);
    const s = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.x) || 1;
    this.scale.x = s * value / this._texture.orig.width;
    this._width = value;
  }
  get height() {
    this.updateText(true);
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this.updateText(true);
    const s = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.sign(this.scale.y) || 1;
    this.scale.y = s * value / this._texture.orig.height;
    this._height = value;
  }
  get style() {
    return this._style;
  }
  set style(style) {
    style = style || {};
    if (style instanceof _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_4__.TextStyle) {
      this._style = style;
    } else {
      this._style = new _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_4__.TextStyle(style);
    }
    this.localStyleID = -1;
    this.dirty = true;
  }
  get text() {
    return this._text;
  }
  set text(text) {
    text = String(text === null || text === void 0 ? "" : text);
    if (this._text === text) {
      return;
    }
    this._text = text;
    this.dirty = true;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(value) {
    this._autoResolution = false;
    if (this._resolution === value) {
      return;
    }
    this._resolution = value;
    this.dirty = true;
  }
};
let Text = _Text;
Text.defaultAutoResolution = true;


//# sourceMappingURL=Text.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/TextMetrics.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@pixi/text/lib/TextMetrics.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextMetrics": function() { return /* binding */ TextMetrics; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");


const contextSettings = {
  willReadFrequently: true
};
const _TextMetrics = class {
  static get experimentalLetterSpacingSupported() {
    let result = _TextMetrics._experimentalLetterSpacingSupported;
    if (result !== void 0) {
      const proto = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.getCanvasRenderingContext2D().prototype;
      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    const font = style.toFontString();
    const fontProperties = _TextMetrics.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context = canvas.getContext("2d", contextSettings);
    context.font = font;
    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context);
      lineWidths[i] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    let width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  }
  static _measureText(text, letterSpacing, context) {
    let useExperimentalLetterSpacing = false;
    if (_TextMetrics.experimentalLetterSpacingSupported) {
      if (_TextMetrics.experimentalLetterSpacing) {
        context.letterSpacing = `${letterSpacing}px`;
        context.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context.letterSpacing = "0px";
        context.textLetterSpacing = "0px";
      }
    }
    let width = context.measureText(text).width;
    if (width > 0) {
      if (useExperimentalLetterSpacing) {
        width -= letterSpacing;
      } else {
        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;
      }
    }
    return width;
  }
  static wordWrap(text, style, canvas = _TextMetrics._canvas) {
    const context = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);
    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _TextMetrics.tokenize(text);
    for (let i = 0; i < tokens.length; i++) {
      let token = tokens[i];
      if (_TextMetrics.isNewline(token)) {
        if (!collapseNewlines) {
          lines += _TextMetrics.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);
        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (_TextMetrics.canBreakWords(token, style.breakWords)) {
          const characters = _TextMetrics.wordWrapSplit(token);
          for (let j = 0; j < characters.length; j++) {
            let char = characters[j];
            let lastChar = char;
            let k = 1;
            while (characters[j + k]) {
              const nextChar = characters[j + k];
              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k++;
            }
            j += k - 1;
            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context);
            if (characterWidth + width > wordWrapWidth) {
              lines += _TextMetrics.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _TextMetrics.addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i === tokens.length - 1;
          lines += _TextMetrics.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _TextMetrics.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _TextMetrics.addLine(line, false);
    return lines;
  }
  static addLine(line, newLine = true) {
    line = _TextMetrics.trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  static getFromCache(key, letterSpacing, cache, context) {
    let width = cache[key];
    if (typeof width !== "number") {
      width = _TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;
      cache[key] = width;
    }
    return width;
  }
  static collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  static collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  static trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i = text.length - 1; i >= 0; i--) {
      const char = text[i];
      if (!_TextMetrics.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  static isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._newlines.includes(char.charCodeAt(0));
  }
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));
  }
  static tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const nextChar = text[i + 1];
      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  static wordWrapSplit(token) {
    return _TextMetrics.graphemeSegmenter(token);
  }
  static measureFont(font) {
    if (_TextMetrics._fonts[font]) {
      return _TextMetrics._fonts[font];
    }
    const properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    const canvas = _TextMetrics._canvas;
    const context = _TextMetrics._context;
    context.font = font;
    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;
    const width = Math.ceil(context.measureText(metricsString).width);
    let baseline = Math.ceil(context.measureText(_TextMetrics.BASELINE_SYMBOL).width);
    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;
    if (width === 0 || height === 0) {
      _TextMetrics._fonts[font] = properties;
      return properties;
    }
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = "#f00";
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    context.fillText(metricsString, 0, baseline);
    const imagedata = context.getImageData(0, 0, width, height).data;
    const pixels = imagedata.length;
    const line = width * 4;
    let i = 0;
    let idx = 0;
    let stop = false;
    for (i = 0; i < baseline; ++i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    for (i = height; i > baseline; --i) {
      for (let j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    _TextMetrics._fonts[font] = properties;
    return properties;
  }
  static clearMetrics(font = "") {
    if (font) {
      delete _TextMetrics._fonts[font];
    } else {
      _TextMetrics._fonts = {};
    }
  }
  static get _canvas() {
    if (!_TextMetrics.__canvas) {
      let canvas;
      try {
        const c = new OffscreenCanvas(0, 0);
        const context = c.getContext("2d", contextSettings);
        if (context?.measureText) {
          _TextMetrics.__canvas = c;
          return c;
        }
        canvas = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.createCanvas();
      } catch (ex) {
        canvas = _pixi_core__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.createCanvas();
      }
      canvas.width = canvas.height = 10;
      _TextMetrics.__canvas = canvas;
    }
    return _TextMetrics.__canvas;
  }
  static get _context() {
    if (!_TextMetrics.__context) {
      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);
    }
    return _TextMetrics.__context;
  }
};
let TextMetrics = _TextMetrics;
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter === "function") {
    const segmenter = new Intl.Segmenter();
    return (s) => [...segmenter.segment(s)].map((x) => x.segment);
  }
  return (s) => [...s];
})();
TextMetrics.experimentalLetterSpacing = false;
TextMetrics._fonts = {};
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];


//# sourceMappingURL=TextMetrics.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/TextStyle.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/text/lib/TextStyle.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextStyle": function() { return /* binding */ TextStyle; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/text/lib/const.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");



const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
const _TextStyle = class {
  constructor(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  clone() {
    const clonedProperties = {};
    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);
    return new _TextStyle(clonedProperties);
  }
  reset() {
    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);
  }
  get align() {
    return this._align;
  }
  set align(align) {
    if (this._align !== align) {
      this._align = align;
      this.styleID++;
    }
  }
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(breakWords) {
    if (this._breakWords !== breakWords) {
      this._breakWords = breakWords;
      this.styleID++;
    }
  }
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(dropShadow) {
    if (this._dropShadow !== dropShadow) {
      this._dropShadow = dropShadow;
      this.styleID++;
    }
  }
  get dropShadowAlpha() {
    return this._dropShadowAlpha;
  }
  set dropShadowAlpha(dropShadowAlpha) {
    if (this._dropShadowAlpha !== dropShadowAlpha) {
      this._dropShadowAlpha = dropShadowAlpha;
      this.styleID++;
    }
  }
  get dropShadowAngle() {
    return this._dropShadowAngle;
  }
  set dropShadowAngle(dropShadowAngle) {
    if (this._dropShadowAngle !== dropShadowAngle) {
      this._dropShadowAngle = dropShadowAngle;
      this.styleID++;
    }
  }
  get dropShadowBlur() {
    return this._dropShadowBlur;
  }
  set dropShadowBlur(dropShadowBlur) {
    if (this._dropShadowBlur !== dropShadowBlur) {
      this._dropShadowBlur = dropShadowBlur;
      this.styleID++;
    }
  }
  get dropShadowColor() {
    return this._dropShadowColor;
  }
  set dropShadowColor(dropShadowColor) {
    const outputColor = getColor(dropShadowColor);
    if (this._dropShadowColor !== outputColor) {
      this._dropShadowColor = outputColor;
      this.styleID++;
    }
  }
  get dropShadowDistance() {
    return this._dropShadowDistance;
  }
  set dropShadowDistance(dropShadowDistance) {
    if (this._dropShadowDistance !== dropShadowDistance) {
      this._dropShadowDistance = dropShadowDistance;
      this.styleID++;
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(fill) {
    const outputColor = getColor(fill);
    if (this._fill !== outputColor) {
      this._fill = outputColor;
      this.styleID++;
    }
  }
  get fillGradientType() {
    return this._fillGradientType;
  }
  set fillGradientType(fillGradientType) {
    if (this._fillGradientType !== fillGradientType) {
      this._fillGradientType = fillGradientType;
      this.styleID++;
    }
  }
  get fillGradientStops() {
    return this._fillGradientStops;
  }
  set fillGradientStops(fillGradientStops) {
    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
      this._fillGradientStops = fillGradientStops;
      this.styleID++;
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(fontFamily) {
    if (this.fontFamily !== fontFamily) {
      this._fontFamily = fontFamily;
      this.styleID++;
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(fontSize) {
    if (this._fontSize !== fontSize) {
      this._fontSize = fontSize;
      this.styleID++;
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(fontStyle) {
    if (this._fontStyle !== fontStyle) {
      this._fontStyle = fontStyle;
      this.styleID++;
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(fontVariant) {
    if (this._fontVariant !== fontVariant) {
      this._fontVariant = fontVariant;
      this.styleID++;
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(fontWeight) {
    if (this._fontWeight !== fontWeight) {
      this._fontWeight = fontWeight;
      this.styleID++;
    }
  }
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(letterSpacing) {
    if (this._letterSpacing !== letterSpacing) {
      this._letterSpacing = letterSpacing;
      this.styleID++;
    }
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(lineHeight) {
    if (this._lineHeight !== lineHeight) {
      this._lineHeight = lineHeight;
      this.styleID++;
    }
  }
  get leading() {
    return this._leading;
  }
  set leading(leading) {
    if (this._leading !== leading) {
      this._leading = leading;
      this.styleID++;
    }
  }
  get lineJoin() {
    return this._lineJoin;
  }
  set lineJoin(lineJoin) {
    if (this._lineJoin !== lineJoin) {
      this._lineJoin = lineJoin;
      this.styleID++;
    }
  }
  get miterLimit() {
    return this._miterLimit;
  }
  set miterLimit(miterLimit) {
    if (this._miterLimit !== miterLimit) {
      this._miterLimit = miterLimit;
      this.styleID++;
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(padding) {
    if (this._padding !== padding) {
      this._padding = padding;
      this.styleID++;
    }
  }
  get stroke() {
    return this._stroke;
  }
  set stroke(stroke) {
    const outputColor = getColor(stroke);
    if (this._stroke !== outputColor) {
      this._stroke = outputColor;
      this.styleID++;
    }
  }
  get strokeThickness() {
    return this._strokeThickness;
  }
  set strokeThickness(strokeThickness) {
    if (this._strokeThickness !== strokeThickness) {
      this._strokeThickness = strokeThickness;
      this.styleID++;
    }
  }
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(textBaseline) {
    if (this._textBaseline !== textBaseline) {
      this._textBaseline = textBaseline;
      this.styleID++;
    }
  }
  get trim() {
    return this._trim;
  }
  set trim(trim) {
    if (this._trim !== trim) {
      this._trim = trim;
      this.styleID++;
    }
  }
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(whiteSpace) {
    if (this._whiteSpace !== whiteSpace) {
      this._whiteSpace = whiteSpace;
      this.styleID++;
    }
  }
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(wordWrap) {
    if (this._wordWrap !== wordWrap) {
      this._wordWrap = wordWrap;
      this.styleID++;
    }
  }
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(wordWrapWidth) {
    if (this._wordWrapWidth !== wordWrapWidth) {
      this._wordWrapWidth = wordWrapWidth;
      this.styleID++;
    }
  }
  toFontString() {
    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;
    let fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (let i = fontFamilies.length - 1; i >= 0; i--) {
      let fontFamily = fontFamilies[i].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
        fontFamily = `"${fontFamily}"`;
      }
      fontFamilies[i] = fontFamily;
    }
    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
  }
};
let TextStyle = _TextStyle;
TextStyle.defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: _const_mjs__WEBPACK_IMPORTED_MODULE_0__.TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};
function getColor(color) {
  const temp = _pixi_core__WEBPACK_IMPORTED_MODULE_1__.Color.shared;
  if (!Array.isArray(color)) {
    return temp.setValue(color).toHex();
  } else {
    return color.map((c) => temp.setValue(c).toHex());
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (const prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}


//# sourceMappingURL=TextStyle.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/const.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/text/lib/const.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TEXT_GRADIENT": function() { return /* binding */ TEXT_GRADIENT; }
/* harmony export */ });
var TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
  return TEXT_GRADIENT2;
})(TEXT_GRADIENT || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/text/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/text/lib/index.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TEXT_GRADIENT": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_0__.TEXT_GRADIENT; },
/* harmony export */   "Text": function() { return /* reexport safe */ _Text_mjs__WEBPACK_IMPORTED_MODULE_1__.Text; },
/* harmony export */   "TextMetrics": function() { return /* reexport safe */ _TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_2__.TextMetrics; },
/* harmony export */   "TextStyle": function() { return /* reexport safe */ _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__.TextStyle; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/text/lib/const.mjs");
/* harmony import */ var _Text_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Text.mjs */ "./node_modules/@pixi/text/lib/Text.mjs");
/* harmony import */ var _TextMetrics_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextMetrics.mjs */ "./node_modules/@pixi/text/lib/TextMetrics.mjs");
/* harmony import */ var _TextStyle_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextStyle.mjs */ "./node_modules/@pixi/text/lib/TextStyle.mjs");




//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/Ticker.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/Ticker.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ticker": function() { return /* binding */ Ticker; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/ticker/lib/const.mjs");
/* harmony import */ var _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TickerListener.mjs */ "./node_modules/@pixi/ticker/lib/TickerListener.mjs");



const _Ticker = class {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_1__.TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  add(fn, context, priority = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_1__.TickerListener(fn, context, priority));
  }
  addOnce(fn, context, priority = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new _TickerListener_mjs__WEBPACK_IMPORTED_MODULE_1__.TickerListener(fn, context, priority, true));
  }
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  remove(fn, context) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
let Ticker = _Ticker;
Ticker.targetFPMS = 0.06;


//# sourceMappingURL=Ticker.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/TickerListener.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/TickerListener.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TickerListener": function() { return /* binding */ TickerListener; }
/* harmony export */ });
class TickerListener {
  constructor(fn, context = null, priority = 0, once = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context;
    this.priority = priority;
    this.once = once;
  }
  match(fn, context = null) {
    return this.fn === fn && this.context === context;
  }
  emit(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    const redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  destroy(hard = false) {
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}


//# sourceMappingURL=TickerListener.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/TickerPlugin.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/TickerPlugin.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TickerPlugin": function() { return /* binding */ TickerPlugin; }
/* harmony export */ });
/* harmony import */ var _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/extensions */ "./node_modules/@pixi/extensions/lib/index.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/ticker/lib/const.mjs");
/* harmony import */ var _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Ticker.mjs */ "./node_modules/@pixi/ticker/lib/Ticker.mjs");




class TickerPlugin {
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, _const_mjs__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY.LOW);
        }
      },
      get() {
        return this._ticker;
      }
    });
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker.shared : new _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker();
    if (options.autoStart) {
      this.start();
    }
  }
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
TickerPlugin.extension = _pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.ExtensionType.Application;
_pixi_extensions__WEBPACK_IMPORTED_MODULE_0__.extensions.add(TickerPlugin);


//# sourceMappingURL=TickerPlugin.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/const.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/const.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UPDATE_PRIORITY": function() { return /* binding */ UPDATE_PRIORITY; }
/* harmony export */ });
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/index.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/index.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ticker": function() { return /* reexport safe */ _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker; },
/* harmony export */   "TickerPlugin": function() { return /* reexport safe */ _TickerPlugin_mjs__WEBPACK_IMPORTED_MODULE_3__.TickerPlugin; },
/* harmony export */   "UPDATE_PRIORITY": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_1__.UPDATE_PRIORITY; }
/* harmony export */ });
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi/ticker/lib/settings.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/ticker/lib/const.mjs");
/* harmony import */ var _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Ticker.mjs */ "./node_modules/@pixi/ticker/lib/Ticker.mjs");
/* harmony import */ var _TickerPlugin_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TickerPlugin.mjs */ "./node_modules/@pixi/ticker/lib/TickerPlugin.mjs");




//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/ticker/lib/settings.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/ticker/lib/settings.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "settings": function() { return /* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings; }
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/utils */ "./node_modules/@pixi/utils/lib/index.mjs");
/* harmony import */ var _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Ticker.mjs */ "./node_modules/@pixi/ticker/lib/Ticker.mjs");





Object.defineProperties(_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings, {
  TARGET_FPMS: {
    get() {
      return _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker.targetFPMS;
    },
    set(value) {
      (0,_pixi_utils__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");
      _Ticker_mjs__WEBPACK_IMPORTED_MODULE_2__.Ticker.targetFPMS = value;
    }
  }
});
//# sourceMappingURL=settings.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/unsafe-eval/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/unsafe-eval/lib/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": function() { return /* reexport safe */ _install_mjs__WEBPACK_IMPORTED_MODULE_0__.install; }
/* harmony export */ });
/* harmony import */ var _install_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./install.mjs */ "./node_modules/@pixi/unsafe-eval/lib/install.mjs");

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/unsafe-eval/lib/install.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/unsafe-eval/lib/install.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "install": function() { return /* binding */ install; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _syncUniforms_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./syncUniforms.mjs */ "./node_modules/@pixi/unsafe-eval/lib/syncUniforms.mjs");



function install(_core) {
  _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.deprecation("7.1.0", "install() has been deprecated, @pixi/unsafe-eval is self-installed since 7.1.0");
}
function selfInstall() {
  Object.assign(_pixi_core__WEBPACK_IMPORTED_MODULE_0__.ShaderSystem.prototype, {
    systemCheck() {
    },
    syncUniforms(group, glProgram) {
      const { shader, renderer } = this;
      (0,_syncUniforms_mjs__WEBPACK_IMPORTED_MODULE_1__.syncUniforms)(group, shader.program.uniformData, glProgram.uniformData, group.uniforms, renderer);
    }
  });
}
selfInstall();


//# sourceMappingURL=install.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/unsafe-eval/lib/syncUniforms.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/unsafe-eval/lib/syncUniforms.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "syncUniforms": function() { return /* binding */ syncUniforms; }
/* harmony export */ });
const GLSL_TO_SINGLE_SETTERS = {
  float(gl, location, cv, v) {
    if (cv !== v) {
      cv.v = v;
      gl.uniform1f(location, v);
    }
  },
  vec2(gl, location, cv, v) {
    if (cv[0] !== v[0] || cv[1] !== v[1]) {
      cv[0] = v[0];
      cv[1] = v[1];
      gl.uniform2f(location, v[0], v[1]);
    }
  },
  vec3(gl, location, cv, v) {
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
      cv[0] = v[0];
      cv[1] = v[1];
      cv[2] = v[2];
      gl.uniform3f(location, v[0], v[1], v[2]);
    }
  },
  int(gl, location, _cv, value) {
    gl.uniform1i(location, value);
  },
  ivec2(gl, location, _cv, value) {
    gl.uniform2i(location, value[0], value[1]);
  },
  ivec3(gl, location, _cv, value) {
    gl.uniform3i(location, value[0], value[1], value[2]);
  },
  ivec4(gl, location, _cv, value) {
    gl.uniform4i(location, value[0], value[1], value[2], value[3]);
  },
  uint(gl, location, _cv, value) {
    gl.uniform1ui(location, value);
  },
  uvec2(gl, location, _cv, value) {
    gl.uniform2ui(location, value[0], value[1]);
  },
  uvec3(gl, location, _cv, value) {
    gl.uniform3ui(location, value[0], value[1], value[2]);
  },
  uvec4(gl, location, _cv, value) {
    gl.uniform4ui(location, value[0], value[1], value[2], value[3]);
  },
  bool(gl, location, cv, v) {
    if (cv !== v) {
      cv.v = v;
      gl.uniform1i(location, Number(v));
    }
  },
  bvec2(gl, location, _cv, value) {
    gl.uniform2i(location, value[0], value[1]);
  },
  bvec3(gl, location, _cv, value) {
    gl.uniform3i(location, value[0], value[1], value[2]);
  },
  bvec4(gl, location, _cv, value) {
    gl.uniform4i(location, value[0], value[1], value[2], value[3]);
  },
  mat2(gl, location, _cv, value) {
    gl.uniformMatrix2fv(location, false, value);
  },
  mat3(gl, location, _cv, value) {
    gl.uniformMatrix3fv(location, false, value);
  },
  mat4(gl, location, _cv, value) {
    gl.uniformMatrix4fv(location, false, value);
  },
  sampler2D(gl, location, _cv, value) {
    gl.uniform1i(location, value);
  },
  samplerCube(gl, location, _cv, value) {
    gl.uniform1i(location, value);
  },
  sampler2DArray(gl, location, _cv, value) {
    gl.uniform1i(location, value);
  }
};
const GLSL_TO_ARRAY_SETTERS = {
  float(gl, location, _cv, value) {
    gl.uniform1fv(location, value);
  },
  vec2(gl, location, _cv, value) {
    gl.uniform2fv(location, value);
  },
  vec3(gl, location, _cv, value) {
    gl.uniform3fv(location, value);
  },
  vec4(gl, location, _cv, value) {
    gl.uniform4fv(location, value);
  },
  int(gl, location, _cv, value) {
    gl.uniform1iv(location, value);
  },
  ivec2(gl, location, _cv, value) {
    gl.uniform2iv(location, value);
  },
  ivec3(gl, location, _cv, value) {
    gl.uniform3iv(location, value);
  },
  ivec4(gl, location, _cv, value) {
    gl.uniform4iv(location, value);
  },
  uint(gl, location, _cv, value) {
    gl.uniform1uiv(location, value);
  },
  uvec2(gl, location, _cv, value) {
    gl.uniform2uiv(location, value);
  },
  uvec3(gl, location, _cv, value) {
    gl.uniform3uiv(location, value);
  },
  uvec4(gl, location, _cv, value) {
    gl.uniform4uiv(location, value);
  },
  bool(gl, location, _cv, value) {
    gl.uniform1iv(location, value);
  },
  bvec2(gl, location, _cv, value) {
    gl.uniform2iv(location, value);
  },
  bvec3(gl, location, _cv, value) {
    gl.uniform3iv(location, value);
  },
  bvec4(gl, location, _cv, value) {
    gl.uniform4iv(location, value);
  },
  sampler2D(gl, location, _cv, value) {
    gl.uniform1iv(location, value);
  },
  samplerCube(gl, location, _cv, value) {
    gl.uniform1iv(location, value);
  },
  sampler2DArray(gl, location, _cv, value) {
    gl.uniform1iv(location, value);
  }
};
function syncUniforms(group, uniformData, ud, uv, renderer) {
  let textureCount = 0;
  let v = null;
  let cv = null;
  const gl = renderer.gl;
  for (const i in group.uniforms) {
    const data = uniformData[i];
    const uvi = uv[i];
    const udi = ud[i];
    const gu = group.uniforms[i];
    if (!data) {
      if (gu.group) {
        renderer.shader.syncUniformGroup(uvi);
      }
      continue;
    }
    if (data.type === "float" && data.size === 1) {
      if (uvi !== udi.value) {
        udi.value = uvi;
        gl.uniform1f(udi.location, uvi);
      }
    } else if ((data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray) {
      renderer.texture.bind(uvi, textureCount);
      if (udi.value !== textureCount) {
        udi.value = textureCount;
        gl.uniform1i(udi.location, textureCount);
      }
      textureCount++;
    } else if (data.type === "mat3" && data.size === 1) {
      if (gu.a !== void 0) {
        gl.uniformMatrix3fv(udi.location, false, uvi.toArray(true));
      } else {
        gl.uniformMatrix3fv(udi.location, false, uvi);
      }
    } else if (data.type === "vec2" && data.size === 1) {
      if (gu.x !== void 0) {
        cv = udi.value;
        v = uvi;
        if (cv[0] !== v.x || cv[1] !== v.y) {
          cv[0] = v.x;
          cv[1] = v.y;
          gl.uniform2f(udi.location, v.x, v.y);
        }
      } else {
        cv = udi.value;
        v = uvi;
        if (cv[0] !== v[0] || cv[1] !== v[1]) {
          cv[0] = v[0];
          cv[1] = v[1];
          gl.uniform2f(udi.location, v[0], v[1]);
        }
      }
    } else if (data.type === "vec4" && data.size === 1) {
      if (gu.width !== void 0) {
        cv = udi.value;
        v = uvi;
        if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
          cv[0] = v.x;
          cv[1] = v.y;
          cv[2] = v.width;
          cv[3] = v.height;
          gl.uniform4f(udi.location, v.x, v.y, v.width, v.height);
        }
      } else {
        cv = udi.value;
        v = uvi;
        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
          cv[0] = v[0];
          cv[1] = v[1];
          cv[2] = v[2];
          cv[3] = v[3];
          gl.uniform4f(udi.location, v[0], v[1], v[2], v[3]);
        }
      }
    } else {
      const funcArray = data.size === 1 ? GLSL_TO_SINGLE_SETTERS : GLSL_TO_ARRAY_SETTERS;
      funcArray[data.type].call(null, gl, udi.location, udi.value, uvi);
    }
  }
}


//# sourceMappingURL=syncUniforms.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/hello.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/hello.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sayHello": function() { return /* binding */ sayHello; },
/* harmony export */   "skipHello": function() { return /* binding */ skipHello; }
/* harmony export */ });
/* harmony import */ var _logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logging/deprecation.mjs */ "./node_modules/@pixi/utils/lib/logging/deprecation.mjs");


function skipHello() {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
}
function sayHello() {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_0__.deprecation)("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`);
}


//# sourceMappingURL=hello.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isWebGLSupported": function() { return /* binding */ isWebGLSupported; }
/* harmony export */ });
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings.mjs */ "./node_modules/@pixi/utils/lib/settings.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");



let supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      const contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!_pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.getWebGLRenderingContext()) {
          return false;
        }
        const canvas = _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.ADAPTER.createCanvas();
        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);
        const success = !!gl?.getContextAttributes()?.stencil;
        if (gl) {
          const loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}


//# sourceMappingURL=isWebGLSupported.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/color/hex.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/color/hex.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hex2rgb": function() { return /* binding */ hex2rgb; },
/* harmony export */   "hex2string": function() { return /* binding */ hex2string; },
/* harmony export */   "rgb2hex": function() { return /* binding */ rgb2hex; },
/* harmony export */   "string2hex": function() { return /* binding */ string2hex; }
/* harmony export */ });
/* harmony import */ var _pixi_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.mjs");
/* harmony import */ var _logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logging/deprecation.mjs */ "./node_modules/@pixi/utils/lib/logging/deprecation.mjs");



function hex2rgb(hex, out = []) {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");
  return _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(hex).toRgbArray(out);
}
function hex2string(hex) {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");
  return _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(hex).toHex();
}
function string2hex(string) {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");
  return _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(string).toNumber();
}
function rgb2hex(rgb) {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__.deprecation)("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");
  return _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(rgb).toNumber();
}


//# sourceMappingURL=hex.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/color/premultiply.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/color/premultiply.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "correctBlendMode": function() { return /* binding */ correctBlendMode; },
/* harmony export */   "premultiplyBlendMode": function() { return /* binding */ premultiplyBlendMode; },
/* harmony export */   "premultiplyRgba": function() { return /* binding */ premultiplyRgba; },
/* harmony export */   "premultiplyTint": function() { return /* binding */ premultiplyTint; },
/* harmony export */   "premultiplyTintToRgba": function() { return /* binding */ premultiplyTintToRgba; }
/* harmony export */ });
/* harmony import */ var _pixi_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/color */ "./node_modules/@pixi/color/lib/index.mjs");
/* harmony import */ var _pixi_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/constants */ "./node_modules/@pixi/constants/lib/index.mjs");
/* harmony import */ var _logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../logging/deprecation.mjs */ "./node_modules/@pixi/utils/lib/logging/deprecation.mjs");




function mapPremultipliedBlendModes() {
  const pm = [];
  const npm = [];
  for (let i = 0; i < 32; i++) {
    pm[i] = i;
    npm[i] = i;
  }
  pm[_pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.NORMAL_NPM] = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.NORMAL;
  pm[_pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.ADD_NPM] = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.ADD;
  pm[_pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.SCREEN_NPM] = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.SCREEN;
  npm[_pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.NORMAL] = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.NORMAL_NPM;
  npm[_pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.ADD] = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.ADD_NPM;
  npm[_pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.SCREEN] = _pixi_constants__WEBPACK_IMPORTED_MODULE_1__.BLEND_MODES.SCREEN_NPM;
  const array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
const premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply = true) {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);
  return _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}
function premultiplyTint(tint, alpha) {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);
  return _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(tint).toPremultiplied(alpha);
}
function premultiplyTintToRgba(tint, alpha, out, premultiply = true) {
  (0,_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_2__.deprecation)("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);
  return _pixi_color__WEBPACK_IMPORTED_MODULE_0__.Color.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));
}


//# sourceMappingURL=premultiply.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/const.mjs":
/*!************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/const.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DATA_URI": function() { return /* binding */ DATA_URI; }
/* harmony export */ });
const DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;


//# sourceMappingURL=const.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createIndicesForQuads": function() { return /* binding */ createIndicesForQuads; }
/* harmony export */ });
function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
    outBuffer[i + 0] = j + 0;
    outBuffer[i + 1] = j + 1;
    outBuffer[i + 2] = j + 2;
    outBuffer[i + 3] = j + 0;
    outBuffer[i + 4] = j + 2;
    outBuffer[i + 5] = j + 3;
  }
  return outBuffer;
}


//# sourceMappingURL=createIndicesForQuads.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/getBufferType.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/getBufferType.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getBufferType": function() { return /* binding */ getBufferType; }
/* harmony export */ });
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}


//# sourceMappingURL=getBufferType.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interleaveTypedArrays": function() { return /* binding */ interleaveTypedArrays; }
/* harmony export */ });
/* harmony import */ var _getBufferType_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBufferType.mjs */ "./node_modules/@pixi/utils/lib/data/getBufferType.mjs");


const map = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function interleaveTypedArrays(arrays, sizes) {
  let outSize = 0;
  let stride = 0;
  const views = {};
  for (let i = 0; i < arrays.length; i++) {
    stride += sizes[i];
    outSize += arrays[i].length;
  }
  const buffer = new ArrayBuffer(outSize * 4);
  let out = null;
  let littleOffset = 0;
  for (let i = 0; i < arrays.length; i++) {
    const size = sizes[i];
    const array = arrays[i];
    const type = (0,_getBufferType_mjs__WEBPACK_IMPORTED_MODULE_0__.getBufferType)(array);
    if (!views[type]) {
      views[type] = new map[type](buffer);
    }
    out = views[type];
    for (let j = 0; j < array.length; j++) {
      const indexStart = (j / size | 0) * stride + littleOffset;
      const index = j % size;
      out[indexStart + index] = array[j];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}


//# sourceMappingURL=interleaveTypedArrays.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/pow2.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/pow2.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPow2": function() { return /* binding */ isPow2; },
/* harmony export */   "log2": function() { return /* binding */ log2; },
/* harmony export */   "nextPow2": function() { return /* binding */ nextPow2; }
/* harmony export */ });
function nextPow2(v) {
  v += v === 0 ? 1 : 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}
function log2(v) {
  let r = (v > 65535 ? 1 : 0) << 4;
  v >>>= r;
  let shift = (v > 255 ? 1 : 0) << 3;
  v >>>= shift;
  r |= shift;
  shift = (v > 15 ? 1 : 0) << 2;
  v >>>= shift;
  r |= shift;
  shift = (v > 3 ? 1 : 0) << 1;
  v >>>= shift;
  r |= shift;
  return r | v >> 1;
}


//# sourceMappingURL=pow2.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/removeItems.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/removeItems.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "removeItems": function() { return /* binding */ removeItems; }
/* harmony export */ });
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}


//# sourceMappingURL=removeItems.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/sign.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/sign.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sign": function() { return /* binding */ sign; }
/* harmony export */ });
function sign(n) {
  if (n === 0)
    return 0;
  return n < 0 ? -1 : 1;
}


//# sourceMappingURL=sign.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/data/uid.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/data/uid.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uid": function() { return /* binding */ uid; }
/* harmony export */ });
let nextUid = 0;
function uid() {
  return ++nextUid;
}


//# sourceMappingURL=uid.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/index.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTextureCache": function() { return /* reexport safe */ _media_caches_mjs__WEBPACK_IMPORTED_MODULE_20__.BaseTextureCache; },
/* harmony export */   "BoundingBox": function() { return /* reexport safe */ _media_BoundingBox_mjs__WEBPACK_IMPORTED_MODULE_19__.BoundingBox; },
/* harmony export */   "CanvasRenderTarget": function() { return /* reexport safe */ _media_CanvasRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_21__.CanvasRenderTarget; },
/* harmony export */   "DATA_URI": function() { return /* reexport safe */ _const_mjs__WEBPACK_IMPORTED_MODULE_10__.DATA_URI; },
/* harmony export */   "EventEmitter": function() { return /* reexport default export from named module */ eventemitter3__WEBPACK_IMPORTED_MODULE_2__; },
/* harmony export */   "ProgramCache": function() { return /* reexport safe */ _media_caches_mjs__WEBPACK_IMPORTED_MODULE_20__.ProgramCache; },
/* harmony export */   "TextureCache": function() { return /* reexport safe */ _media_caches_mjs__WEBPACK_IMPORTED_MODULE_20__.TextureCache; },
/* harmony export */   "clearTextureCache": function() { return /* reexport safe */ _media_caches_mjs__WEBPACK_IMPORTED_MODULE_20__.clearTextureCache; },
/* harmony export */   "correctBlendMode": function() { return /* reexport safe */ _color_premultiply_mjs__WEBPACK_IMPORTED_MODULE_9__.correctBlendMode; },
/* harmony export */   "createIndicesForQuads": function() { return /* reexport safe */ _data_createIndicesForQuads_mjs__WEBPACK_IMPORTED_MODULE_11__.createIndicesForQuads; },
/* harmony export */   "decomposeDataUri": function() { return /* reexport safe */ _network_decomposeDataUri_mjs__WEBPACK_IMPORTED_MODULE_24__.decomposeDataUri; },
/* harmony export */   "deprecation": function() { return /* reexport safe */ _logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_18__.deprecation; },
/* harmony export */   "destroyTextureCache": function() { return /* reexport safe */ _media_caches_mjs__WEBPACK_IMPORTED_MODULE_20__.destroyTextureCache; },
/* harmony export */   "determineCrossOrigin": function() { return /* reexport safe */ _network_determineCrossOrigin_mjs__WEBPACK_IMPORTED_MODULE_25__.determineCrossOrigin; },
/* harmony export */   "earcut": function() { return /* reexport default export from named module */ earcut__WEBPACK_IMPORTED_MODULE_3__; },
/* harmony export */   "getBufferType": function() { return /* reexport safe */ _data_getBufferType_mjs__WEBPACK_IMPORTED_MODULE_12__.getBufferType; },
/* harmony export */   "getCanvasBoundingBox": function() { return /* reexport safe */ _media_getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_22__.getCanvasBoundingBox; },
/* harmony export */   "getResolutionOfUrl": function() { return /* reexport safe */ _network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_26__.getResolutionOfUrl; },
/* harmony export */   "hex2rgb": function() { return /* reexport safe */ _color_hex_mjs__WEBPACK_IMPORTED_MODULE_8__.hex2rgb; },
/* harmony export */   "hex2string": function() { return /* reexport safe */ _color_hex_mjs__WEBPACK_IMPORTED_MODULE_8__.hex2string; },
/* harmony export */   "interleaveTypedArrays": function() { return /* reexport safe */ _data_interleaveTypedArrays_mjs__WEBPACK_IMPORTED_MODULE_13__.interleaveTypedArrays; },
/* harmony export */   "isMobile": function() { return /* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.isMobile; },
/* harmony export */   "isPow2": function() { return /* reexport safe */ _data_pow2_mjs__WEBPACK_IMPORTED_MODULE_14__.isPow2; },
/* harmony export */   "isWebGLSupported": function() { return /* reexport safe */ _browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_7__.isWebGLSupported; },
/* harmony export */   "log2": function() { return /* reexport safe */ _data_pow2_mjs__WEBPACK_IMPORTED_MODULE_14__.log2; },
/* harmony export */   "nextPow2": function() { return /* reexport safe */ _data_pow2_mjs__WEBPACK_IMPORTED_MODULE_14__.nextPow2; },
/* harmony export */   "path": function() { return /* reexport safe */ _path_mjs__WEBPACK_IMPORTED_MODULE_5__.path; },
/* harmony export */   "premultiplyBlendMode": function() { return /* reexport safe */ _color_premultiply_mjs__WEBPACK_IMPORTED_MODULE_9__.premultiplyBlendMode; },
/* harmony export */   "premultiplyRgba": function() { return /* reexport safe */ _color_premultiply_mjs__WEBPACK_IMPORTED_MODULE_9__.premultiplyRgba; },
/* harmony export */   "premultiplyTint": function() { return /* reexport safe */ _color_premultiply_mjs__WEBPACK_IMPORTED_MODULE_9__.premultiplyTint; },
/* harmony export */   "premultiplyTintToRgba": function() { return /* reexport safe */ _color_premultiply_mjs__WEBPACK_IMPORTED_MODULE_9__.premultiplyTintToRgba; },
/* harmony export */   "removeItems": function() { return /* reexport safe */ _data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_15__.removeItems; },
/* harmony export */   "rgb2hex": function() { return /* reexport safe */ _color_hex_mjs__WEBPACK_IMPORTED_MODULE_8__.rgb2hex; },
/* harmony export */   "sayHello": function() { return /* reexport safe */ _browser_hello_mjs__WEBPACK_IMPORTED_MODULE_6__.sayHello; },
/* harmony export */   "sign": function() { return /* reexport safe */ _data_sign_mjs__WEBPACK_IMPORTED_MODULE_16__.sign; },
/* harmony export */   "skipHello": function() { return /* reexport safe */ _browser_hello_mjs__WEBPACK_IMPORTED_MODULE_6__.skipHello; },
/* harmony export */   "string2hex": function() { return /* reexport safe */ _color_hex_mjs__WEBPACK_IMPORTED_MODULE_8__.string2hex; },
/* harmony export */   "trimCanvas": function() { return /* reexport safe */ _media_trimCanvas_mjs__WEBPACK_IMPORTED_MODULE_23__.trimCanvas; },
/* harmony export */   "uid": function() { return /* reexport safe */ _data_uid_mjs__WEBPACK_IMPORTED_MODULE_17__.uid; },
/* harmony export */   "url": function() { return /* reexport safe */ _url_mjs__WEBPACK_IMPORTED_MODULE_4__.url; }
/* harmony export */ });
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.mjs */ "./node_modules/@pixi/utils/lib/settings.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
/* harmony import */ var _url_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url.mjs */ "./node_modules/@pixi/utils/lib/url.mjs");
/* harmony import */ var _path_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path.mjs */ "./node_modules/@pixi/utils/lib/path.mjs");
/* harmony import */ var _browser_hello_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./browser/hello.mjs */ "./node_modules/@pixi/utils/lib/browser/hello.mjs");
/* harmony import */ var _browser_isWebGLSupported_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./browser/isWebGLSupported.mjs */ "./node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs");
/* harmony import */ var _color_hex_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./color/hex.mjs */ "./node_modules/@pixi/utils/lib/color/hex.mjs");
/* harmony import */ var _color_premultiply_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./color/premultiply.mjs */ "./node_modules/@pixi/utils/lib/color/premultiply.mjs");
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./const.mjs */ "./node_modules/@pixi/utils/lib/const.mjs");
/* harmony import */ var _data_createIndicesForQuads_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./data/createIndicesForQuads.mjs */ "./node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs");
/* harmony import */ var _data_getBufferType_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./data/getBufferType.mjs */ "./node_modules/@pixi/utils/lib/data/getBufferType.mjs");
/* harmony import */ var _data_interleaveTypedArrays_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./data/interleaveTypedArrays.mjs */ "./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs");
/* harmony import */ var _data_pow2_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./data/pow2.mjs */ "./node_modules/@pixi/utils/lib/data/pow2.mjs");
/* harmony import */ var _data_removeItems_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./data/removeItems.mjs */ "./node_modules/@pixi/utils/lib/data/removeItems.mjs");
/* harmony import */ var _data_sign_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./data/sign.mjs */ "./node_modules/@pixi/utils/lib/data/sign.mjs");
/* harmony import */ var _data_uid_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./data/uid.mjs */ "./node_modules/@pixi/utils/lib/data/uid.mjs");
/* harmony import */ var _logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./logging/deprecation.mjs */ "./node_modules/@pixi/utils/lib/logging/deprecation.mjs");
/* harmony import */ var _media_BoundingBox_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./media/BoundingBox.mjs */ "./node_modules/@pixi/utils/lib/media/BoundingBox.mjs");
/* harmony import */ var _media_caches_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./media/caches.mjs */ "./node_modules/@pixi/utils/lib/media/caches.mjs");
/* harmony import */ var _media_CanvasRenderTarget_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./media/CanvasRenderTarget.mjs */ "./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs");
/* harmony import */ var _media_getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./media/getCanvasBoundingBox.mjs */ "./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs");
/* harmony import */ var _media_trimCanvas_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./media/trimCanvas.mjs */ "./node_modules/@pixi/utils/lib/media/trimCanvas.mjs");
/* harmony import */ var _network_decomposeDataUri_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./network/decomposeDataUri.mjs */ "./node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs");
/* harmony import */ var _network_determineCrossOrigin_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./network/determineCrossOrigin.mjs */ "./node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs");
/* harmony import */ var _network_getResolutionOfUrl_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./network/getResolutionOfUrl.mjs */ "./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs");
/* harmony import */ var _types_index_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./types/index.mjs */ "./node_modules/@pixi/utils/lib/types/index.mjs");




























//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/logging/deprecation.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/logging/deprecation.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deprecation": function() { return /* binding */ deprecation; }
/* harmony export */ });
const warnings = {};
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}
Deprecated since v${version}`);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}


//# sourceMappingURL=deprecation.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/BoundingBox.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/BoundingBox.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BoundingBox": function() { return /* binding */ BoundingBox; }
/* harmony export */ });
const _BoundingBox = class {
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
let BoundingBox = _BoundingBox;
BoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);


//# sourceMappingURL=BoundingBox.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CanvasRenderTarget": function() { return /* binding */ CanvasRenderTarget; }
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");


class CanvasRenderTarget {
  constructor(width, height, resolution) {
    this._canvas = _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.createCanvas();
    this._context = this._canvas.getContext("2d");
    this.resolution = resolution || _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.RESOLUTION;
    this.resize(width, height);
  }
  clear() {
    this._checkDestroyed();
    this._context.setTransform(1, 0, 0, 1, 0, 0);
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
  }
  resize(desiredWidth, desiredHeight) {
    this._checkDestroyed();
    this._canvas.width = Math.round(desiredWidth * this.resolution);
    this._canvas.height = Math.round(desiredHeight * this.resolution);
  }
  destroy() {
    this._context = null;
    this._canvas = null;
  }
  get width() {
    this._checkDestroyed();
    return this._canvas.width;
  }
  set width(val) {
    this._checkDestroyed();
    this._canvas.width = Math.round(val);
  }
  get height() {
    this._checkDestroyed();
    return this._canvas.height;
  }
  set height(val) {
    this._checkDestroyed();
    this._canvas.height = Math.round(val);
  }
  get canvas() {
    this._checkDestroyed();
    return this._canvas;
  }
  get context() {
    this._checkDestroyed();
    return this._context;
  }
  _checkDestroyed() {
    if (this._canvas === null) {
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
    }
  }
}


//# sourceMappingURL=CanvasRenderTarget.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/caches.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/caches.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTextureCache": function() { return /* binding */ BaseTextureCache; },
/* harmony export */   "ProgramCache": function() { return /* binding */ ProgramCache; },
/* harmony export */   "TextureCache": function() { return /* binding */ TextureCache; },
/* harmony export */   "clearTextureCache": function() { return /* binding */ clearTextureCache; },
/* harmony export */   "destroyTextureCache": function() { return /* binding */ destroyTextureCache; }
/* harmony export */ });
const ProgramCache = {};
const TextureCache = /* @__PURE__ */ Object.create(null);
const BaseTextureCache = /* @__PURE__ */ Object.create(null);
function destroyTextureCache() {
  let key;
  for (key in TextureCache) {
    TextureCache[key].destroy();
  }
  for (key in BaseTextureCache) {
    BaseTextureCache[key].destroy();
  }
}
function clearTextureCache() {
  let key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}


//# sourceMappingURL=caches.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCanvasBoundingBox": function() { return /* binding */ getCanvasBoundingBox; }
/* harmony export */ });
/* harmony import */ var _BoundingBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoundingBox.mjs */ "./node_modules/@pixi/utils/lib/media/BoundingBox.mjs");


function checkRow(data, width, y) {
  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x, top, bottom) {
  const stride = 4 * width;
  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas) {
  const { width, height } = canvas;
  const context = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return _BoundingBox_mjs__WEBPACK_IMPORTED_MODULE_0__.BoundingBox.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new _BoundingBox_mjs__WEBPACK_IMPORTED_MODULE_0__.BoundingBox(left, top, right, bottom);
}


//# sourceMappingURL=getCanvasBoundingBox.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/media/trimCanvas.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/media/trimCanvas.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trimCanvas": function() { return /* binding */ trimCanvas; }
/* harmony export */ });
/* harmony import */ var _getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCanvasBoundingBox.mjs */ "./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs");


function trimCanvas(canvas) {
  const boundingBox = (0,_getCanvasBoundingBox_mjs__WEBPACK_IMPORTED_MODULE_0__.getCanvasBoundingBox)(canvas);
  const { width, height } = boundingBox;
  let data = null;
  if (!boundingBox.isEmpty()) {
    const context = canvas.getContext("2d");
    if (context === null) {
      throw new TypeError("Failed to get canvas 2D context");
    }
    data = context.getImageData(boundingBox.left, boundingBox.top, width, height);
  }
  return { width, height, data };
}


//# sourceMappingURL=trimCanvas.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decomposeDataUri": function() { return /* binding */ decomposeDataUri; }
/* harmony export */ });
/* harmony import */ var _const_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../const.mjs */ "./node_modules/@pixi/utils/lib/const.mjs");


function decomposeDataUri(dataUri) {
  const dataUriMatch = _const_mjs__WEBPACK_IMPORTED_MODULE_0__.DATA_URI.exec(dataUri);
  if (dataUriMatch) {
    return {
      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,
      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,
      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,
      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,
      data: dataUriMatch[5]
    };
  }
  return void 0;
}


//# sourceMappingURL=decomposeDataUri.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "determineCrossOrigin": function() { return /* binding */ determineCrossOrigin; }
/* harmony export */ });
/* harmony import */ var _url_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../url.mjs */ "./node_modules/@pixi/utils/lib/url.mjs");


let tempAnchor;
function determineCrossOrigin(url$1, loc = globalThis.location) {
  if (url$1.startsWith("data:")) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor) {
    tempAnchor = document.createElement("a");
  }
  tempAnchor.href = url$1;
  const parsedUrl = _url_mjs__WEBPACK_IMPORTED_MODULE_0__.url.parse(tempAnchor.href);
  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}


//# sourceMappingURL=determineCrossOrigin.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getResolutionOfUrl": function() { return /* binding */ getResolutionOfUrl; }
/* harmony export */ });
/* harmony import */ var _settings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settings.mjs */ "./node_modules/@pixi/utils/lib/settings.mjs");
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");



function getResolutionOfUrl(url, defaultValue = 1) {
  const resolution = _pixi_settings__WEBPACK_IMPORTED_MODULE_1__.settings.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue;
}


//# sourceMappingURL=getResolutionOfUrl.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/path.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/path.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "path": function() { return /* binding */ path; }
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");


function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code = path2.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i)}`;
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  hasProtocol(path2) {
    return /^[^/:]+:\//.test(this.toPosix(path2));
  },
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let protocol = "";
    const isFile = /^file:\/\/\//.exec(path2);
    const isHttp = /^[^/:]+:\/\//.exec(path2);
    const isWindows = /^[^/:]+:\//.exec(path2);
    if (isFile || isHttp || isWindows) {
      const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];
      protocol = arr;
      path2 = path2.slice(arr.length);
    }
    return protocol;
  },
  toAbsolute(url, customBaseUrl, customRootUrl) {
    if (this.isDataUrl(url))
      return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.ADAPTER.getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    assertPath(url);
    url = this.toPosix(url);
    if (url.startsWith("/")) {
      return path.join(rootUrl, url.slice(1));
    }
    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
    return absolutePath;
  },
  normalize(path2) {
    path2 = this.toPosix(path2);
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2, false);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol + path2;
  },
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i - 1] ?? "";
          if (this.extname(prevArg)) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; i >= 1; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/"))
      root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      if (index !== -1) {
        root = path2.slice(0, index);
      } else
        root = path2;
      if (!root.endsWith("/"))
        root += "/";
    }
    return root;
  },
  basename(path2, ext) {
    assertPath(path2);
    if (ext)
      assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i = path2.length - 1; i >= 0; --i) {
      if (path2.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    const protocol = "";
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    if (protocol)
      ret.dir = protocol + ret.dir;
    return ret;
  },
  sep: "/",
  delimiter: ":"
};


//# sourceMappingURL=path.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/settings.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/settings.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "settings": function() { return /* reexport safe */ _pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings; }
/* harmony export */ });
/* harmony import */ var _pixi_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/settings */ "./node_modules/@pixi/settings/lib/index.mjs");



_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.RETINA_PREFIX = /@([0-9\.]+)x/;
_pixi_settings__WEBPACK_IMPORTED_MODULE_0__.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
//# sourceMappingURL=settings.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/types/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@pixi/utils/lib/types/index.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/@pixi/utils/lib/url.mjs":
/*!**********************************************!*\
  !*** ./node_modules/@pixi/utils/lib/url.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "url": function() { return /* binding */ url; }
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "./node_modules/url/url.js");


const url = {
  parse: url__WEBPACK_IMPORTED_MODULE_0__.parse,
  format: url__WEBPACK_IMPORTED_MODULE_0__.format,
  resolve: url__WEBPACK_IMPORTED_MODULE_0__.resolve
};


//# sourceMappingURL=url.mjs.map


/***/ }),

/***/ "./node_modules/colord/index.mjs":
/*!***************************************!*\
  !*** ./node_modules/colord/index.mjs ***!
  \***************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Colord": function() { return /* binding */ j; },
/* harmony export */   "colord": function() { return /* binding */ w; },
/* harmony export */   "extend": function() { return /* binding */ k; },
/* harmony export */   "getFormat": function() { return /* binding */ I; },
/* harmony export */   "random": function() { return /* binding */ E; }
/* harmony export */ });
var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};


/***/ }),

/***/ "./node_modules/colord/plugins/names.mjs":
/*!***********************************************!*\
  !*** ./node_modules/colord/plugins/names.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}


/***/ }),

/***/ "./node_modules/pixi-spine/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pixi-spine/lib/index.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AttachmentType": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.AttachmentType; },
/* harmony export */   "BinaryInput": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.BinaryInput; },
/* harmony export */   "Color": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Color; },
/* harmony export */   "DebugUtils": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.DebugUtils; },
/* harmony export */   "IntSet": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.IntSet; },
/* harmony export */   "Interpolation": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Interpolation; },
/* harmony export */   "MathUtils": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MathUtils; },
/* harmony export */   "MixBlend": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixBlend; },
/* harmony export */   "MixDirection": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.MixDirection; },
/* harmony export */   "Pool": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Pool; },
/* harmony export */   "PositionMode": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.PositionMode; },
/* harmony export */   "Pow": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Pow; },
/* harmony export */   "PowOut": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.PowOut; },
/* harmony export */   "RotateMode": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.RotateMode; },
/* harmony export */   "SkeletonBounds": function() { return /* reexport safe */ _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_2__.SkeletonBounds; },
/* harmony export */   "SkeletonBoundsBase": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.SkeletonBoundsBase; },
/* harmony export */   "Spine": function() { return /* reexport safe */ _pixi_spine_loader_uni__WEBPACK_IMPORTED_MODULE_0__.Spine; },
/* harmony export */   "SpineBase": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.SpineBase; },
/* harmony export */   "SpineDebugRenderer": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.SpineDebugRenderer; },
/* harmony export */   "SpineMesh": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.SpineMesh; },
/* harmony export */   "SpineSprite": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.SpineSprite; },
/* harmony export */   "StringSet": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.StringSet; },
/* harmony export */   "TextureAtlas": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TextureAtlas; },
/* harmony export */   "TextureAtlasPage": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TextureAtlasPage; },
/* harmony export */   "TextureAtlasRegion": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TextureAtlasRegion; },
/* harmony export */   "TextureFilter": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TextureFilter; },
/* harmony export */   "TextureRegion": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TextureRegion; },
/* harmony export */   "TextureWrap": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TextureWrap; },
/* harmony export */   "TimeKeeper": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TimeKeeper; },
/* harmony export */   "TransformMode": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.TransformMode; },
/* harmony export */   "Utils": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Utils; },
/* harmony export */   "Vector2": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.Vector2; },
/* harmony export */   "WindowedMean": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.WindowedMean; },
/* harmony export */   "filterFromString": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.filterFromString; },
/* harmony export */   "settings": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.settings; },
/* harmony export */   "wrapFromString": function() { return /* reexport safe */ _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__.wrapFromString; }
/* harmony export */ });
/* harmony import */ var _pixi_spine_loader_uni__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi-spine/loader-uni */ "./node_modules/@pixi-spine/loader-uni/lib/index.mjs");
/* harmony import */ var _pixi_spine_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi-spine/base */ "./node_modules/@pixi-spine/base/lib/index.mjs");
/* harmony import */ var _pixi_spine_runtime_4_1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi-spine/runtime-4.1 */ "./node_modules/@pixi-spine/runtime-4.1/lib/index.mjs");



//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/filters.mjs":
/*!**********************************************!*\
  !*** ./node_modules/pixi.js/lib/filters.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "filters": function() { return /* binding */ filters; }
/* harmony export */ });
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_filter_alpha__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/filter-alpha */ "./node_modules/@pixi/filter-alpha/lib/index.mjs");
/* harmony import */ var _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/filter-blur */ "./node_modules/@pixi/filter-blur/lib/index.mjs");
/* harmony import */ var _pixi_filter_color_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/filter-color-matrix */ "./node_modules/@pixi/filter-color-matrix/lib/index.mjs");
/* harmony import */ var _pixi_filter_displacement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/filter-displacement */ "./node_modules/@pixi/filter-displacement/lib/index.mjs");
/* harmony import */ var _pixi_filter_fxaa__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/filter-fxaa */ "./node_modules/@pixi/filter-fxaa/lib/index.mjs");
/* harmony import */ var _pixi_filter_noise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pixi/filter-noise */ "./node_modules/@pixi/filter-noise/lib/index.mjs");








const filters = {
  AlphaFilter: _pixi_filter_alpha__WEBPACK_IMPORTED_MODULE_1__.AlphaFilter,
  BlurFilter: _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_2__.BlurFilter,
  BlurFilterPass: _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_2__.BlurFilterPass,
  ColorMatrixFilter: _pixi_filter_color_matrix__WEBPACK_IMPORTED_MODULE_3__.ColorMatrixFilter,
  DisplacementFilter: _pixi_filter_displacement__WEBPACK_IMPORTED_MODULE_4__.DisplacementFilter,
  FXAAFilter: _pixi_filter_fxaa__WEBPACK_IMPORTED_MODULE_5__.FXAAFilter,
  NoiseFilter: _pixi_filter_noise__WEBPACK_IMPORTED_MODULE_6__.NoiseFilter
};
Object.entries(filters).forEach(([key, FilterClass]) => {
  Object.defineProperty(filters, key, {
    get() {
      _pixi_core__WEBPACK_IMPORTED_MODULE_0__.utils.deprecation("7.1.0", `filters.${key} has moved to ${key}`);
      return FilterClass;
    }
  });
});


//# sourceMappingURL=filters.mjs.map


/***/ }),

/***/ "./node_modules/pixi.js/lib/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/pixi.js/lib/index.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ALPHA_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ALPHA_MODES; },
/* harmony export */   "AbstractMultiResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.AbstractMultiResource; },
/* harmony export */   "AccessibilityManager": function() { return /* reexport safe */ _pixi_accessibility__WEBPACK_IMPORTED_MODULE_4__.AccessibilityManager; },
/* harmony export */   "AlphaFilter": function() { return /* reexport safe */ _pixi_filter_alpha__WEBPACK_IMPORTED_MODULE_12__.AlphaFilter; },
/* harmony export */   "AnimatedSprite": function() { return /* reexport safe */ _pixi_sprite_animated__WEBPACK_IMPORTED_MODULE_24__.AnimatedSprite; },
/* harmony export */   "Application": function() { return /* reexport safe */ _pixi_app__WEBPACK_IMPORTED_MODULE_5__.Application; },
/* harmony export */   "ArrayResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ArrayResource; },
/* harmony export */   "Assets": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.Assets; },
/* harmony export */   "AssetsClass": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.AssetsClass; },
/* harmony export */   "Attribute": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Attribute; },
/* harmony export */   "BLEND_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BLEND_MODES; },
/* harmony export */   "BUFFER_BITS": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BUFFER_BITS; },
/* harmony export */   "BUFFER_TYPE": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BUFFER_TYPE; },
/* harmony export */   "BackgroundSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BackgroundSystem; },
/* harmony export */   "BaseImageResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BaseImageResource; },
/* harmony export */   "BasePrepare": function() { return /* reexport safe */ _pixi_prepare__WEBPACK_IMPORTED_MODULE_22__.BasePrepare; },
/* harmony export */   "BaseRenderTexture": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BaseRenderTexture; },
/* harmony export */   "BaseTexture": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BaseTexture; },
/* harmony export */   "BatchDrawCall": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BatchDrawCall; },
/* harmony export */   "BatchGeometry": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BatchGeometry; },
/* harmony export */   "BatchRenderer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BatchRenderer; },
/* harmony export */   "BatchShaderGenerator": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BatchShaderGenerator; },
/* harmony export */   "BatchSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BatchSystem; },
/* harmony export */   "BatchTextureArray": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BatchTextureArray; },
/* harmony export */   "BitmapFont": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.BitmapFont; },
/* harmony export */   "BitmapFontData": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.BitmapFontData; },
/* harmony export */   "BitmapText": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.BitmapText; },
/* harmony export */   "BlobResource": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.BlobResource; },
/* harmony export */   "BlurFilter": function() { return /* reexport safe */ _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_13__.BlurFilter; },
/* harmony export */   "BlurFilterPass": function() { return /* reexport safe */ _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_13__.BlurFilterPass; },
/* harmony export */   "Bounds": function() { return /* reexport safe */ _pixi_display__WEBPACK_IMPORTED_MODULE_9__.Bounds; },
/* harmony export */   "BrowserAdapter": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BrowserAdapter; },
/* harmony export */   "Buffer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Buffer; },
/* harmony export */   "BufferResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BufferResource; },
/* harmony export */   "BufferSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.BufferSystem; },
/* harmony export */   "CLEAR_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.CLEAR_MODES; },
/* harmony export */   "COLOR_MASK_BITS": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.COLOR_MASK_BITS; },
/* harmony export */   "Cache": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.Cache; },
/* harmony export */   "CanvasResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.CanvasResource; },
/* harmony export */   "Circle": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Circle; },
/* harmony export */   "Color": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Color; },
/* harmony export */   "ColorMatrixFilter": function() { return /* reexport safe */ _pixi_filter_color_matrix__WEBPACK_IMPORTED_MODULE_14__.ColorMatrixFilter; },
/* harmony export */   "CompressedTextureResource": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.CompressedTextureResource; },
/* harmony export */   "Container": function() { return /* reexport safe */ _pixi_display__WEBPACK_IMPORTED_MODULE_9__.Container; },
/* harmony export */   "ContextSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ContextSystem; },
/* harmony export */   "CountLimiter": function() { return /* reexport safe */ _pixi_prepare__WEBPACK_IMPORTED_MODULE_22__.CountLimiter; },
/* harmony export */   "CubeResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.CubeResource; },
/* harmony export */   "DEG_TO_RAD": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.DEG_TO_RAD; },
/* harmony export */   "DRAW_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.DRAW_MODES; },
/* harmony export */   "DisplacementFilter": function() { return /* reexport safe */ _pixi_filter_displacement__WEBPACK_IMPORTED_MODULE_15__.DisplacementFilter; },
/* harmony export */   "DisplayObject": function() { return /* reexport safe */ _pixi_display__WEBPACK_IMPORTED_MODULE_9__.DisplayObject; },
/* harmony export */   "ENV": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ENV; },
/* harmony export */   "Ellipse": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Ellipse; },
/* harmony export */   "EventBoundary": function() { return /* reexport safe */ _pixi_events__WEBPACK_IMPORTED_MODULE_10__.EventBoundary; },
/* harmony export */   "EventSystem": function() { return /* reexport safe */ _pixi_events__WEBPACK_IMPORTED_MODULE_10__.EventSystem; },
/* harmony export */   "ExtensionType": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ExtensionType; },
/* harmony export */   "Extract": function() { return /* reexport safe */ _pixi_extract__WEBPACK_IMPORTED_MODULE_11__.Extract; },
/* harmony export */   "FORMATS": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.FORMATS; },
/* harmony export */   "FORMATS_TO_COMPONENTS": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.FORMATS_TO_COMPONENTS; },
/* harmony export */   "FXAAFilter": function() { return /* reexport safe */ _pixi_filter_fxaa__WEBPACK_IMPORTED_MODULE_16__.FXAAFilter; },
/* harmony export */   "FederatedDisplayObject": function() { return /* reexport safe */ _pixi_events__WEBPACK_IMPORTED_MODULE_10__.FederatedDisplayObject; },
/* harmony export */   "FederatedEvent": function() { return /* reexport safe */ _pixi_events__WEBPACK_IMPORTED_MODULE_10__.FederatedEvent; },
/* harmony export */   "FederatedMouseEvent": function() { return /* reexport safe */ _pixi_events__WEBPACK_IMPORTED_MODULE_10__.FederatedMouseEvent; },
/* harmony export */   "FederatedPointerEvent": function() { return /* reexport safe */ _pixi_events__WEBPACK_IMPORTED_MODULE_10__.FederatedPointerEvent; },
/* harmony export */   "FederatedWheelEvent": function() { return /* reexport safe */ _pixi_events__WEBPACK_IMPORTED_MODULE_10__.FederatedWheelEvent; },
/* harmony export */   "FillStyle": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.FillStyle; },
/* harmony export */   "Filter": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Filter; },
/* harmony export */   "FilterState": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.FilterState; },
/* harmony export */   "FilterSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.FilterSystem; },
/* harmony export */   "Framebuffer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Framebuffer; },
/* harmony export */   "FramebufferSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.FramebufferSystem; },
/* harmony export */   "GC_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.GC_MODES; },
/* harmony export */   "GLFramebuffer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.GLFramebuffer; },
/* harmony export */   "GLProgram": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.GLProgram; },
/* harmony export */   "GLTexture": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.GLTexture; },
/* harmony export */   "GRAPHICS_CURVES": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.GRAPHICS_CURVES; },
/* harmony export */   "GenerateTextureSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.GenerateTextureSystem; },
/* harmony export */   "Geometry": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Geometry; },
/* harmony export */   "GeometrySystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.GeometrySystem; },
/* harmony export */   "Graphics": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.Graphics; },
/* harmony export */   "GraphicsData": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.GraphicsData; },
/* harmony export */   "GraphicsGeometry": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.GraphicsGeometry; },
/* harmony export */   "HTMLText": function() { return /* reexport safe */ _pixi_text_html__WEBPACK_IMPORTED_MODULE_29__.HTMLText; },
/* harmony export */   "HTMLTextStyle": function() { return /* reexport safe */ _pixi_text_html__WEBPACK_IMPORTED_MODULE_29__.HTMLTextStyle; },
/* harmony export */   "IGLUniformData": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.IGLUniformData; },
/* harmony export */   "INSTALLED": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.INSTALLED; },
/* harmony export */   "INTERNAL_FORMATS": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.INTERNAL_FORMATS; },
/* harmony export */   "INTERNAL_FORMAT_TO_BYTES_PER_PIXEL": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL; },
/* harmony export */   "ImageBitmapResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ImageBitmapResource; },
/* harmony export */   "ImageResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ImageResource; },
/* harmony export */   "LINE_CAP": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.LINE_CAP; },
/* harmony export */   "LINE_JOIN": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.LINE_JOIN; },
/* harmony export */   "LineStyle": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.LineStyle; },
/* harmony export */   "LoaderParserPriority": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.LoaderParserPriority; },
/* harmony export */   "MASK_TYPES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.MASK_TYPES; },
/* harmony export */   "MIPMAP_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.MIPMAP_MODES; },
/* harmony export */   "MSAA_QUALITY": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.MSAA_QUALITY; },
/* harmony export */   "MaskData": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.MaskData; },
/* harmony export */   "MaskSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.MaskSystem; },
/* harmony export */   "Matrix": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Matrix; },
/* harmony export */   "Mesh": function() { return /* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_19__.Mesh; },
/* harmony export */   "MeshBatchUvs": function() { return /* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_19__.MeshBatchUvs; },
/* harmony export */   "MeshGeometry": function() { return /* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_19__.MeshGeometry; },
/* harmony export */   "MeshMaterial": function() { return /* reexport safe */ _pixi_mesh__WEBPACK_IMPORTED_MODULE_19__.MeshMaterial; },
/* harmony export */   "MultisampleSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.MultisampleSystem; },
/* harmony export */   "NineSlicePlane": function() { return /* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_20__.NineSlicePlane; },
/* harmony export */   "NoiseFilter": function() { return /* reexport safe */ _pixi_filter_noise__WEBPACK_IMPORTED_MODULE_17__.NoiseFilter; },
/* harmony export */   "ObjectRenderer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ObjectRenderer; },
/* harmony export */   "ObjectRendererSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ObjectRendererSystem; },
/* harmony export */   "ObservablePoint": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ObservablePoint; },
/* harmony export */   "PI_2": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.PI_2; },
/* harmony export */   "PRECISION": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.PRECISION; },
/* harmony export */   "ParticleContainer": function() { return /* reexport safe */ _pixi_particle_container__WEBPACK_IMPORTED_MODULE_21__.ParticleContainer; },
/* harmony export */   "ParticleRenderer": function() { return /* reexport safe */ _pixi_particle_container__WEBPACK_IMPORTED_MODULE_21__.ParticleRenderer; },
/* harmony export */   "PlaneGeometry": function() { return /* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_20__.PlaneGeometry; },
/* harmony export */   "PluginSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.PluginSystem; },
/* harmony export */   "Point": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Point; },
/* harmony export */   "Polygon": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Polygon; },
/* harmony export */   "Prepare": function() { return /* reexport safe */ _pixi_prepare__WEBPACK_IMPORTED_MODULE_22__.Prepare; },
/* harmony export */   "Program": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Program; },
/* harmony export */   "ProjectionSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ProjectionSystem; },
/* harmony export */   "Quad": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Quad; },
/* harmony export */   "QuadUv": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.QuadUv; },
/* harmony export */   "RAD_TO_DEG": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.RAD_TO_DEG; },
/* harmony export */   "RENDERER_TYPE": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.RENDERER_TYPE; },
/* harmony export */   "Rectangle": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Rectangle; },
/* harmony export */   "RenderTexture": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.RenderTexture; },
/* harmony export */   "RenderTexturePool": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.RenderTexturePool; },
/* harmony export */   "RenderTextureSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.RenderTextureSystem; },
/* harmony export */   "Renderer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Renderer; },
/* harmony export */   "ResizePlugin": function() { return /* reexport safe */ _pixi_app__WEBPACK_IMPORTED_MODULE_5__.ResizePlugin; },
/* harmony export */   "Resource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Resource; },
/* harmony export */   "RopeGeometry": function() { return /* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_20__.RopeGeometry; },
/* harmony export */   "RoundedRectangle": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.RoundedRectangle; },
/* harmony export */   "Runner": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Runner; },
/* harmony export */   "SAMPLER_TYPES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.SAMPLER_TYPES; },
/* harmony export */   "SCALE_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.SCALE_MODES; },
/* harmony export */   "SHAPES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.SHAPES; },
/* harmony export */   "SVGResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.SVGResource; },
/* harmony export */   "ScissorSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ScissorSystem; },
/* harmony export */   "Shader": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Shader; },
/* harmony export */   "ShaderSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ShaderSystem; },
/* harmony export */   "SimpleMesh": function() { return /* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_20__.SimpleMesh; },
/* harmony export */   "SimplePlane": function() { return /* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_20__.SimplePlane; },
/* harmony export */   "SimpleRope": function() { return /* reexport safe */ _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_20__.SimpleRope; },
/* harmony export */   "Sprite": function() { return /* reexport safe */ _pixi_sprite__WEBPACK_IMPORTED_MODULE_23__.Sprite; },
/* harmony export */   "SpriteMaskFilter": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.SpriteMaskFilter; },
/* harmony export */   "Spritesheet": function() { return /* reexport safe */ _pixi_spritesheet__WEBPACK_IMPORTED_MODULE_26__.Spritesheet; },
/* harmony export */   "StartupSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.StartupSystem; },
/* harmony export */   "State": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.State; },
/* harmony export */   "StateSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.StateSystem; },
/* harmony export */   "StencilSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.StencilSystem; },
/* harmony export */   "SystemManager": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.SystemManager; },
/* harmony export */   "TARGETS": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TARGETS; },
/* harmony export */   "TEXT_GRADIENT": function() { return /* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_27__.TEXT_GRADIENT; },
/* harmony export */   "TYPES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TYPES; },
/* harmony export */   "TYPES_TO_BYTES_PER_COMPONENT": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.TYPES_TO_BYTES_PER_COMPONENT; },
/* harmony export */   "TYPES_TO_BYTES_PER_PIXEL": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.TYPES_TO_BYTES_PER_PIXEL; },
/* harmony export */   "TemporaryDisplayObject": function() { return /* reexport safe */ _pixi_display__WEBPACK_IMPORTED_MODULE_9__.TemporaryDisplayObject; },
/* harmony export */   "Text": function() { return /* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_27__.Text; },
/* harmony export */   "TextFormat": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.TextFormat; },
/* harmony export */   "TextMetrics": function() { return /* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_27__.TextMetrics; },
/* harmony export */   "TextStyle": function() { return /* reexport safe */ _pixi_text__WEBPACK_IMPORTED_MODULE_27__.TextStyle; },
/* harmony export */   "Texture": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Texture; },
/* harmony export */   "TextureGCSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TextureGCSystem; },
/* harmony export */   "TextureMatrix": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TextureMatrix; },
/* harmony export */   "TextureSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TextureSystem; },
/* harmony export */   "TextureUvs": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TextureUvs; },
/* harmony export */   "Ticker": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Ticker; },
/* harmony export */   "TickerPlugin": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TickerPlugin; },
/* harmony export */   "TilingSprite": function() { return /* reexport safe */ _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_25__.TilingSprite; },
/* harmony export */   "TilingSpriteRenderer": function() { return /* reexport safe */ _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_25__.TilingSpriteRenderer; },
/* harmony export */   "TimeLimiter": function() { return /* reexport safe */ _pixi_prepare__WEBPACK_IMPORTED_MODULE_22__.TimeLimiter; },
/* harmony export */   "Transform": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.Transform; },
/* harmony export */   "TransformFeedback": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TransformFeedback; },
/* harmony export */   "TransformFeedbackSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.TransformFeedbackSystem; },
/* harmony export */   "UPDATE_PRIORITY": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.UPDATE_PRIORITY; },
/* harmony export */   "UniformGroup": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.UniformGroup; },
/* harmony export */   "VERSION": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.VERSION; },
/* harmony export */   "VideoResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.VideoResource; },
/* harmony export */   "ViewSystem": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ViewSystem; },
/* harmony export */   "ViewableBuffer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.ViewableBuffer; },
/* harmony export */   "WRAP_MODES": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.WRAP_MODES; },
/* harmony export */   "XMLFormat": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.XMLFormat; },
/* harmony export */   "XMLStringFormat": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.XMLStringFormat; },
/* harmony export */   "accessibleTarget": function() { return /* reexport safe */ _pixi_accessibility__WEBPACK_IMPORTED_MODULE_4__.accessibleTarget; },
/* harmony export */   "autoDetectFormat": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.autoDetectFormat; },
/* harmony export */   "autoDetectRenderer": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.autoDetectRenderer; },
/* harmony export */   "autoDetectResource": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.autoDetectResource; },
/* harmony export */   "cacheTextureArray": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.cacheTextureArray; },
/* harmony export */   "checkDataUrl": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.checkDataUrl; },
/* harmony export */   "checkExtension": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.checkExtension; },
/* harmony export */   "checkMaxIfStatementsInShader": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.checkMaxIfStatementsInShader; },
/* harmony export */   "convertToList": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.convertToList; },
/* harmony export */   "copySearchParams": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.copySearchParams; },
/* harmony export */   "createStringVariations": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.createStringVariations; },
/* harmony export */   "createTexture": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.createTexture; },
/* harmony export */   "createUBOElements": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.createUBOElements; },
/* harmony export */   "curves": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.curves; },
/* harmony export */   "defaultFilterVertex": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.defaultFilterVertex; },
/* harmony export */   "defaultVertex": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.defaultVertex; },
/* harmony export */   "detectAvif": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.detectAvif; },
/* harmony export */   "detectCompressedTextures": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.detectCompressedTextures; },
/* harmony export */   "detectDefaults": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.detectDefaults; },
/* harmony export */   "detectWebp": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.detectWebp; },
/* harmony export */   "extensions": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.extensions; },
/* harmony export */   "filters": function() { return /* reexport safe */ _filters_mjs__WEBPACK_IMPORTED_MODULE_3__.filters; },
/* harmony export */   "generateProgram": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.generateProgram; },
/* harmony export */   "generateUniformBufferSync": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.generateUniformBufferSync; },
/* harmony export */   "getFontFamilyName": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.getFontFamilyName; },
/* harmony export */   "getTestContext": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.getTestContext; },
/* harmony export */   "getUBOData": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.getUBOData; },
/* harmony export */   "graphicsUtils": function() { return /* reexport safe */ _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__.graphicsUtils; },
/* harmony export */   "groupD8": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.groupD8; },
/* harmony export */   "isMobile": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.isMobile; },
/* harmony export */   "isSingleItem": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.isSingleItem; },
/* harmony export */   "loadBitmapFont": function() { return /* reexport safe */ _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__.loadBitmapFont; },
/* harmony export */   "loadDDS": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.loadDDS; },
/* harmony export */   "loadImageBitmap": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.loadImageBitmap; },
/* harmony export */   "loadJson": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.loadJson; },
/* harmony export */   "loadKTX": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.loadKTX; },
/* harmony export */   "loadSVG": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.loadSVG; },
/* harmony export */   "loadTextures": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.loadTextures; },
/* harmony export */   "loadTxt": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.loadTxt; },
/* harmony export */   "loadWebFont": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.loadWebFont; },
/* harmony export */   "parseDDS": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.parseDDS; },
/* harmony export */   "parseKTX": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.parseKTX; },
/* harmony export */   "resolveCompressedTextureUrl": function() { return /* reexport safe */ _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__.resolveCompressedTextureUrl; },
/* harmony export */   "resolveTextureUrl": function() { return /* reexport safe */ _pixi_assets__WEBPACK_IMPORTED_MODULE_6__.resolveTextureUrl; },
/* harmony export */   "settings": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.settings; },
/* harmony export */   "spritesheetAsset": function() { return /* reexport safe */ _pixi_spritesheet__WEBPACK_IMPORTED_MODULE_26__.spritesheetAsset; },
/* harmony export */   "uniformParsers": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.uniformParsers; },
/* harmony export */   "unsafeEvalSupported": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.unsafeEvalSupported; },
/* harmony export */   "utils": function() { return /* reexport safe */ _pixi_core__WEBPACK_IMPORTED_MODULE_8__.utils; }
/* harmony export */ });
/* harmony import */ var _pixi_mixin_cache_as_bitmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/mixin-cache-as-bitmap */ "./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs");
/* harmony import */ var _pixi_mixin_get_child_by_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/mixin-get-child-by-name */ "./node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs");
/* harmony import */ var _pixi_mixin_get_global_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/mixin-get-global-position */ "./node_modules/@pixi/mixin-get-global-position/lib/index.mjs");
/* harmony import */ var _filters_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filters.mjs */ "./node_modules/pixi.js/lib/filters.mjs");
/* harmony import */ var _pixi_accessibility__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pixi/accessibility */ "./node_modules/@pixi/accessibility/lib/index.mjs");
/* harmony import */ var _pixi_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi/app */ "./node_modules/@pixi/app/lib/index.mjs");
/* harmony import */ var _pixi_assets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pixi/assets */ "./node_modules/@pixi/assets/lib/index.mjs");
/* harmony import */ var _pixi_compressed_textures__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pixi/compressed-textures */ "./node_modules/@pixi/compressed-textures/lib/index.mjs");
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @pixi/display */ "./node_modules/@pixi/display/lib/index.mjs");
/* harmony import */ var _pixi_events__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pixi/events */ "./node_modules/@pixi/events/lib/index.mjs");
/* harmony import */ var _pixi_extract__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pixi/extract */ "./node_modules/@pixi/extract/lib/index.mjs");
/* harmony import */ var _pixi_filter_alpha__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @pixi/filter-alpha */ "./node_modules/@pixi/filter-alpha/lib/index.mjs");
/* harmony import */ var _pixi_filter_blur__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @pixi/filter-blur */ "./node_modules/@pixi/filter-blur/lib/index.mjs");
/* harmony import */ var _pixi_filter_color_matrix__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @pixi/filter-color-matrix */ "./node_modules/@pixi/filter-color-matrix/lib/index.mjs");
/* harmony import */ var _pixi_filter_displacement__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @pixi/filter-displacement */ "./node_modules/@pixi/filter-displacement/lib/index.mjs");
/* harmony import */ var _pixi_filter_fxaa__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @pixi/filter-fxaa */ "./node_modules/@pixi/filter-fxaa/lib/index.mjs");
/* harmony import */ var _pixi_filter_noise__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @pixi/filter-noise */ "./node_modules/@pixi/filter-noise/lib/index.mjs");
/* harmony import */ var _pixi_graphics__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @pixi/graphics */ "./node_modules/@pixi/graphics/lib/index.mjs");
/* harmony import */ var _pixi_mesh__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @pixi/mesh */ "./node_modules/@pixi/mesh/lib/index.mjs");
/* harmony import */ var _pixi_mesh_extras__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @pixi/mesh-extras */ "./node_modules/@pixi/mesh-extras/lib/index.mjs");
/* harmony import */ var _pixi_particle_container__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @pixi/particle-container */ "./node_modules/@pixi/particle-container/lib/index.mjs");
/* harmony import */ var _pixi_prepare__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @pixi/prepare */ "./node_modules/@pixi/prepare/lib/index.mjs");
/* harmony import */ var _pixi_sprite__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @pixi/sprite */ "./node_modules/@pixi/sprite/lib/index.mjs");
/* harmony import */ var _pixi_sprite_animated__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @pixi/sprite-animated */ "./node_modules/@pixi/sprite-animated/lib/index.mjs");
/* harmony import */ var _pixi_sprite_tiling__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @pixi/sprite-tiling */ "./node_modules/@pixi/sprite-tiling/lib/index.mjs");
/* harmony import */ var _pixi_spritesheet__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @pixi/spritesheet */ "./node_modules/@pixi/spritesheet/lib/index.mjs");
/* harmony import */ var _pixi_text__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @pixi/text */ "./node_modules/@pixi/text/lib/index.mjs");
/* harmony import */ var _pixi_text_bitmap__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @pixi/text-bitmap */ "./node_modules/@pixi/text-bitmap/lib/index.mjs");
/* harmony import */ var _pixi_text_html__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @pixi/text-html */ "./node_modules/@pixi/text-html/lib/index.mjs");






























//# sourceMappingURL=index.mjs.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/core */ "./node_modules/@pixi/core/lib/index.mjs");
/* harmony import */ var _pixi_unsafe_eval__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/unsafe-eval */ "./node_modules/@pixi/unsafe-eval/lib/index.mjs");
/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/fetch.js");
/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pixi.js */ "./node_modules/pixi.js/lib/index.mjs");
/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pixi-spine */ "./node_modules/pixi-spine/lib/index.mjs");
__webpack_require__(/*! ./adapter/weapp-adapter */ "./src/adapter/weapp-adapter.js");
// import "@babel/polyfill";



// Apply the patch to PIXI
(0,_pixi_unsafe_eval__WEBPACK_IMPORTED_MODULE_1__.install)({
  ShaderSystem: _pixi_core__WEBPACK_IMPORTED_MODULE_0__.ShaderSystem
});



// 获取适配屏幕大小
var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
  pixelRatio = _wx$getSystemInfoSync.pixelRatio,
  windowWidth = _wx$getSystemInfoSync.windowWidth,
  windowHeight = _wx$getSystemInfoSync.windowHeight;
var app = new pixi_js__WEBPACK_IMPORTED_MODULE_3__.Application({
  width: windowWidth * pixelRatio,
  height: windowHeight * pixelRatio,
  background: '#1099bb',
  view: canvas
});
document.body.appendChild(app.view);
pixi_js__WEBPACK_IMPORTED_MODULE_3__.Assets.load('assets/pixi-spine/dragon.json').then(onAssetsLoaded);
function onAssetsLoaded(dragonAsset) {
  // instantiate the spine animation
  var dragon = new pixi_spine__WEBPACK_IMPORTED_MODULE_4__.Spine(dragonAsset.spineData);
  dragon.skeleton.setToSetupPose();
  dragon.update(0);
  dragon.autoUpdate = false;

  // create a container for the spine animation and add the animation to it
  var dragonCage = new pixi_js__WEBPACK_IMPORTED_MODULE_3__.Container();
  dragonCage.addChild(dragon);

  // measure the spine animation and position it inside its container to align it to the origin
  var localRect = dragon.getLocalBounds();
  dragon.position.set(-localRect.x, -localRect.y);

  // now we can scale, position and rotate the container as any other display object
  var scale = Math.min(app.screen.width * 0.7 / dragonCage.width, app.screen.height * 0.7 / dragonCage.height);
  dragonCage.scale.set(scale, scale);
  dragonCage.position.set((app.screen.width - dragonCage.width) * 0.5, (app.screen.height - dragonCage.height) * 0.5);

  // add the container to the stage
  app.stage.addChild(dragonCage);

  // once position and scaled, set the animation to play
  dragon.state.setAnimation(0, 'flying', true);
  app.ticker.add(function () {
    // update the spine animation, only needed if dragon.autoupdate is set to false
    dragon.update(app.ticker.deltaMS / 1000); // IN SECONDS!
  });
}
}();
/******/ })()
;
//# sourceMappingURL=game.js.map